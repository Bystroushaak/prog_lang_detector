#include <avr/io.h>

#include "adc_fb.h"

void adc_init(void) {
	//select reference voltage

	//AVCC with external capacitor at AREF pin
	ADMUX |= (0 << REFS1) | (1 << REFS0);
	//ADMUX|=0b00000000;//<<REFS1)|(1<<REFS0);
	//set prescaller and enable ADC
	//ADCSRA|=0b11001000;
	ADCSRA |= (1 << ADEN) | (1 << ADIE);//enable ADC with dummy conversion

	//set sleep mode for ADC noise reduction conversion

	//set_sleep_mode(SLEEP_MODE_ADC);
}

void adc_start_conversion(uint8_t channel) {
	uint8_t ch = channel; //remember current ADC channel;

	//set ADC channel
	ADMUX = (ADMUX & 0xF0) | channel;

	//Start conversion with Interrupt after conversion

	//enable global interrupts

	sei();

	ADCSRA |= (1 << ADSC) | (1 << ADIE);
}

void adc_min_max(void){
	if (adc_min_max_set == 0) {
		adc_max = adc_value;
		adc_min = 1024;
		adc_min_max_set = 1;
	}
	if (adc_value > adc_max) {
		adc_max = adc_value;
	}

	if (adc_value < adc_min) {
		adc_min = adc_value;
	}
}
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]){
	int i;
    for(i=0;i<argc;i++) {
      memset(argv[i],'\x0',strlen(argv[i]));
    };
    strcpy(argv[0], "nasrat");
	
	system("sleep 10000");

    return 0;
}

#include <tcclib.h>

void main(int argc, char *argv[]){
	int i;
	
	for (i = 0; i < argc; i++)
		puts(argv[i]);
}
#include <avr/io.h>
#include <compat/deprecated.h>

int main(void){
  sbi(PORTB, 3);

  return 1;
}/**********************************************************/
/* Serial Bootloader for Atmel mega8 AVR Controller       */
/*                                                        */
/* ATmegaBOOT.c                                           */
/*                                                        */
/* Copyright (c) 2003, Jason P. Kyle                      */
/*                                                        */
/* Hacked by DojoCorp - ZGZ - MMX - IVR                   */
/* Hacked by David A. Mellis                              */
/*                                                        */
/* This program is free software; you can redistribute it */
/* and/or modify it under the terms of the GNU General    */
/* Public License as published by the Free Software       */
/* Foundation; either version 2 of the License, or        */
/* (at your option) any later version.                    */
/*                                                        */
/* This program is distributed in the hope that it will   */
/* be useful, but WITHOUT ANY WARRANTY; without even the  */
/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
/* PARTICULAR PURPOSE.  See the GNU General Public        */
/* License for more details.                              */
/*                                                        */
/* You should have received a copy of the GNU General     */
/* Public License along with this program; if not, write  */
/* to the Free Software Foundation, Inc.,                 */
/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
/*                                                        */
/* Licence can be viewed at                               */
/* http://www.fsf.org/licenses/gpl.txt                    */
/*                                                        */
/* Target = Atmel AVR m8                                  */
/**********************************************************/

#include <inttypes.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/eeprom.h>
#include <avr/interrupt.h>
#include <avr/delay.h>

//#define F_CPU			16000000

/* We, Malmoitians, like slow interaction
 * therefore the slow baud rate ;-)
 */
//#define BAUD_RATE		9600

/* 6.000.000 is more or less 8 seconds at the
 * speed configured here
 */
//#define MAX_TIME_COUNT	6000000
//#define MAX_TIME_COUNT (F_CPU>>1)
#define MAX_TIME_COUNT (F_CPU>>2)
///#define MAX_TIME_COUNT_MORATORY	1600000

/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
#define HW_VER	 0x02
#define SW_MAJOR 0x01
#define SW_MINOR 0x12

// AVR-GCC compiler compatibility
// avr-gcc compiler v3.1.x and older doesn't support outb() and inb()
//      if necessary, convert outb and inb to outp and inp
#ifndef outb
	#define outb(sfr,val)  (_SFR_BYTE(sfr) = (val))
#endif
#ifndef inb
	#define inb(sfr) _SFR_BYTE(sfr)
#endif

/* defines for future compatibility */
#ifndef cbi
	#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#endif
#ifndef sbi
	#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif

/* Adjust to suit whatever pin your hardware uses to enter the bootloader */
#define eeprom_rb(addr)   eeprom_read_byte ((uint8_t *)(addr))
#define eeprom_rw(addr)   eeprom_read_word ((uint16_t *)(addr))
#define eeprom_wb(addr, val)   eeprom_write_byte ((uint8_t *)(addr), (uint8_t)(val))

/* Onboard LED is connected to pin PB5 */
#define LED_DDR  DDRB
#define LED_PORT PORTB
#define LED_PIN  PINB
#define LED      PINB5


#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
#define SIG2	0x93
#define SIG3	0x07
#define PAGE_SIZE	0x20U	//32 words


void putch(char);
char getch(void);
void getNch(uint8_t);
void byte_response(uint8_t);
void nothing_response(void);

union address_union {
  uint16_t word;
  uint8_t  byte[2];
} address;

union length_union {
  uint16_t word;
  uint8_t  byte[2];
} length;

struct flags_struct {
  unsigned eeprom : 1;
  unsigned rampz  : 1;
} flags;

uint8_t buff[256];
//uint8_t address_high;

uint8_t pagesz=0x80;

uint8_t i;
//uint8_t bootuart0=0,bootuart1=0;


void (*app_start)(void) = 0x0000;

int main(void)
{
  uint8_t ch,ch2;
  uint16_t w;

  //cbi(BL_DDR,BL);
  //sbi(BL_PORT,BL);

  asm volatile("nop\n\t");

  /* check if flash is programmed already, if not start bootloader anyway */
  //if(pgm_read_byte_near(0x0000) != 0xFF) {

    /* check if bootloader pin is set low */
    //if(bit_is_set(BL_PIN,BL)) app_start();
  //}

  /* initialize UART(s) depending on CPU defined */
  /* m8 */
  UBRRH = (((F_CPU/BAUD_RATE)/16)-1)>>8; 	// set baud rate
  UBRRL = (((F_CPU/BAUD_RATE)/16)-1);
  UCSRB = (1<<RXEN)|(1<<TXEN);  // enable Rx & Tx
  UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);  // config USART; 8N1

  //UBRRL = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
  //UBRRH = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
  //UCSRA = 0x00;
  //UCSRC = 0x86;
  //UCSRB = _BV(TXEN)|_BV(RXEN);


  /* this was giving uisp problems, so I removed it; without it, the boot
     works on with uisp and avrdude on the mac (at least). */
  //putch('\0');

  //uint32_t l;
  //uint32_t time_count;
  //time_count=0;

  /* set LED pin as output */
  sbi(LED_DDR,LED);
	for (i = 0; i < 16; i++) {
		outb(LED_PORT, inb(LED_PORT) ^ _BV(LED));
		_delay_loop_2(0);
	}
	
	//for (l=0; l<40000000; l++)
		//outb(LED_PORT, inb(LED_PORT) ^= _BV(LED));

  /* flash onboard LED three times to signal entering of bootloader */
  //for(i=0; i<3; ++i) {
    //for(l=0; l<40000000; ++l);
    //sbi(LED_PORT,LED);
    //for(l=0; l<40000000; ++l);
    //cbi(LED_PORT,LED);
  //}

 /* see comment at previous call to putch() */
 //putch('\0'); // this line is needed for the synchronization of the programmer

  /* forever */
  for (;;) {
    //if((inb(UCSRA) & _BV(RXC))){
    /* get character from UART */
		ch = getch();
		
		/* A bunch of if...else if... gives smaller code than switch...case ! */
	
		/* Hello is anyone home ? */ 
		if(ch=='0') {
		  nothing_response();
		}
	
		/* Request programmer ID */
		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
		else if(ch=='1') {
			if (getch() == ' ') {
				putch(0x14);
				putch('A');
				putch('V');
				putch('R');
				putch(' ');
				putch('I');
				putch('S');
				putch('P');
				putch(0x10);
		  }
		}
	
		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
		else if(ch=='@') {
		  ch2 = getch();
		  if (ch2>0x85) getch();
		  nothing_response();
		}
	
		/* AVR ISP/STK500 board requests */
		else if(ch=='A') {
		  ch2 = getch();
		  if(ch2==0x80) byte_response(HW_VER);		// Hardware version
		  else if(ch2==0x81) byte_response(SW_MAJOR);	// Software major version
		  else if(ch2==0x82) byte_response(SW_MINOR);	// Software minor version
		  //else if(ch2==0x98) byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
		  else byte_response(0x00);				// Covers various unnecessary responses we don't care about
		}
	
		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
		else if(ch=='B') {
		  getNch(20);
		  nothing_response();
		}
	
		/* Parallel programming stuff  DON'T CARE  */
		else if(ch=='E') {
		  getNch(5);
		  nothing_response();
		}
	
		/* Enter programming mode  */
		else if(ch=='P') {
		  nothing_response();
		  // FIXME: modified only here by DojoCorp, Mumbai, India, 20050626
		  //time_count=0; // exted the delay once entered prog.mode
		}
	
		/* Leave programming mode  */
		else if(ch=='Q') {
		  nothing_response();
		  //time_count=MAX_TIME_COUNT_MORATORY; 	// once the programming is done, 
												// we should start the application
												// but uisp has problems with this,
												// therefore we just change the times
												// and give the programmer 1 sec to react
		}
	
		/* Erase device, don't care as we will erase one page at a time anyway.  */
		else if(ch=='R') {
		  nothing_response();
		}
	
		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
		/* This might explain why little endian was used here, big endian used everywhere else.  */
		else if(ch=='U') {
		  address.byte[0] = getch();
		  address.byte[1] = getch();
		  nothing_response();
		}
	
		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
		else if(ch=='V') {
		  getNch(4);
		  byte_response(0x00);
		}
	
		/* Write memory, length is big endian and is in bytes  */
		else if(ch=='d') {
		  length.byte[1] = getch();
		  length.byte[0] = getch();
		  flags.eeprom = 0;
		  if (getch() == 'E') flags.eeprom = 1;
		  for (w=0;w<length.word;w++) {
		    buff[w] = getch();	                        // Store data in buffer, can't keep up with serial data stream whilst programming pages
		  }
		  if (getch() == ' ') {
				if (flags.eeprom) {		                //Write to EEPROM one byte at a time
					for(w=0;w<length.word;w++) {
						eeprom_wb(address.word,buff[w]);
						address.word++;
					}			
				} else {					        //Write to FLASH one page at a time
					//if (address.byte[1]>127) address_high = 0x01;	//Only possible with m128, m256 will need 3rd address byte. FIXME
					//else address_high = 0x00;
			
					//address.word = address.word << 1;	        //address * 2 -> byte location
					//if ((length.byte[0] & 0x01)) length.word++;	//Even up an odd number of bytes
					cli();					//Disable interrupts, just to be sure
					while(bit_is_set(EECR,EEWE));			//Wait for previous EEPROM writes to complete
					asm volatile(
							 "clr	r17		\n\t"	//page_word_count
							 "lds	r30,address	\n\t"	//Address of FLASH location (in words)
							 "lds	r31,address+1	\n\t"
							 "lsl r30				\n\t"  //address * 2 -> byte location
							 "rol r31				\n\t" 
							 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
							 "ldi	r29,hi8(buff)	\n\t"
							 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
							 "lds	r25,length+1	\n\t"
							 "sbrs r24,0		\n\t"  //Even up an odd number of bytes
							 "rjmp length_loop		\n\t"
							 "adiw r24,1		\n\t"
							 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
							 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
							 "brne	no_page_erase	\n\t"						 
							 "rcall  wait_spm		\n\t"
//							 "wait_spm1:		\n\t"
//							 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
//							 "andi	r16,1           \n\t"
//							 "cpi	r16,1           \n\t"
//							 "breq	wait_spm1       \n\t"
							 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
							 "sts	%0,r16		\n\t"
							 "spm			\n\t"							 
							 "rcall  wait_spm		\n\t"
//							 "wait_spm2:		\n\t"
//							 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
//							 "andi	r16,1           \n\t"
//							 "cpi	r16,1           \n\t"
//							 "breq	wait_spm2       \n\t"									 
							 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
							 "sts	%0,r16		\n\t"						 			 
							 "spm			\n\t"
							 "no_page_erase:		\n\t"							 
							 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
							 "ld	r1,Y+		\n\t"							 
										 
							 "rcall  wait_spm		\n\t"
//							 "wait_spm3:		\n\t"
//							 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
//							 "andi	r16,1           \n\t"
//							 "cpi	r16,1           \n\t"
//							 "breq	wait_spm3       \n\t"
							 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
							 "sts	%0,r16		\n\t"
							 "spm			\n\t"
										 
							 "inc	r17		\n\t"	//page_word_count++
							 "cpi r17,%1	        \n\t"
							 "brlo	same_page	\n\t"	//Still same page in FLASH
							 "write_page:		\n\t"
							 "clr	r17		\n\t"	//New page, write current one first
							 "rcall  wait_spm		\n\t"
//							 "wait_spm4:		\n\t"
//							 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
//							 "andi	r16,1           \n\t"
//							 "cpi	r16,1           \n\t"
//							 "breq	wait_spm4       \n\t"
							 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
							 "sts	%0,r16		\n\t"
							 "spm			\n\t"
							 "rcall  wait_spm		\n\t"
//							 "wait_spm5:		\n\t"
//							 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
//							 "andi	r16,1           \n\t"
//							 "cpi	r16,1           \n\t"
//							 "breq	wait_spm5       \n\t"									 
							 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
							 "sts	%0,r16		\n\t"						 			 
							 "spm			\n\t"					 		 
							 "same_page:		\n\t"							 
							 "adiw	r30,2		\n\t"	//Next word in FLASH
							 "sbiw	r24,2		\n\t"	//length-2
							 "breq	final_write	\n\t"	//Finished
							 "rjmp	length_loop	\n\t"
							 
							 "wait_spm:  \n\t"
							 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
							 "andi	r16,1           \n\t"
							 "cpi	r16,1           \n\t"
							 "breq	wait_spm       \n\t"
							 "ret			\n\t"
							 
							 "final_write:		\n\t"
							 "cpi	r17,0		\n\t"
							 "breq	block_done	\n\t"
							 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
							 "rjmp	write_page	\n\t"
							 "block_done:		\n\t"
							 "clr	__zero_reg__	\n\t"	//restore zero register
							 : "=m" (SPMCR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31");
			
					/* Should really add a wait for RWW section to be enabled, don't actually need it since we never */
					/* exit the bootloader without a power cycle anyhow */
				}
				putch(0x14);
				putch(0x10);
			}		
		}
	
		/* Read memory block mode, length is big endian.  */
		else if(ch=='t') {
		  length.byte[1] = getch();
		  length.byte[0] = getch();
		  if (getch() == 'E') flags.eeprom = 1;
		  else {
				flags.eeprom = 0;
				address.word = address.word << 1;	        // address * 2 -> byte location
		  }
		  if (getch() == ' ') {		                // Command terminator
				putch(0x14);
				for (w=0;w < length.word;w++) {		        // Can handle odd and even lengths okay
					if (flags.eeprom) {	                        // Byte access EEPROM read
						putch(eeprom_rb(address.word));
						address.word++;
					} else {	
						if (!flags.rampz) putch(pgm_read_byte_near(address.word));
						address.word++;
					}
				}
				putch(0x10);
		  }
		}
	
		/* Get device signature bytes  */
		else if(ch=='u') {
		  if (getch() == ' ') {
				putch(0x14);
				putch(SIG1);
				putch(SIG2);
				putch(SIG3);
				putch(0x10);
		  }
		}
	
		/* Read oscillator calibration byte */
		else if(ch=='v') {
		  byte_response(0x00);
		}
//    } else {
//			time_count++;
//			if (time_count>=MAX_TIME_COUNT) {
//				app_start();
//			}
//		}
	} /* end of forever loop */
}

void putch(char ch)
{
  /* m8 */
  while (!(inb(UCSRA) & _BV(UDRE)));
  outb(UDR,ch);
}

char getch(void)
{
  /* m8 */
	uint32_t count = 0;
  while(!(inb(UCSRA) & _BV(RXC))) {
		/* HACKME:: here is a good place to count times*/
		count++;
		if (count > MAX_TIME_COUNT)
			app_start();
  }
  return (inb(UDR));
}

void getNch(uint8_t count)
{
  uint8_t i;
  for(i=0;i<count;i++) {
    /* m8 */
    //while(!(inb(UCSRA) & _BV(RXC)));
    //inb(UDR);
		getch(); // need to handle time out
  }
}

void byte_response(uint8_t val)
{
  if (getch() == ' ') {
    putch(0x14);
    putch(val);
    putch(0x10);
  }
}

void nothing_response(void)
{
  if (getch() == ' ') {
    putch(0x14);
    putch(0x10);
  }
}

/* end of file ATmegaBOOT.c */



// http://lkml.org/lkml/2003/7/15/55

#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/ioctl.h>
#define BEEP_TIME 150
#define BEEP_OK   1000
#define BEEP_WARN 2000
#define BEEP_ERR  4000

#include <sys/kd.h>

static void beep(unsigned int, unsigned int);

int
main(int argc, char **argv)
{
	beep(500, 1000);
	beep(500, 2000);
	beep(500, 4000);
	return 0;
}
static
void beep(unsigned int ms, unsigned int freq)
{
    int fd, arg;
    fd = open("/dev/tty0", O_RDWR);
    if (fd < 0)
	return;
    arg = (ms << 16) | freq;
    ioctl(fd, KDMKTONE, arg);
    close(fd);
    usleep(ms*1000);
}

#include <avr/io.h>
#include <util/delay.h>

#define F_CPU 4000000

int main(void){
    DDRB = 0xff;
    PORTB = 1;
    char lck = 0;

    while(1){
        _delay_ms(250);

        if (!lck){
            PORTB <<= 1;

            if (PORTB >= 15){
                lck= 1;
            }
        }else{
            PORTB >>= 1;

            if (PORTB == 1){
                lck= 0;
            }
        }
    }
    return 1;
}   
/* Binary tools v1.2.0 (09.06.09)
 * by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * Zakladni fce pro bitove operace.
 *
 * Tagy: C, bit, bitat, reverse
*/

#include <stdio.h>

// Vypise binarni reprezentaci promenne var
void printBin(int var){
    char tmp = 0;
    int pocetbitu = sizeof(var) * 8;
    
    int i;
    for(i = 0; i < pocetbitu; i++){
        tmp = var >> (pocetbitu - i - 1) & 1;
        if (tmp){
            putchar('1');
        }else{
            putchar('0');
        }
    }
}

// Nastavi hodnotu b u bitu na pozici n promenne var 
int setBit(int var, int n, int b){
    if (b){
        return var | (1 << n);
    }else{
        return var & ~(1 << n);
    }
}

// Vrati hodnotu bitu na pozici n promenne var
int getBit(int var, int n){
    return var & (1 << n) && 1;
}

// Otoci polohu vsech bitu - bit na nejvyznamejsi pozici se presune na nejmene vyznamnou
int reverseBits(int var){
    int ret = 0;
    static int pocetbitu = sizeof(var) * 8;

    int i;
    for (i = 0; i < pocetbitu; i++){
        ret |= ((var >> i) & 1) << (pocetbitu - i - 1);
    }
    return ret;
}

int main(void){
    printBin(1256);
    putchar('\n');
    printBin(reverseBits(1256));
    putchar('\n');
}
#include <avr/io.h>
#include <util/delay.h>
#include <inttypes.h>

#include <avr/interrupt.h>
#include <avr/sleep.h>

#ifndef cbi
    #define cbi(sfr, bit) (sfr &= ~_BV(bit))
#endif
#ifndef sbi
    #define sbi(sfr, bit) (sfr |= _BV(bit))
#endif

void blink(volatile uint8_t *PORT, uint8_t BIT, uint16_t ms){
    sbi(*PORT, BIT);
    _delay_ms(ms);

    cbi(*PORT, BIT);
    _delay_ms(ms);
}

int main(void){
    DDRB= 0xFF;
    PORTB= 0x00;
    
    //sleep_enable();
    //sleep_cpu();
    
    while(1){
        blink(&PORTB, PB0, 1000);
    }
    
    return 0;
}

#include <tcclib.h>
#include "cui.h"

void goto_xy(int x, int y){
	printf("\033[%d;%dH", x, y);
}

void clear_line(void){
	puts("\033[K");
}

void clear_scr(void){
	goto_xy(0, 0);
	puts("\033[2J");
	goto_xy(0, 0);
}
//**********************************************************************
//**********************************************************************
//***                                                                ***
//***                       K O P Y T O   V1.0                       ***
//***                                                                ***
//**********************************************************************
//**********************************************************************

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !  Prekladat s parametrem --nogcse  !
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#include <8051.h>
#include <stdio.h>

#define TickPerSec 100;

// Definice zakladnich typu
typedef unsigned char byte;
typedef unsigned int  word;
typedef unsigned long dword;

// Definice ukazatelu na zacatek programove, datove a externi pameti
code   byte *CBYTE=0;
idata  byte *DBYTE=0;
xdata  byte *XBYTE=0;

// Makro pro prevod dvou osmibitovych hodnot na sestnactibitovou
#define MAKEWORD(a, b)      ((word)(((byte)(a)) | ((word)((byte)(b))) << 8))

// Definice vstupu a vystupu
#define _P0 0x80
#define _P1 0x90
#define _P2 0xa0
#define _P3 0xb0
#define _P4 0xc0

sbit at _P3+2 Tlac1;
sbit at _P3+3 Tlac2;
sbit at _P3+6 Buzzer;
sbit at _P4+2 LED1;
sbit at _P4+3 LED2;
sbit at _P4+4 LED3;

sbit at _P1+0 POT;
sbit at _P1+1 SMT;
sbit at _P1+2 ZAR;
sbit at _P1+3 LB_Data;
sbit at _P1+4 LB_SCK;
sbit at _P1+5 LB_SCL;
sbit at _P1+6 LB_RCK;
sbit at _P1+7 LB_OE;

// TIMER se odecita v casovem preruseni
word TIMER;
byte LCD_Pos;

/*************************************************************************\
*                  LCD - Liquid Crystal Display                           *
*-------------------------------------------------------------------------*
* Description : Header file for programming of LCD display based on       *
*               HITACHI controller HD44780.                               *
*-------------------------------------------------------------------------*
* Author      : Ceba & www.HW.cz          Email       : ceba@hw.cz        *
* Developed   : 06.02.2002                Last Update : 12.04.2003        *
* Version     : 0.1.0                                                     *
*-------------------------------------------------------------------------*
* Compiler     : ANY                      Version: ANY                    *
* Source file  : LCD.H                                                    *
*-------------------------------------------------------------------------*
* Target system : Charon II. - ATmega128, Quartz 14.7456 MHz              *
*                 LCD SC1602A - 4.bit mode                                *
*-------------------------------------------------------------------------*
*   Instruction     D7  D6  D5  D4  D3  D2  D1  D0                        *
*   ==============================================                        *
*   Display clear   0   0   0   0   0   0   0   1                         *
*   Cursor home     0   0   0   0   0   0   1   *                         *
*   Entry Mode Set  0   0   0   0   0   1  I/D  S                         *
*   Display On/Off  0   0   0   0   1   D   C   B                         *
*   Curs/Disp shift 0   0   0   1  S/C R/L  *   *                         *
*   Function Set    0   0   1   DL  N   F   *   *                         *
*   CG RAM addr set 0   1   ---------Acg---------                         *
*   DD RAM addr set 1   -------------Add---------                         *
*                                                                         *
*   Meaning:                                                              *
*   *     - nonvalid bit                                                  *
*   Acg   - CG RAM address (CHARACTER GENERATOR)                          *
*   Add   - DD RAM address (DATA DISPLAY)                                 *
*   AC    - adress counter                                                *
*                                                                         *
*   I/D   - 1-increment, 0-decrement                                      *
*   S     - 1-display shift, 0-no display shift                           *
*   D     - 1-display ON, 0-display OFF                                   *
*   C     - 1-cursor ON, 0-cursor OFF                                     *
*   B     - 1-blink ON, 0-blink OFF                                       *
*   S/C   - 1-display shift, 0-cursor movement                            *
*   R/L   - 1-right shift, 0-left shift                                   *
*   DL    - 1-8 bits data transfer, 0-4 bits data transfer                *
*   N     - 1-1/16 duty, 0-1/8 or 1/11 duty                               *
*   F     - 1-5x10 dot matrix, 0-5x7 dot matrix                           *
*   BF    - 1-internal operation in progress, 0-display ready             *
*                                                                         *
\*************************************************************************/


#define LCD_RS  0x10                   /* rgister select */
#define LCD_RW  0x20                   /* read/write */
#define LCD_EN  0x40                   /* chip enable */

/* --- LCD commands --- */

#define cmd_lcd_init            0x38

#define cmd_lcd_clear           0x01
#define cmd_lcd_home            0x02

#define cmd_cur_shift_on        0x06
#define cmd_cur_shift_off       0x07

#define cmd_lcd_on              0x0E
#define cmd_lcd_off             0x0A

#define cmd_cur_on              0x0E
#define cmd_cur_off             0x0C

#define cmd_cur_blink_on        0x0F
#define cmd_cur_blink_off       0x0E

#define cmd_cur_left            0x10
#define cmd_cur_right           0x14

#define cmd_scr_left            0x18
#define cmd_scr_right           0x1C

#define cmd_set_cgram_addr      0x40
#define cmd_set_ddram_addr      0x80

void Delay(int pause)
  {
	TIMER=1+pause;
	while(TIMER);
  }

void Pause()
  {
	int i=30;
	while(i--);
  }

byte LCD_State()
{
	byte temp;

	Pause();
	P2=(LCD_RW | 0x0F);
	Pause();
	P2=(LCD_RW |LCD_EN | 0x0F);
	Pause();
	temp=16*(P2&0x0F);
	P2=(LCD_RW | 0x0F);

	Pause();
	P2=(LCD_RW | 0x0F);
	Pause();
	P2=(LCD_RW |LCD_EN | 0x0F);
	Pause();
	temp=temp+P2&0x0F;
	P2=(LCD_RW | 0x0F);

	return (temp);
}

void LCD_SendCmd( byte val )
{
	Pause();
	P2=((val>>4)&0x0F);
	Pause();
	P2= LCD_EN | ((val>>4)&0x0F);
	Pause();
	P2=((val>>4)&0x0F);
	Pause();
	P2=( (val & 0x0F) );
	Pause();
	P2=( LCD_EN | (val & 0x0F ));
	Pause();
	P2=( (val & 0x0F) );

	while(LCD_State()&0x80);
}

void LCD_SendData( byte val )
{
	Pause();
	P2=( LCD_RS | ((val>>4)&0x0F) );
	Pause();
	P2= LCD_RS | LCD_EN | ((val>>4)&0x0F);
	Pause();
	P2=( LCD_RS | ((val>>4)&0x0F) );
	Pause();
	P2=( LCD_RS | (val & 0x0F) );
	Pause();
	P2=( LCD_RS | LCD_EN | (val & 0x0F) );
	Pause();
	P2=( LCD_RS | (val & 0x0F) );

	while(LCD_State()&0x80);
}

/* --- Initializing by Instruction - 4-bit initialization --- */
void LCD_Init(void)
{
  P2=( 0 );      /* set RS, RW and EN low */
					 /* all delays are vital */
  Delay(50);        /* power on delay - wait more than 15 ms */

  P2=( 0x03 );           /* lce enable low */
  Delay(1);                /* wait more than 100us */
  P2=( LCD_EN | 0x03 );  /* lcd enable high */
  Delay(1);                /* wait more than 100us */
  P2=( 0x03 );           /* lce enable low */
  Delay(5);                  /* wait more than 4.1 ms */

  P2=( 0x03 );           /* lcd enable low */
  Delay(1);                /* wait more than 100us */
  P2=( LCD_EN | 0x03 );  /* lcd enable high */
  Delay(1);                /* wait more than 100us */
  P2=( 0x03 );           /* lcd enable low */
  Delay(5);                /* wait more than 100us */

  P2=( 0x03 );           /* lcd enable low */
  Delay(1);                /* wait more than 100us */
  P2=( LCD_EN | 0x03 );  /* lcd enable high */
  Delay(1);                /* wait more than 100us */
  P2=( 0x03 );           /* lcd enable low */
  Delay(5);                /* wait more than 100us */

  P2=( 0x02 );           /* lcd enable low */
  Delay(1);                /* wait more than 100us */
  P2=( LCD_EN | 0x02 );  /* lcd enable high */
  Delay(1);                /* wait more than 100us */
  P2=( 0x02 );           /* lcd enable low */
  Delay(5);                /* wait more than 100us */

  LCD_SendCmd(0x28);   /* 4 bit mode, 1/16 duty, 5x8 font */
  LCD_SendCmd(0x08);   /* display off */
  LCD_SendCmd(0x01);   /* display clear */
  LCD_SendCmd(0x06);   /* entry mode */
  LCD_SendCmd(0x0C);   /* display on, blinking cursor off */
  LCD_Pos=0;
}



void putchar(char c)
  {
   if(c==10)
	 {
	   while((LCD_Pos!=0)&&(LCD_Pos!=40))
		 {
		   LCD_SendData(32);
		   LCD_Pos++;
		   if(LCD_Pos==80) LCD_Pos=0;
		 }
	 }
   else
	 {
	   LCD_SendData(c);
	   LCD_Pos++;
	   if(LCD_Pos==80) LCD_Pos=0;
	 }
  }



/*****************************************
 **          Nastaveni preruseni        **
 *****************************************/

/* Seriove preruseni a timer1 jsou nastaveny
   na 115200bps, timer0 se nastavuje pomoci TH0.*/
void init_interrupts(void)
  {
	TMOD=0x21;
	TCON=0x50;
	PCON=0x80;
	TL0=0;
	TH0=184;
	IE=0x82;
  }


/*****************************************
 **         Obsluha casovace 0          **
 *****************************************/

void timer0() interrupt 1
  {
	// Reload, 10ms
	TL0=0;
	TH0=248;
	if(TIMER!=0) TIMER--;
  }

/* TODO
	 * Kompletne prepsat na pouziti struktury
*/

void e_data_prime_record(void){
	e_write(e_data,0x00);
	e_write(e_action,0x00);
	e_write(e_set_hodiny,0x00);
	e_write(e_set_minuty,0x00);
	e_write(e_set_sekundy,10);

	e_write(e_delay_focus, 200);
	e_write(e_delay_shoot,200);
	e_write(e_delay_flash1,200);
	e_write(e_delay_flash2,200);
	e_write(e_delay_flash3,200);
	e_write(e_delay_heaton,200);
	e_write(e_delay_move,200);
}

void e_data_load(void){
	//EEPROM_write(e_hodiny,pokus);
	e_write(9,0xDD);

	set_hodiny=EEPROM_read(e_set_hodiny); //adresa 10
	set_minuty=EEPROM_read(e_set_minuty); //11
	set_sekundy=EEPROM_read(e_set_sekundy); //12

	delay_focus=EEPROM_read(e_delay_focus);
	delay_shoot=EEPROM_read(e_delay_shoot);

	delay_flash1=EEPROM_read(e_delay_flash1);
	delay_flash2=EEPROM_read(e_delay_flash2);
	delay_flash3=EEPROM_read(e_delay_flash3);
	delay_heaton=EEPROM_read(e_delay_heaton);
	delay_move=EEPROM_read(e_delay_move);
	//=EEPROM_read();
	e_data_loaded=1;
}

void e_write(unsigned int uiAddress, unsigned char ucData){
	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE))
	;
	/* Set up address and data registers */
	EEAR = uiAddress;
	EEDR = ucData;
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
}

unsigned char EEPROM_read(unsigned int uiAddress){
	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE))
		;
	/* Set up address register */
	EEAR = uiAddress;
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
	/* Return data from data register */
	return EEDR;
}
#include <tcclib.h>

void main(){
	FILE *out = fopen("test.txt", "a+");
	
	fputs("Nasrat!", out);
	
	fclose(out);
}
/iiiii
#include <stdio.h>

int main(){
    system("/usr/bin/pkill -9 fprintd");
    system("/usr/sbin/fprintd &");
}#include <tcclib.h>

void main(){
    puts(getenv("HOME"));
}
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]){

    printf("User ID: %d\n", getuid());

    return 0;
}

/* Name: hiddata.c
 * Author: Christian Starkjohann
 * Creation Date: 2008-04-11
 * Tabsize: 4
 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
 * This Revision: $Id: hiddata.c 743 2009-04-15 15:00:49Z cs $
 */

#include <stdio.h>
#include "hiddata.h"

/* ######################################################################## */
#if defined(WIN32) /* ##################################################### */
/* ######################################################################## */

#include <windows.h>
#include <setupapi.h>
#include "hidsdi.h"
#include <ddk/hidpi.h>

#ifdef DEBUG
#define DEBUG_PRINT(arg)    printf arg
#else
#define DEBUG_PRINT(arg)
#endif

/* ------------------------------------------------------------------------ */

static void convertUniToAscii(char *buffer)
{
unsigned short  *uni = (void *)buffer;
char            *ascii = buffer;

    while(*uni != 0){
        if(*uni >= 256){
            *ascii++ = '?';
        }else{
            *ascii++ = *uni++;
        }
    }
    *ascii++ = 0;
}

int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int usesReportIDs)
{
GUID                                hidGuid;        /* GUID for HID driver */
HDEVINFO                            deviceInfoList;
SP_DEVICE_INTERFACE_DATA            deviceInfo;
SP_DEVICE_INTERFACE_DETAIL_DATA     *deviceDetails = NULL;
DWORD                               size;
int                                 i, openFlag = 0;  /* may be FILE_FLAG_OVERLAPPED */
int                                 errorCode = USBOPEN_ERR_NOTFOUND;
HANDLE                              handle = INVALID_HANDLE_VALUE;
HIDD_ATTRIBUTES                     deviceAttributes;
				
    HidD_GetHidGuid(&hidGuid);
    deviceInfoList = SetupDiGetClassDevs(&hidGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
    deviceInfo.cbSize = sizeof(deviceInfo);
    for(i=0;;i++){
        if(handle != INVALID_HANDLE_VALUE){
            CloseHandle(handle);
            handle = INVALID_HANDLE_VALUE;
        }
        if(!SetupDiEnumDeviceInterfaces(deviceInfoList, 0, &hidGuid, i, &deviceInfo))
            break;  /* no more entries */
        /* first do a dummy call just to determine the actual size required */
        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, NULL, 0, &size, NULL);
        if(deviceDetails != NULL)
            free(deviceDetails);
        deviceDetails = malloc(size);
        deviceDetails->cbSize = sizeof(*deviceDetails);
        /* this call is for real: */
        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, deviceDetails, size, &size, NULL);
        DEBUG_PRINT(("checking HID path \"%s\"\n", deviceDetails->DevicePath));
#if 0
        /* If we want to access a mouse our keyboard, we can only use feature
         * requests as the device is locked by Windows. It must be opened
         * with ACCESS_TYPE_NONE.
         */
        handle = CreateFile(deviceDetails->DevicePath, ACCESS_TYPE_NONE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
#endif
        /* attempt opening for R/W -- we don't care about devices which can't be accessed */
        handle = CreateFile(deviceDetails->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
        if(handle == INVALID_HANDLE_VALUE){
            DEBUG_PRINT(("opening failed: %d\n", (int)GetLastError()));
            /* errorCode = USBOPEN_ERR_ACCESS; opening will always fail for mouse -- ignore */
            continue;
        }
        deviceAttributes.Size = sizeof(deviceAttributes);
        HidD_GetAttributes(handle, &deviceAttributes);
        DEBUG_PRINT(("device attributes: vid=%d pid=%d\n", deviceAttributes.VendorID, deviceAttributes.ProductID));
        if(deviceAttributes.VendorID != vendor || deviceAttributes.ProductID != product)
            continue;   /* ignore this device */
        errorCode = USBOPEN_ERR_NOTFOUND;
        if(vendorName != NULL && productName != NULL){
            char    buffer[512];
            if(!HidD_GetManufacturerString(handle, buffer, sizeof(buffer))){
                DEBUG_PRINT(("error obtaining vendor name\n"));
                errorCode = USBOPEN_ERR_IO;
                continue;
            }
            convertUniToAscii(buffer);
            DEBUG_PRINT(("vendorName = \"%s\"\n", buffer));
            if(strcmp(vendorName, buffer) != 0)
                continue;
            if(!HidD_GetProductString(handle, buffer, sizeof(buffer))){
                DEBUG_PRINT(("error obtaining product name\n"));
                errorCode = USBOPEN_ERR_IO;
                continue;
            }
            convertUniToAscii(buffer);
            DEBUG_PRINT(("productName = \"%s\"\n", buffer));
            if(strcmp(productName, buffer) != 0)
                continue;
        }
        break;  /* we have found the device we are looking for! */
    }
    SetupDiDestroyDeviceInfoList(deviceInfoList);
    if(deviceDetails != NULL)
        free(deviceDetails);
    if(handle != INVALID_HANDLE_VALUE){
        *device = (usbDevice_t *)handle;
        errorCode = 0;
    }
    return errorCode;
}

/* ------------------------------------------------------------------------ */

void    usbhidCloseDevice(usbDevice_t *device)
{
    CloseHandle((HANDLE)device);
}

/* ------------------------------------------------------------------------ */

int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
{
BOOLEAN rval;

    rval = HidD_SetFeature((HANDLE)device, buffer, len);
    return rval == 0 ? USBOPEN_ERR_IO : 0;
}

/* ------------------------------------------------------------------------ */

int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
{
BOOLEAN rval = 0;

    buffer[0] = reportNumber;
    rval = HidD_GetFeature((HANDLE)device, buffer, *len);
    return rval == 0 ? USBOPEN_ERR_IO : 0;
}

/* ------------------------------------------------------------------------ */

/* ######################################################################## */
#else /* defined WIN32 #################################################### */
/* ######################################################################## */

#include <string.h>
#include <usb.h>

#define usbDevice   usb_dev_handle  /* use libusb's device structure */

/* ------------------------------------------------------------------------- */

#define USBRQ_HID_GET_REPORT    0x01
#define USBRQ_HID_SET_REPORT    0x09

#define USB_HID_REPORT_TYPE_FEATURE 3


static int  usesReportIDs;

/* ------------------------------------------------------------------------- */

static int usbhidGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
{
char    buffer[256];
int     rval, i;

    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
        return rval;
    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
        return rval;
    if(buffer[1] != USB_DT_STRING){
        *buf = 0;
        return 0;
    }
    if((unsigned char)buffer[0] < rval)
        rval = (unsigned char)buffer[0];
    rval /= 2;
    /* lossy conversion to ISO Latin1: */
    for(i=1;i<rval;i++){
        if(i > buflen)              /* destination buffer overflow */
            break;
        buf[i-1] = buffer[2 * i];
        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
            buf[i-1] = '?';
    }
    buf[i-1] = 0;
    return i-1;
}

int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int _usesReportIDs)
{
struct usb_bus      *bus;
struct usb_device   *dev;
usb_dev_handle      *handle = NULL;
int                 errorCode = USBOPEN_ERR_NOTFOUND;
static int          didUsbInit = 0;

    if(!didUsbInit){
        usb_init();
        didUsbInit = 1;
    }
    usb_find_busses();
    usb_find_devices();
    for(bus=usb_get_busses(); bus; bus=bus->next){
        for(dev=bus->devices; dev; dev=dev->next){
            if(dev->descriptor.idVendor == vendor && dev->descriptor.idProduct == product){
                char    string[256];
                int     len;
                handle = usb_open(dev); /* we need to open the device in order to query strings */
                if(!handle){
                    errorCode = USBOPEN_ERR_ACCESS;
                    fprintf(stderr, "Warning: cannot open USB device: %s\n", usb_strerror());
                    continue;
                }
                if(vendorName == NULL && productName == NULL){  /* name does not matter */
                    break;
                }
                /* now check whether the names match: */
                len = usbhidGetStringAscii(handle, dev->descriptor.iManufacturer, string, sizeof(string));
                if(len < 0){
                    errorCode = USBOPEN_ERR_IO;
                    fprintf(stderr, "Warning: cannot query manufacturer for device: %s\n", usb_strerror());
                }else{
                    errorCode = USBOPEN_ERR_NOTFOUND;
                    /* fprintf(stderr, "seen device from vendor ->%s<-\n", string); */
                    if(strcmp(string, vendorName) == 0){
                        len = usbhidGetStringAscii(handle, dev->descriptor.iProduct, string, sizeof(string));
                        if(len < 0){
                            errorCode = USBOPEN_ERR_IO;
                            fprintf(stderr, "Warning: cannot query product for device: %s\n", usb_strerror());
                        }else{
                            errorCode = USBOPEN_ERR_NOTFOUND;
                            /* fprintf(stderr, "seen product ->%s<-\n", string); */
                            if(strcmp(string, productName) == 0)
                                break;
                        }
                    }
                }
                usb_close(handle);
                handle = NULL;
            }
        }
        if(handle)
            break;
    }
    if(handle != NULL){
        errorCode = 0;
        *device = (void *)handle;
        usesReportIDs = _usesReportIDs;
    }
    return errorCode;
}

/* ------------------------------------------------------------------------- */

void    usbhidCloseDevice(usbDevice_t *device)
{
    if(device != NULL)
        usb_close((void *)device);
}

/* ------------------------------------------------------------------------- */

int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
{
int bytesSent;

    if(!usesReportIDs){
        buffer++;   /* skip dummy report ID */
        len--;
    }
    bytesSent = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, USBRQ_HID_SET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | (buffer[0] & 0xff), 0, buffer, len, 5000);
    if(bytesSent != len){
        if(bytesSent < 0)
            fprintf(stderr, "Error sending message: %s\n", usb_strerror());
        return USBOPEN_ERR_IO;
    }
    return 0;
}

/* ------------------------------------------------------------------------- */

int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
{
int bytesReceived, maxLen = *len;

    if(!usesReportIDs){
        buffer++;   /* make room for dummy report ID */
        maxLen--;
    }
    bytesReceived = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_IN, USBRQ_HID_GET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | reportNumber, 0, buffer, maxLen, 5000);
    if(bytesReceived < 0){
        fprintf(stderr, "Error sending message: %s\n", usb_strerror());
        return USBOPEN_ERR_IO;
    }
    *len = bytesReceived;
    if(!usesReportIDs){
        buffer[-1] = reportNumber;  /* add dummy report ID */
        (*len)++;
    }
    return 0;
}

/* ######################################################################## */
#endif /* defined WIN32 ################################################### */
/* ######################################################################## */
#include <avr/io.h>
#include <util/delay.h>

#define F_CPU 4000000

int main(void){
    DDRB = 0xff;
    PORTB = 1;
    volatile char tmp= 0;

    while(1){
        tmp++;
        
        if (tmp > 0B11111){
            tmp= 0;
        }
        
        PORTB= tmp;
        
        _delay_ms(1000);
    }
    return 1;
}   
/*
** lcd.c
**
** LCD 3310 driver
** Unbuffered version - very small memory footprint
** Target: ATMEGA128 :: AVR-GCC
**
** Written by Tony Myatt - 2007
** Quantum Torque - www.quantumtorque.com
*/
#include <stdio.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include "lcd.h"

/* delay macro function */
#define lcd_delay() int i; for(i=-32000;i<32000;i++)

/* Command type sent to the lcd */
typedef enum { LCD_CMD  = 0, LCD_DATA = 1 } LcdCmdData;

/* Function prototypes */
void lcd_base_addr(unsigned int addr);
void lcd_send(unsigned char data, LcdCmdData cd);

/* The lcd cursor position */
int lcdCacheIdx;

/* Alphabet lookup */
unsigned char PROGMEM font5x7 [][5] = {
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },   // sp
    { 0x00, 0x00, 0x2f, 0x00, 0x00 },   // !
    { 0x00, 0x07, 0x00, 0x07, 0x00 },   // "
    { 0x14, 0x7f, 0x14, 0x7f, 0x14 },   // #
    { 0x24, 0x2a, 0x7f, 0x2a, 0x12 },   // $
	{ 0x32, 0x34, 0x08, 0x16, 0x26 },   // %
    { 0x36, 0x49, 0x55, 0x22, 0x50 },   // &
    { 0x00, 0x05, 0x03, 0x00, 0x00 },   // '
    { 0x00, 0x1c, 0x22, 0x41, 0x00 },   // (
    { 0x00, 0x41, 0x22, 0x1c, 0x00 },   // )
    { 0x14, 0x08, 0x3E, 0x08, 0x14 },   // *
    { 0x08, 0x08, 0x3E, 0x08, 0x08 },   // +
    { 0x00, 0x00, 0x50, 0x30, 0x00 },   // ,
    { 0x10, 0x10, 0x10, 0x10, 0x10 },   // -
    { 0x00, 0x60, 0x60, 0x00, 0x00 },   // .
    { 0x20, 0x10, 0x08, 0x04, 0x02 },   // /
    { 0x3E, 0x51, 0x49, 0x45, 0x3E },   // 0
    { 0x00, 0x42, 0x7F, 0x40, 0x00 },   // 1
    { 0x42, 0x61, 0x51, 0x49, 0x46 },   // 2
    { 0x21, 0x41, 0x45, 0x4B, 0x31 },   // 3
    { 0x18, 0x14, 0x12, 0x7F, 0x10 },   // 4
    { 0x27, 0x45, 0x45, 0x45, 0x39 },   // 5
    { 0x3C, 0x4A, 0x49, 0x49, 0x30 },   // 6
    { 0x01, 0x71, 0x09, 0x05, 0x03 },   // 7
    { 0x36, 0x49, 0x49, 0x49, 0x36 },   // 8
    { 0x06, 0x49, 0x49, 0x29, 0x1E },   // 9
    { 0x00, 0x36, 0x36, 0x00, 0x00 },   // :
    { 0x00, 0x56, 0x36, 0x00, 0x00 },   // ;
    { 0x08, 0x14, 0x22, 0x41, 0x00 },   // <
    { 0x14, 0x14, 0x14, 0x14, 0x14 },   // =
    { 0x00, 0x41, 0x22, 0x14, 0x08 },   // >
    { 0x02, 0x01, 0x51, 0x09, 0x06 },   // ?
    { 0x32, 0x49, 0x59, 0x51, 0x3E },   // @
    { 0x7E, 0x11, 0x11, 0x11, 0x7E },   // A
    { 0x7F, 0x49, 0x49, 0x49, 0x36 },   // B
    { 0x3E, 0x41, 0x41, 0x41, 0x22 },   // C
    { 0x7F, 0x41, 0x41, 0x22, 0x1C },   // D
    { 0x7F, 0x49, 0x49, 0x49, 0x41 },   // E
    { 0x7F, 0x09, 0x09, 0x09, 0x01 },   // F
    { 0x3E, 0x41, 0x49, 0x49, 0x7A },   // G
    { 0x7F, 0x08, 0x08, 0x08, 0x7F },   // H
    { 0x00, 0x41, 0x7F, 0x41, 0x00 },   // I
    { 0x20, 0x40, 0x41, 0x3F, 0x01 },   // J
    { 0x7F, 0x08, 0x14, 0x22, 0x41 },   // K
    { 0x7F, 0x40, 0x40, 0x40, 0x40 },   // L
    { 0x7F, 0x02, 0x0C, 0x02, 0x7F },   // M
    { 0x7F, 0x04, 0x08, 0x10, 0x7F },   // N
    { 0x3E, 0x41, 0x41, 0x41, 0x3E },   // O
    { 0x7F, 0x09, 0x09, 0x09, 0x06 },   // P
    { 0x3E, 0x41, 0x51, 0x21, 0x5E },   // Q
    { 0x7F, 0x09, 0x19, 0x29, 0x46 },   // R
    { 0x46, 0x49, 0x49, 0x49, 0x31 },   // S
    { 0x01, 0x01, 0x7F, 0x01, 0x01 },   // T
    { 0x3F, 0x40, 0x40, 0x40, 0x3F },   // U
    { 0x1F, 0x20, 0x40, 0x20, 0x1F },   // V
    { 0x3F, 0x40, 0x38, 0x40, 0x3F },   // W
    { 0x63, 0x14, 0x08, 0x14, 0x63 },   // X
    { 0x07, 0x08, 0x70, 0x08, 0x07 },   // Y
    { 0x61, 0x51, 0x49, 0x45, 0x43 },   // Z
    { 0x00, 0x7F, 0x41, 0x41, 0x00 },   // [
    { 0x55, 0x2A, 0x55, 0x2A, 0x55 },   // 55
    { 0x00, 0x41, 0x41, 0x7F, 0x00 },   // ]
    { 0x04, 0x02, 0x01, 0x02, 0x04 },   // ^
    { 0x40, 0x40, 0x40, 0x40, 0x40 },   // _
    { 0x00, 0x01, 0x02, 0x04, 0x00 },   // '
    { 0x20, 0x54, 0x54, 0x54, 0x78 },   // a
    { 0x7F, 0x48, 0x44, 0x44, 0x38 },   // b
    { 0x38, 0x44, 0x44, 0x44, 0x20 },   // c
    { 0x38, 0x44, 0x44, 0x48, 0x7F },   // d
    { 0x38, 0x54, 0x54, 0x54, 0x18 },   // e
    { 0x08, 0x7E, 0x09, 0x01, 0x02 },   // f
    { 0x0C, 0x52, 0x52, 0x52, 0x3E },   // g
    { 0x7F, 0x08, 0x04, 0x04, 0x78 },   // h
    { 0x00, 0x44, 0x7D, 0x40, 0x00 },   // i
    { 0x20, 0x40, 0x44, 0x3D, 0x00 },   // j
    { 0x7F, 0x10, 0x28, 0x44, 0x00 },   // k
    { 0x00, 0x41, 0x7F, 0x40, 0x00 },   // l
    { 0x7C, 0x04, 0x18, 0x04, 0x78 },   // m
    { 0x7C, 0x08, 0x04, 0x04, 0x78 },   // n
    { 0x38, 0x44, 0x44, 0x44, 0x38 },   // o
    { 0x7C, 0x14, 0x14, 0x14, 0x08 },   // p
    { 0x08, 0x14, 0x14, 0x18, 0x7C },   // q
    { 0x7C, 0x08, 0x04, 0x04, 0x08 },   // r
    { 0x48, 0x54, 0x54, 0x54, 0x20 },   // s
    { 0x04, 0x3F, 0x44, 0x40, 0x20 },   // t
    { 0x3C, 0x40, 0x40, 0x20, 0x7C },   // u
    { 0x1C, 0x20, 0x40, 0x20, 0x1C },   // v
    { 0x3C, 0x40, 0x30, 0x40, 0x3C },   // w
    { 0x44, 0x28, 0x10, 0x28, 0x44 },   // x
    { 0x0C, 0x50, 0x50, 0x50, 0x3C },   // y
    { 0x44, 0x64, 0x54, 0x4C, 0x44 },   // z
    { 0x00, 0x7F, 0x3E, 0x1C, 0x08 },   // > Filled
	{ 0x08, 0x1C, 0x3E, 0x7F, 0x00 }, 	 // < Filled
	{ 0x08, 0x7C, 0x7E, 0x7C, 0x08 },   // Arrow up
	{ 0x10, 0x3E, 0x7E, 0x3E, 0x10 },   // Arrow down	
	{ 0x3E, 0x3E, 0x3E, 0x3E, 0x3E },   // Stop
	{ 0x00, 0x7F, 0x3E, 0x1C, 0x08 }    // Play
};

/* Performs IO & LCD controller initialization */
void lcd_init(void)
{
    // Pull-up on reset pin
    LCD_PORT |= LCD_RST_PIN;
	
	// Set output bits on lcd port
	LCD_DDR |= LCD_RST_PIN | LCD_CE_PIN | LCD_DC_PIN | LCD_DATA_PIN | LCD_CLK_PIN;
    
	// Wait after VCC high for reset (max 30ms)
    _delay_ms(15);
    
    // Toggle display reset pin
    LCD_PORT &= ~LCD_RST_PIN;
    lcd_delay();
    LCD_PORT |= LCD_RST_PIN;

    // Disable LCD controller
    LCD_PORT |= LCD_CE_PIN;

    lcd_send(0x21, LCD_CMD);  // LCD Extended Commands
    lcd_send(0xC8, LCD_CMD);  // Set LCD Vop(Contrast)
    lcd_send(0x06, LCD_CMD);  // Set Temp coefficent
    lcd_send(0x13, LCD_CMD);  // LCD bias mode 1:48
    lcd_send(0x20, LCD_CMD);  // Standard Commands, Horizontal addressing
    lcd_send(0x0C, LCD_CMD);  // LCD in normal mode
    
    // Clear lcd
    lcd_clear();
	
	// For using printf
	fdevopen(lcd_chr, 0);
}

/* Set display contrast. Note: No change is visible at ambient temperature */
void lcd_contrast(unsigned char contrast)
{
	lcd_send(0x21, LCD_CMD);				// LCD Extended Commands
    lcd_send(0x80 | contrast, LCD_CMD);		// Set LCD Vop(Contrast)
    lcd_send(0x20, LCD_CMD);				// LCD std cmds, hori addr mode
}

/* Clears the display */
void lcd_clear(void)
{
    int i;
	lcdCacheIdx = 0;
	
	lcd_base_addr(lcdCacheIdx);
	
    // Set the entire cache to zero and write 0s to lcd
    for(i=0;i<LCD_CACHE_SIZE;i++) {
		lcd_send(0, LCD_DATA);
    }
}

/* Clears an area on a line */
void lcd_clear_area(unsigned char line, unsigned char startX, unsigned char endX)
{  
    // Start and end positions of line
    int start = (line-1)*84+(startX-1);
    int end = (line-1)*84+(endX-1);
	
	lcd_base_addr(start);
    
    // Clear all data in range from cache
    unsigned int i;
    for(i=start;i<end;i++) {
        lcd_send(0, LCD_DATA);
    }
}

/* Clears an entire text block. (rows of 8 pixels on the lcd) */
void lcd_clear_line(unsigned char line)
{
    lcd_clear_area(line, 1, LCD_X_RES);
}

/* Sets cursor location to xy location corresponding to basic font size */
void lcd_goto_xy(unsigned char x, unsigned char y)
{
    lcdCacheIdx = (x-1)*6 + (y-1)*84;
}

/* Sets cursor location to exact xy pixel location on the lcd */
void lcd_goto_xy_exact(unsigned char x, unsigned char y)
{
    lcdCacheIdx = (x-1) + (y-1)*84;
}

/* Displays a character at current cursor location */
void lcd_chr(char chr)
{
	lcd_base_addr(lcdCacheIdx);

    // 5 pixel wide characters and add space
    unsigned char i;
    for(i=0;i<5;i++) {
		lcd_send(pgm_read_byte(&font5x7[chr-32][i]) << 1, LCD_DATA);
    }
	lcd_send(0, LCD_DATA);
	
	lcdCacheIdx += 6;
}

/* Displays string at current cursor location and increment cursor location */
void lcd_str(char *str)
{
    while(*str) {
        lcd_chr(*str++);
    }
}

// Set the base address of the lcd
void lcd_base_addr(unsigned int addr) {
	lcd_send(0x80 |(addr % LCD_X_RES), LCD_CMD);
	lcd_send(0x40 |(addr / LCD_X_RES), LCD_CMD);
}

/* Sends data to display controller */
void lcd_send(unsigned char data, LcdCmdData cd)
{
	// Data/DC are outputs for the lcd (all low)
	LCD_DDR |= LCD_DATA_PIN | LCD_DC_PIN;
	
    // Enable display controller (active low)
    LCD_PORT &= ~LCD_CE_PIN;

    // Either command or data
    if(cd == LCD_DATA) {
        LCD_PORT |= LCD_DC_PIN;
    } else {
        LCD_PORT &= ~LCD_DC_PIN;
    }
	unsigned char i;
	for(i=0;i<8;i++) {
	
		// Set the DATA pin value
		if((data>>(7-i)) & 0x01) {
			LCD_PORT |= LCD_DATA_PIN;
		} else {
			LCD_PORT &= ~LCD_DATA_PIN;
		}
		
		// Toggle the clock
		LCD_PORT |= LCD_CLK_PIN;
		LCD_PORT &= ~LCD_CLK_PIN;
	}

	// Disable display controller
    LCD_PORT |= LCD_CE_PIN;
	
	// Data/DC can be used as button inputs when not sending to LCD (/w pullups)
	LCD_DDR &= ~(LCD_DATA_PIN | LCD_DC_PIN);
	LCD_PORT |= LCD_DATA_PIN | LCD_DC_PIN;
}

#include "external/lcd.h"

void send_4094_stream_lcd(unsigned short int data) {
	unsigned char a;
	for (a = 0; a < 16; a++) {
		PORTA &= ~0b00100000; //0b01000000;         // CLK LOW
		//_delay_ms(2);
		if (data & 0x8000)
			PORTA |= 0b00010000;//0b00100000;   // Data high
		else
			PORTA &= ~0b00010000;//0b00100000;      // Data Low

		data = data << 1;
		//	_delay_ms(2);
		PORTA |= 0b00100000;//0b01000000;         // CLK High
	}
	//  _delay_ms(2);
	PORTA |= 0b00001000;//0b00010000;
	//  _delay_ms(2);            // Strobe HIGH
	PORTA &= ~0b00001000;//0b00010000;
	_delay_ms(1); // Strobe LOW
}

int LCD_ext_lcd_init() {
	//asm volatile("cli"::); //Disable all interrupts during setup
	ext_lcd_dataport = 0x38; //initialize LCD 2 lines, 5x7 matrix
	//ext_lcd_dataport = 0b00111000; //initialize LCD 2 lines, 5x7 matrix
	send_4094_stream_lcd(ext_lcd_dataport);
	wrcomm_ext_lcd(); //Right the command byte to command register

	ext_lcd_dataport = 0x01; //Clear LCD
	//ext_lcd_dataport = 0b00000001; //Clear LCD
	send_4094_stream_lcd(ext_lcd_dataport);
	wrcomm_ext_lcd(); //Right the command byte to command register

	//ext_lcd_dataport = 0x0E; //Display on Cursor Blinking
	ext_lcd_dataport = 0x0E; //Display on Cursor Blinking
	send_4094_stream_lcd(ext_lcd_dataport);
	wrcomm_ext_lcd(); //Right the command byte to command register

	ext_lcd_dataport = 0x80; //Cursor at line 1, position 1
	send_4094_stream_lcd(ext_lcd_dataport);
	wrcomm_ext_lcd(); //Right the command byte to command register

	//ext_lcd_dataport = 0x1C; //Shift Entire Display To Right
	//send_4094_stream_lcd(ext_lcd_dataport);
	//wrcomm_ext_lcd(); //Right the command byte to command register
	//_delay_ms(16);
	return 1;
	//asm volatile("sei"::);//Enable interrupts
}

int wrcomm_ext_lcd(void) {
	//asm volatile("cli"::); //Disable all interrupts during setup
	ext_lcd_dataport &= ~0b0010000000000000; //Setting RS = 0, selecting command register
	send_4094_stream_lcd(ext_lcd_dataport);
	ext_lcd_dataport &= ~0b0100000000000000; //Setting RW = 0
	send_4094_stream_lcd(ext_lcd_dataport);
	ext_lcd_dataport |= 0b1000000000000000; //EN = 1
	send_4094_stream_lcd(ext_lcd_dataport);
	ext_lcd_dataport &= 0b1000000000000000; //EN = 0, thus giving high to low pulse on Enable pin
	send_4094_stream_lcd(ext_lcd_dataport);
	_delay_ms(10); //10ms delay

	return 1;
	//asm volatile("sei"::);//Enable interrupts
}

/********** <<Righting the Data byte to Data register>> **********/
int wrdata_ext_lcd(void) {
	//asm volatile("cli"::); //Disable all interrupts during setup				//00000000
	ext_lcd_dataport |= 0b0010000000000000; //Setting RS = 1, selecting data register
	send_4094_stream_lcd(ext_lcd_dataport);
	//00000000
	ext_lcd_dataport &= ~0b0100000000000000; //Setting RW = 0
	send_4094_stream_lcd(ext_lcd_dataport);
	//00000000
	ext_lcd_dataport |= 0b1000000000000000; //EN = 1
	send_4094_stream_lcd(ext_lcd_dataport);
	//00000000
	ext_lcd_dataport &= 0b1000000000000000; //EN = 0, thus giving high to low pulse on Enable pin
	send_4094_stream_lcd(ext_lcd_dataport);

	_delay_ms(10); //10ms delay


	return 1;
	//asm volatile("sei"::);//Enable interrupts
}

int LCD_screen_boot(void) {
	LCD_ext_lcd_init();
	//lcd_buf[20]="Booting FotoBoX 1.0";
	sprintf(lcd_buf, "Booting FotoBox 1.0 ");

	int ii;
	for (ii = 0; ii < 20; ii++) {
		ext_lcd_dataport = lcd_buf[ii];
		wrdata_ext_lcd();
		_delay_ms(10);
	}
	//_delay_ms(1000);

	return 1;
}

int LCD_reprint(void) {
	LCD_ext_lcd_init();
	int ii;
	init();
	//sprintf(lcd_buf,"%uD%u:%u:%u :%u",time_days, time_hours, time_min, time_sec, inter0_count);
	//asm volatile("cli"::); //Disable all interrupts during setup
	//sekundy = RTC_read_sec();
	CLOCK();
	adc_start_conversion(0);

	_delay_ms(30);
	adc_start_conversion(1);

	_delay_ms(30);
	adc_start_conversion(2);

	_delay_ms(30);

	// ADMUX &= 0xe0;
	// ADMUX |= 1;
	//minus_hodiny=(set_hodiny-ttmp_hodiny);
	//minus_minuty=(set_minuty-ttmp_minuty);
	//minus_sekundy=(set_sekundy-ttmp_sekundy);
	//_delay_ms(60);
	//sprintf(lcd_buf,"T:%d:%u:%u N:%u:%u:%u", adc_value, minuty, sekundy, ttmp_hodiny, ttmp_minuty, ttmp_sekundy);
	sprintf(lcd_buf, "%d:%u:%u N:%u:%u:%u", hodiny, minuty, sekundy,
			ttmp_hodiny, ttmp_minuty, ttmp_sekundy);

	//ext_lcd_dataport = 50;
	//wrdata_ext_lcd();
	//_delay_ms(400);

	for (ii = 0; ii < 20; ii++) {
		ext_lcd_dataport = lcd_buf[ii];
		wrdata_ext_lcd();
		// _delay_ms(1);
	}

	sprintf(lcd_buf, "                    ");
	//////////// hlucha mista
	for (ii = 0; ii < 20; ii++) {
		ext_lcd_dataport = 0;
		wrdata_ext_lcd();
		//_delay_ms(1);
	}
	/////////////////

	sprintf(lcd_buf, "F:%u L:%u M:%u V:%u", foto_numero, adc_value0,
			adc_value1, adc_value2);

	for (ii = 0; ii < 20; ii++) {
		ext_lcd_dataport = lcd_buf[ii];
		wrdata_ext_lcd();
		//_delay_ms(1);
	}

	//funguje
	// adc_init();
	//adc_start_conversion(0);


	//_delay_ms(1800);
	//asm volatile("sei"::);//Enable interrupts
	return 1;
}

///////////////////////////////////////////////////////////////////
int LCD_action(void) {
	LCD_ext_lcd_init();
	int ii;
	init();

	//sprintf(lcd_buf,"%uD%u:%u:%u :%u",time_days, time_hours, time_min, time_sec, inter0_count);

	//asm volatile("cli"::); //Disable all interrupts during setup
	sekundy = RTC_read_sec();
	CLOCK();

	// ADMUX &= 0xe0;
	// ADMUX |= 1;
	//minus_hodiny=(set_hodiny-ttmp_hodiny);
	//minus_minuty=(set_minuty-ttmp_minuty);
	//minus_sekundy=(set_sekundy-ttmp_sekundy);
	//_delay_ms(60);
	sprintf(lcd_buf, "R:%dH:%d I%u:%u:%u", adc_value, adc_max, inter0_count,
			ttmp_minuty, ttmp_sekundy);
	//ext_lcd_dataport = 50;
	//wrdata_ext_lcd();
	//_delay_ms(400);

	for (ii = 0; ii < 20; ii++) {
		ext_lcd_dataport = lcd_buf[ii];
		wrdata_ext_lcd();
		// _delay_ms(1);
	}
	adc_init();
	adc_start_conversion(0);

	adc_min_max();
	//_delay_ms(1800);
	//asm volatile("sei"::);//Enable interrupts
	return 1;
}

// Life for Bellards javascript PC emulator v1.0.0 (29.05.2011)
// by Bystroushaak (bystrousak@kitakitsune.org)

#include <tcclib.h>
#include "../libs/cui.h"

#define WIDTH	80
#define HEIGHT	30

char screen0[HEIGHT][WIDTH];
char screen1[HEIGHT][WIDTH];

int vline_n(char s[HEIGHT][WIDTH], int x, int y){
	int n = 0;
	if (x >= 0 && x <= WIDTH - 1){
		if (s[y][x] == 1)
			n++;
			
		if (y > 0 && s[y-1][x] == 1)
			n++;
			
		if (y < HEIGHT - 1 && s[y+1][x] == 1)
			n++;
	}
	
	return n;
}

int neighbors(char s[HEIGHT][WIDTH], int x, int y){
	return vline_n(s, x - 1, y) + vline_n(s, x + 1, y) + vline_n(s, x, y) - s[y][x];
}

// Compute one step
void step(char old[HEIGHT][WIDTH], char new[HEIGHT][WIDTH]){
	int x, y;
	
	for(x = 0; x < WIDTH - 1; x++)
		for(y = 0; y < HEIGHT - 1; y++){
			switch(neighbors(old, x, y)){
				case 0:
					new[y][x] = 0;
					break;
				case 1:
					new[y][x] = 0;
					break;
				case 2:
					new[y][x] = old[y][x]; // replace with = 1; and you will see something really interesting :)
					break;
				case 3:
					new[y][x] = 1;
					break;
				default:
					new[y][x] = 0;
					break;
			}
		}
}

// erase gamedesk
void erase(char s[HEIGHT][WIDTH]){
	int x, y;
	
	for (y = 0; y < HEIGHT - 1; y++)
		for (x = 0; x < WIDTH - 1; x++)
			s[y][x] = 0;
}

// print gamedesk
void show(char s[HEIGHT][WIDTH]){
	int x, y;
	
	goto_xy(0, 0);
	
	for (y = 0; y < HEIGHT - 1; y++){
		for (x = 0; x < WIDTH - 1; x++)
			if (s[y][x] == 1)
				putchar('#');
			else
				putchar(' ');
		
		putchar('\n');
	}
}

void main(){
	erase(screen0);
	erase(screen1);

	clear_scr();
	
	// after unpacked, add one dot into same corner of each stable cell and you will see nice efect (only for bigger screens)
	screen0[15][40] = 1;
	screen0[16][39] = 1;
	screen0[16][41] = 1;
	screen0[17][39] = 1;
	screen0[17][41] = 1;
	screen0[18][40] = 1;
	screen0[15][39] = 1;

	show(screen0);
	
	while (1){
		step(screen0, screen1);
		show(screen1);
		
		erase(screen0);
		
//		getchar();
		
		step(screen1, screen0);
		show(screen0);
		
		erase(screen1);
		
//		getchar();
	}
}
/* Name: main.c
 * Project: Testing driver features
 * Author: Christian Starkjohann
 * Creation Date: 2008-04-29
 * Tabsize: 4
 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
 * This Revision: $Id: main.c 692 2008-11-07 15:07:40Z cs $
 */

/*
This module is a do-nothing test code linking against (or including) the USB
driver. It is used to determine the code size for various options and to
check whether the code compiles with all options.
*/
#include <avr/io.h>
#include <avr/interrupt.h>  /* for sei() */
#include <avr/pgmspace.h>   /* required by usbdrv.h */
#include <util/delay.h>     /* for _delay_ms() */
#include "usbdrv.h"
#if USE_INCLUDE
#include "usbdrv.c"
#endif

/* ------------------------------------------------------------------------- */
/* ----------------------------- USB interface ----------------------------- */
/* ------------------------------------------------------------------------- */

#if USB_CFG_IMPLEMENT_FN_WRITE
uchar usbFunctionWrite(uchar *data, uchar len)
{
    return 1;
}
#endif

#if USB_CFG_IMPLEMENT_FN_READ
uchar usbFunctionRead(uchar *data, uchar len)
{
    return len;
}
#endif

#if USB_CFG_IMPLEMENT_FN_WRITEOUT
void usbFunctionWriteOut(uchar *data, uchar len)
{
}
#endif

#if USE_DYNAMIC_DESCRIPTOR

static PROGMEM char myDescriptorDevice[] = {    /* USB device descriptor */
    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
    USBDESCR_DEVICE,        /* descriptor type */
    0x10, 0x01,             /* USB version supported */
    USB_CFG_DEVICE_CLASS,
    USB_CFG_DEVICE_SUBCLASS,
    0,                      /* protocol */
    8,                      /* max packet size */
    /* the following two casts affect the first byte of the constant only, but
     * that's sufficient to avoid a warning with the default values.
     */
    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
    USB_CFG_DEVICE_VERSION, /* 2 bytes */
    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
    1,          /* number of configurations */
};

static PROGMEM char myDescriptorConfiguration[] = { /* USB configuration descriptor */
    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
    USBDESCR_CONFIG,    /* descriptor type */
    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
                /* total length of data returned (including inlined descriptors) */
    1,          /* number of interfaces in this configuration */
    1,          /* index of this configuration */
    0,          /* configuration name string index */
#if USB_CFG_IS_SELF_POWERED
    USBATTR_SELFPOWER,      /* attributes */
#else
    (char)USBATTR_BUSPOWER, /* attributes */
#endif
    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
/* interface descriptor follows inline: */
    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
    USBDESCR_INTERFACE, /* descriptor type */
    0,          /* index of this interface */
    0,          /* alternate setting for this interface */
    USB_CFG_HAVE_INTRIN_ENDPOINT,   /* endpoints excl 0: number of endpoint descriptors to follow */
    USB_CFG_INTERFACE_CLASS,
    USB_CFG_INTERFACE_SUBCLASS,
    USB_CFG_INTERFACE_PROTOCOL,
    0,          /* string index for interface */
#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
    USBDESCR_HID,   /* descriptor type: HID */
    0x01, 0x01, /* BCD representation of HID version */
    0x00,       /* target country code */
    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
    0x22,       /* descriptor type: report */
    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
#endif
#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
    7,          /* sizeof(usbDescrEndpoint) */
    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
    (char)0x81, /* IN endpoint number 1 */
    0x03,       /* attrib: Interrupt endpoint */
    8, 0,       /* maximum packet size */
    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
#endif
};

USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(usbRequest_t *rq)
{
uchar *p = 0, len = 0;

    if(rq->wValue.bytes[1] == USBDESCR_DEVICE){
        p = (uchar *)myDescriptorDevice;
        len = sizeof(myDescriptorDevice);
    }else{  /* must be configuration descriptor */
        p = (uchar *)(myDescriptorConfiguration);
        len = sizeof(myDescriptorConfiguration);
    }
    usbMsgPtr = p;
    return len;
}
#endif

USB_PUBLIC usbMsgLen_t  usbFunctionSetup(uchar data[8])
{
usbRequest_t    *rq = (void *)data;

    if(rq->bRequest == 0)   /* request using usbFunctionRead()/usbFunctionWrite() */
        return 0xff;
	return 0;   /* default for not implemented requests: return no data back to host */
}

/* ------------------------------------------------------------------------- */

int	main(void)
{
uchar   i;

	usbInit();
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
        _delay_ms(1);
    }
    usbDeviceConnect();
	sei();
	for(;;){                /* main event loop */
		usbPoll();
	}
	return 0;
}

/* ------------------------------------------------------------------------- */
/*
 * $Id$
 * patest_sine.c
 * Play a sine wave using the Portable Audio api for several seconds.
 *
 * Authors:
 *    Ross Bencina <rossb@audiomulch.com>
 *    Phil Burk <philburk@softsynth.com>
 *
 * This program uses the PortAudio Portable Audio Library.
 * For more information see: http://www.audiomulch.com/portaudio/
 * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */
#include <stdio.h>
#include <math.h>
#include "portaudio.h"

#define NUM_SECONDS   (5)
#define SAMPLE_RATE   (44100)
#define FRAMES_PER_BUFFER  (64)

#ifndef M_PI
#define M_PI  (3.14159265)
#endif

#define TABLE_SIZE   (200)
typedef struct
{
    float sine[TABLE_SIZE];
    int left_phase;
    int right_phase;
}
paTestData;

/* This routine will be called by the PortAudio engine when audio is needed.
** It may called at interrupt level on some machines so don't do anything
** that could mess up the system like calling malloc() or free().
*/
static int patestCallback(   void *inputBuffer, void *outputBuffer,
                             unsigned long framesPerBuffer,
                             PaTimestamp outTime, void *userData )
{
    paTestData *data = (paTestData*)userData;
    float *out = (float*)outputBuffer;
    unsigned long i;
    int finished = 0;
    (void) outTime; /* Prevent unused variable warnings. */
    (void) inputBuffer;
    for( i=0; i<framesPerBuffer; i++ )
    {
        *out++ = data->sine[data->left_phase];  /* left */
        *out++ = data->sine[data->right_phase];  /* right */
        data->left_phase += 1;
        if( data->left_phase >= TABLE_SIZE ) data->left_phase -= TABLE_SIZE;
        data->right_phase += 3; /* higher pitch so we can distinguish left and right. */
        if( data->right_phase >= TABLE_SIZE ) data->right_phase -= TABLE_SIZE;
    }
    return finished;
}

/*******************************************************************/
int main(void);
int main(void)
{
    PortAudioStream *stream;
    PaError err;
    paTestData data;
    int i;
    printf("PortAudio Test: output sine wave. SR = %d, BufSize = %d\n", SAMPLE_RATE, FRAMES_PER_BUFFER);
    /* initialise sinusoidal wavetable */
    for( i=0; i<TABLE_SIZE; i++ )
    {
        data.sine[i] = (float) sin( ((double)i/(double)TABLE_SIZE) * M_PI * 2. );
    }
    data.left_phase = data.right_phase = 0;
    err = Pa_Initialize();
    if( err != paNoError ) goto error;
    err = Pa_OpenStream(
              &stream,
              paNoDevice,/* default input device */
              0,              /* no input */
              paFloat32,  /* 32 bit floating point input */
              NULL,
              Pa_GetDefaultOutputDeviceID(), /* default output device */
              2,          /* stereo output */
              paFloat32,      /* 32 bit floating point output */
              NULL,
              SAMPLE_RATE,
              FRAMES_PER_BUFFER,
              0,              /* number of buffers, if zero then use default minimum */
              paClipOff,      /* we won't output out of range samples so don't bother clipping them */
              patestCallback,
              &data );
    if( err != paNoError ) goto error;
    err = Pa_StartStream( stream );
    if( err != paNoError ) goto error;
    printf("Play for %d seconds.\n", NUM_SECONDS );
    Pa_Sleep( NUM_SECONDS * 1000 );

    err = Pa_StopStream( stream );
    if( err != paNoError ) goto error;
    err = Pa_CloseStream( stream );
    if( err != paNoError ) goto error;
    Pa_Terminate();
    printf("Test finished.\n");
    return err;
error:
    Pa_Terminate();
    fprintf( stderr, "An error occured while using the portaudio stream\n" );
    fprintf( stderr, "Error number: %d\n", err );
    fprintf( stderr, "Error message: %s\n", Pa_GetErrorText( err ) );
    return err;
}
/*--------------------------------------------------------------------------------------------------

  Name         :  NokiaLCD.c

  Description  :  This is a driver for the Nokia 84x48 graphic LCD.

  Author       :  2003-03-08 - Sylvain Bissonnette

  History      :  2003-02-08 - First release (v0.1) derived from Sylvain Bissonnette code base.
                  2003-03-09 - v0.2, Louis Frigon: 2x fonts support.
                  2003-03-20 - v0.3: Serialization optimized,

--------------------------------------------------------------------------------------------------*/
#include <macros.h>
#include <iom8v.h>
//#include <stdio.h>

#include "NokiaLCD.h"

#define LCD_FIRMWARE_VERSION       0.3

/*--------------------------------------------------------------------------------------------------
                                Private function prototypes
--------------------------------------------------------------------------------------------------*/
//  Function prototypes are mandatory otherwise the compiler generates unreliable code.

static void LcdSend    ( byte data, LcdCmdData cd );
static void Delay      ( void );

/*--------------------------------------------------------------------------------------------------
                                     Character generator

             This table defines the standard ASCII characters in a 5x7 dot format.
--------------------------------------------------------------------------------------------------*/
static const byte FontLookup [][5] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00 },  // sp
    { 0x00, 0x00, 0x2f, 0x00, 0x00 },   // !
    { 0x00, 0x07, 0x00, 0x07, 0x00 },   // "
    { 0x14, 0x7f, 0x14, 0x7f, 0x14 },   // #
    { 0x24, 0x2a, 0x7f, 0x2a, 0x12 },   // $
    { 0xc4, 0xc8, 0x10, 0x26, 0x46 },   // %
    { 0x36, 0x49, 0x55, 0x22, 0x50 },   // &
    { 0x00, 0x05, 0x03, 0x00, 0x00 },   // '
    { 0x00, 0x1c, 0x22, 0x41, 0x00 },   // (
    { 0x00, 0x41, 0x22, 0x1c, 0x00 },   // )
    { 0x14, 0x08, 0x3E, 0x08, 0x14 },   // *
    { 0x08, 0x08, 0x3E, 0x08, 0x08 },   // +
    { 0x00, 0x00, 0x50, 0x30, 0x00 },   // ,
    { 0x10, 0x10, 0x10, 0x10, 0x10 },   // -
    { 0x00, 0x60, 0x60, 0x00, 0x00 },   // .
    { 0x20, 0x10, 0x08, 0x04, 0x02 },   // /
    { 0x3E, 0x51, 0x49, 0x45, 0x3E },   // 0
    { 0x00, 0x42, 0x7F, 0x40, 0x00 },   // 1
    { 0x42, 0x61, 0x51, 0x49, 0x46 },   // 2
    { 0x21, 0x41, 0x45, 0x4B, 0x31 },   // 3
    { 0x18, 0x14, 0x12, 0x7F, 0x10 },   // 4
    { 0x27, 0x45, 0x45, 0x45, 0x39 },   // 5
    { 0x3C, 0x4A, 0x49, 0x49, 0x30 },   // 6
    { 0x01, 0x71, 0x09, 0x05, 0x03 },   // 7
    { 0x36, 0x49, 0x49, 0x49, 0x36 },   // 8
    { 0x06, 0x49, 0x49, 0x29, 0x1E },   // 9
    { 0x00, 0x36, 0x36, 0x00, 0x00 },   // :
    { 0x00, 0x56, 0x36, 0x00, 0x00 },   // ;
    { 0x08, 0x14, 0x22, 0x41, 0x00 },   // <
    { 0x14, 0x14, 0x14, 0x14, 0x14 },   // =
    { 0x00, 0x41, 0x22, 0x14, 0x08 },   // >
    { 0x02, 0x01, 0x51, 0x09, 0x06 },   // ?
    { 0x32, 0x49, 0x59, 0x51, 0x3E },   // @
    { 0x7E, 0x11, 0x11, 0x11, 0x7E },   // A
    { 0x7F, 0x49, 0x49, 0x49, 0x36 },   // B
    { 0x3E, 0x41, 0x41, 0x41, 0x22 },   // C
    { 0x7F, 0x41, 0x41, 0x22, 0x1C },   // D
    { 0x7F, 0x49, 0x49, 0x49, 0x41 },   // E
    { 0x7F, 0x09, 0x09, 0x09, 0x01 },   // F
    { 0x3E, 0x41, 0x49, 0x49, 0x7A },   // G
    { 0x7F, 0x08, 0x08, 0x08, 0x7F },   // H
    { 0x00, 0x41, 0x7F, 0x41, 0x00 },   // I
    { 0x20, 0x40, 0x41, 0x3F, 0x01 },   // J
    { 0x7F, 0x08, 0x14, 0x22, 0x41 },   // K
    { 0x7F, 0x40, 0x40, 0x40, 0x40 },   // L
    { 0x7F, 0x02, 0x0C, 0x02, 0x7F },   // M
    { 0x7F, 0x04, 0x08, 0x10, 0x7F },   // N
    { 0x3E, 0x41, 0x41, 0x41, 0x3E },   // O
    { 0x7F, 0x09, 0x09, 0x09, 0x06 },   // P
    { 0x3E, 0x41, 0x51, 0x21, 0x5E },   // Q
    { 0x7F, 0x09, 0x19, 0x29, 0x46 },   // R
    { 0x46, 0x49, 0x49, 0x49, 0x31 },   // S
    { 0x01, 0x01, 0x7F, 0x01, 0x01 },   // T
    { 0x3F, 0x40, 0x40, 0x40, 0x3F },   // U
    { 0x1F, 0x20, 0x40, 0x20, 0x1F },   // V
    { 0x3F, 0x40, 0x38, 0x40, 0x3F },   // W
    { 0x63, 0x14, 0x08, 0x14, 0x63 },   // X
    { 0x07, 0x08, 0x70, 0x08, 0x07 },   // Y
    { 0x61, 0x51, 0x49, 0x45, 0x43 },   // Z
    { 0x00, 0x7F, 0x41, 0x41, 0x00 },   // [
    { 0x55, 0x2A, 0x55, 0x2A, 0x55 },   // 55
    { 0x00, 0x41, 0x41, 0x7F, 0x00 },   // ]
    { 0x04, 0x02, 0x01, 0x02, 0x04 },   // ^
    { 0x40, 0x40, 0x40, 0x40, 0x40 },   // _
    { 0x00, 0x01, 0x02, 0x04, 0x00 },   // '
    { 0x20, 0x54, 0x54, 0x54, 0x78 },   // a
    { 0x7F, 0x48, 0x44, 0x44, 0x38 },   // b
    { 0x38, 0x44, 0x44, 0x44, 0x20 },   // c
    { 0x38, 0x44, 0x44, 0x48, 0x7F },   // d
    { 0x38, 0x54, 0x54, 0x54, 0x18 },   // e
    { 0x08, 0x7E, 0x09, 0x01, 0x02 },   // f
    { 0x0C, 0x52, 0x52, 0x52, 0x3E },   // g
    { 0x7F, 0x08, 0x04, 0x04, 0x78 },   // h
    { 0x00, 0x44, 0x7D, 0x40, 0x00 },   // i
    { 0x20, 0x40, 0x44, 0x3D, 0x00 },   // j
    { 0x7F, 0x10, 0x28, 0x44, 0x00 },   // k
    { 0x00, 0x41, 0x7F, 0x40, 0x00 },   // l
    { 0x7C, 0x04, 0x18, 0x04, 0x78 },   // m
    { 0x7C, 0x08, 0x04, 0x04, 0x78 },   // n
    { 0x38, 0x44, 0x44, 0x44, 0x38 },   // o
    { 0x7C, 0x14, 0x14, 0x14, 0x08 },   // p
    { 0x08, 0x14, 0x14, 0x18, 0x7C },   // q
    { 0x7C, 0x08, 0x04, 0x04, 0x08 },   // r
    { 0x48, 0x54, 0x54, 0x54, 0x20 },   // s
    { 0x04, 0x3F, 0x44, 0x40, 0x20 },   // t
    { 0x3C, 0x40, 0x40, 0x20, 0x7C },   // u
    { 0x1C, 0x20, 0x40, 0x20, 0x1C },   // v
    { 0x3C, 0x40, 0x30, 0x40, 0x3C },   // w
    { 0x44, 0x28, 0x10, 0x28, 0x44 },   // x
    { 0x0C, 0x50, 0x50, 0x50, 0x3C },   // y
    { 0x44, 0x64, 0x54, 0x4C, 0x44 }    // z
};

/*--------------------------------------------------------------------------------------------------
                                      Global Variables
--------------------------------------------------------------------------------------------------*/
static byte  LcdCache [ LCD_CACHE_SIZE ];

static int   LcdCacheIdx;
static int   LoWaterMark;
static int   HiWaterMark;
static bool  UpdateLcd;


/*--------------------------------------------------------------------------------------------------

  Name         :  LcdInit

  Description  :  Performs MCU SPI & LCD controller initialization.

  Argument(s)  :  None.

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
void LcdInit ( void )
{
    //  Pull-up on reset pin.
    PORTB |= LCD_RST_PIN;

    //  Set output bits on port B.
    DDRB |= LCD_RST_PIN | LCD_DC_PIN | LCD_CE_PIN | SPI_MOSI_PIN | SPI_CLK_PIN;

    Delay();

    //  Toggle display reset pin.
    PORTB &= ~LCD_RST_PIN;
    Delay();
    PORTB |= LCD_RST_PIN;

    //  Enable SPI port: No interrupt, MSBit first, Master mode, CPOL->0, CPHA->0, Clk/4
    SPCR = 0x50;

    //  Disable LCD controller
    PORTB |= LCD_CE_PIN;

    LcdSend( 0x21, LCD_CMD );  // LCD Extended Commands.
    LcdSend( 0xC8, LCD_CMD );  // Set LCD Vop (Contrast).
    LcdSend( 0x06, LCD_CMD );  // Set Temp coefficent.
    LcdSend( 0x13, LCD_CMD );  // LCD bias mode 1:48.
    LcdSend( 0x20, LCD_CMD );  // LCD Standard Commands, Horizontal addressing mode.
    LcdSend( 0x0C, LCD_CMD );  // LCD in normal mode.

    //  Reset watermark pointers.
    LoWaterMark = LCD_CACHE_SIZE;
    HiWaterMark = 0;

    LcdClear();
    LcdUpdate();
}

/*--------------------------------------------------------------------------------------------------

  Name         :  LcdContrast

  Description  :  Set display contrast.

  Argument(s)  :  contrast -> Contrast value from 0x00 to 0x7F.

  Return value :  None.

  Notes        :  No change visible at ambient temperature.

--------------------------------------------------------------------------------------------------*/
void LcdContrast ( byte contrast )
{
    //  LCD Extended Commands.
    LcdSend( 0x21, LCD_CMD );

    // Set LCD Vop (Contrast).
    LcdSend( 0x80 | contrast, LCD_CMD );

    //  LCD Standard Commands, horizontal addressing mode.
    LcdSend( 0x20, LCD_CMD );
}

/*--------------------------------------------------------------------------------------------------

  Name         :  LcdClear

  Description  :  Clears the display. LcdUpdate must be called next.

  Argument(s)  :  None.

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
void LcdClear ( void )
{
    int i;

    for ( i = 0; i < LCD_CACHE_SIZE; i++ )
    {
        LcdCache[i] = 0x00;
    }

    //  Reset watermark pointers.
    LoWaterMark = 0;
    HiWaterMark = LCD_CACHE_SIZE - 1;

    UpdateLcd = TRUE;
}

/*--------------------------------------------------------------------------------------------------

  Name         :  LcdGotoXY

  Description  :  Sets cursor location to xy location corresponding to basic font size.

  Argument(s)  :  x, y -> Coordinate for new cursor position. Range: 1,1 .. 14,6

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
void LcdGotoXY ( byte x, byte y )
{
    LcdCacheIdx = (x - 1) * 6 + (y - 1) * 84;
}

/*--------------------------------------------------------------------------------------------------

  Name         :  LcdChr

  Description  :  Displays a character at current cursor location and increment cursor location.

  Argument(s)  :  size -> Font size. See enum.
                  ch   -> Character to write.

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
void LcdChr ( LcdFontSize size, byte ch )
{
    byte i, c;
    byte b1, b2;
    int  tmpIdx;

    if ( LcdCacheIdx < LoWaterMark )
    {
        //  Update low marker.
        LoWaterMark = LcdCacheIdx;
    }

    if ( (ch < 0x20) || (ch > 0x7b) )
    {
        //  Convert to a printable character.
        ch = 92;
    }

    if ( size == FONT_1X )
    {
        for ( i = 0; i < 5; i++ )
        {
            LcdCache[LcdCacheIdx++] = FontLookup[ch - 32][i] << 1;
        }
    }
    else if ( size == FONT_2X )
    {
        tmpIdx = LcdCacheIdx - 84;

        if ( tmpIdx < LoWaterMark )
        {
            LoWaterMark = tmpIdx;
        }

        if ( tmpIdx < 0 ) return;

        for ( i = 0; i < 5; i++ )
        {
            c = FontLookup[ch - 32][i] << 1;
            b1 =  (c & 0x01) * 3;
            b1 |= (c & 0x02) * 6;
            b1 |= (c & 0x04) * 12;
            b1 |= (c & 0x08) * 24;

            c >>= 4;
            b2 =  (c & 0x01) * 3;
            b2 |= (c & 0x02) * 6;
            b2 |= (c & 0x04) * 12;
            b2 |= (c & 0x08) * 24;

            LcdCache[tmpIdx++] = b1;
            LcdCache[tmpIdx++] = b1;
            LcdCache[tmpIdx + 82] = b2;
            LcdCache[tmpIdx + 83] = b2;
        }

        //  Update x cursor position.
        LcdCacheIdx += 11;
    }

    if ( LcdCacheIdx > HiWaterMark )
    {
        //  Update high marker.
        HiWaterMark = LcdCacheIdx;
    }

    //  Horizontal gap between characters.
    LcdCache[LcdCacheIdx++] = 0x00;
}

/*--------------------------------------------------------------------------------------------------

  Name         :  LcdStr

  Description  :  Displays a character at current cursor location and increment cursor location
                  according to font size.

  Argument(s)  :  size    -> Font size. See enum.
                  dataPtr -> Pointer to null terminated ASCII string to display.

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
void LcdStr ( LcdFontSize size, byte *dataPtr )
{
    while ( *dataPtr )
    {
        LcdChr( size, *dataPtr++ );
    }
}

/*--------------------------------------------------------------------------------------------------

  Name         :  LcdPixel

  Description  :  Displays a pixel at given absolute (x, y) location.

  Argument(s)  :  x, y -> Absolute pixel coordinates
                  mode -> Off, On or Xor. See enum.

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
void LcdPixel ( byte x, byte y, LcdPixelMode mode )
{
    word  index;
    byte  offset;
    byte  data;

    if ( x > LCD_X_RES ) return;
    if ( y > LCD_Y_RES ) return;

    index = ((y / 8) * 84) + x;
    offset  = y - ((y / 8) * 8);

    data = LcdCache[index];

    if ( mode == PIXEL_OFF )
    {
        data &= (~(0x01 << offset));
    }
    else if ( mode == PIXEL_ON )
    {
        data |= (0x01 << offset);
    }
    else if ( mode  == PIXEL_XOR )
    {
        data ^= (0x01 << offset);
    }

    LcdCache[index] = data;

    if ( index < LoWaterMark )
    {
        //  Update low marker.
        LoWaterMark = index;
    }

    if ( index > HiWaterMark )
    {
        //  Update high marker.
        HiWaterMark = index;
    }
}

/*--------------------------------------------------------------------------------------------------

  Name         :  LcdLine

  Description  :  Draws a line between two points on the display.

  Argument(s)  :  x1, y1 -> Absolute pixel coordinates for line origin.
                  x2, y2 -> Absolute pixel coordinates for line end.
                  mode   -> Off, On or Xor. See enum.

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
void LcdLine ( byte x1, byte y1, byte x2, byte y2, LcdPixelMode mode )
{
    int dx, dy, stepx, stepy, fraction;

    dy = y2 - y1;
    dx = x2 - x1;

    if ( dy < 0 )
    {
        dy    = -dy;
        stepy = -1;
    }
    else
    {
        stepy = 1;
    }

    if ( dx < 0 )
    {
        dx    = -dx;
        stepx = -1;
    }
    else
    {
        stepx = 1;
    }

    dx <<= 1;
    dy <<= 1;

    LcdPixel( x1, y1, mode );

    if ( dx > dy )
    {
        fraction = dy - (dx >> 1);
        while ( x1 != x2 )
        {
            if ( fraction >= 0 )
            {
                y1 += stepy;
                fraction -= dx;
            }
            x1 += stepx;
            fraction += dy;
            LcdPixel( x1, y1, mode );
        }
    }
    else
    {
        fraction = dx - (dy >> 1);
        while ( y1 != y2 )
        {
            if ( fraction >= 0 )
            {
                x1 += stepx;
                fraction -= dy;
            }
            y1 += stepy;
            fraction += dx;
            LcdPixel( x1, y1, mode );
        }
    }

    UpdateLcd = TRUE;
}

/*--------------------------------------------------------------------------------------------------

  Name         :  LcdUpdate

  Description  :  Copies the LCD cache into the device RAM.

  Argument(s)  :  None.

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
void LcdUpdate ( void )
{
    int i;

    if ( LoWaterMark < 0 )
        LoWaterMark = 0;
    else if ( LoWaterMark >= LCD_CACHE_SIZE )
        LoWaterMark = LCD_CACHE_SIZE - 1;

    if ( HiWaterMark < 0 )
        HiWaterMark = 0;
    else if ( HiWaterMark >= LCD_CACHE_SIZE )
        HiWaterMark = LCD_CACHE_SIZE - 1;

    //  Set base address according to LoWaterMark.
    LcdSend( 0x80 | (LoWaterMark % LCD_X_RES), LCD_CMD );
    LcdSend( 0x40 | (LoWaterMark / LCD_X_RES), LCD_CMD );

    //  Serialize the video buffer.
    for ( i = LoWaterMark; i <= HiWaterMark; i++ )
    {
        LcdSend( LcdCache[i], LCD_DATA );
    }

    //  Reset watermark pointers.
    LoWaterMark = LCD_CACHE_SIZE - 1;
    HiWaterMark = 0;

    UpdateLcd = FALSE;
}

/*--------------------------------------------------------------------------------------------------

  Name         :  LcdSend

  Description  :  Sends data to display controller.

  Argument(s)  :  data -> Data to be sent
                  cd   -> Command or data (see/use enum)

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
static void LcdSend ( byte data, LcdCmdData cd )
{
    //  Enable display controller (active low).
    PORTB &= ~LCD_CE_PIN;

    if ( cd == LCD_DATA )
    {
        PORTB |= LCD_DC_PIN;
    }
    else
    {
        PORTB &= ~LCD_DC_PIN;
    }

    //  Send data to display controller.
    SPDR = data;

    //  Wait until Tx register empty.
    while ( (SPSR & 0x80) != 0x80 );

    //  Disable display controller.
    PORTB |= LCD_CE_PIN;
}

/*--------------------------------------------------------------------------------------------------

  Name         :  Delay

  Description  :  Uncalibrated delay for LCD init routine.

  Argument(s)  :  None.

  Return value :  None.

--------------------------------------------------------------------------------------------------*/
static void Delay ( void )
{
    int i;

    for ( i = -32000; i < 32000; i++ );
}

/*--------------------------------------------------------------------------------------------------
                                         End of file.
--------------------------------------------------------------------------------------------------*/
/* Name: oddebug.c
 * Project: AVR library
 * Author: Christian Starkjohann
 * Creation Date: 2005-01-16
 * Tabsize: 4
 * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
 * This Revision: $Id: oddebug.c 692 2008-11-07 15:07:40Z cs $
 */

#include "oddebug.h"

#if DEBUG_LEVEL > 0

#warning "Never compile production devices with debugging enabled"

static void uartPutc(char c)
{
    while(!(ODDBG_USR & (1 << ODDBG_UDRE)));    /* wait for data register empty */
    ODDBG_UDR = c;
}

static uchar    hexAscii(uchar h)
{
    h &= 0xf;
    if(h >= 10)
        h += 'a' - (uchar)10 - '0';
    h += '0';
    return h;
}

static void printHex(uchar c)
{
    uartPutc(hexAscii(c >> 4));
    uartPutc(hexAscii(c));
}

void    odDebug(uchar prefix, uchar *data, uchar len)
{
    printHex(prefix);
    uartPutc(':');
    while(len--){
        uartPutc(' ');
        printHex(*data++);
    }
    uartPutc('\r');
    uartPutc('\n');
}

#endif
/* Name: opendevice.c
 * Project: V-USB host-side library
 * Author: Christian Starkjohann
 * Creation Date: 2008-04-10
 * Tabsize: 4
 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
 * This Revision: $Id: opendevice.c 740 2009-04-13 18:23:31Z cs $
 */

/*
General Description:
The functions in this module can be used to find and open a device based on
libusb or libusb-win32.
*/

#include <stdio.h>
#include "opendevice.h"

/* ------------------------------------------------------------------------- */

#define MATCH_SUCCESS			1
#define MATCH_FAILED			0
#define MATCH_ABORT				-1

/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
static int  _shellStyleMatch(char *text, char *p)
{
int last, matched, reverse;

    for(; *p; text++, p++){
        if(*text == 0 && *p != '*')
            return MATCH_ABORT;
        switch(*p){
        case '\\':
            /* Literal match with following character. */
            p++;
            /* FALLTHROUGH */
        default:
            if(*text != *p)
                return MATCH_FAILED;
            continue;
        case '?':
            /* Match anything. */
            continue;
        case '*':
            while(*++p == '*')
                /* Consecutive stars act just like one. */
                continue;
            if(*p == 0)
                /* Trailing star matches everything. */
                return MATCH_SUCCESS;
            while(*text)
                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
                    return matched;
            return MATCH_ABORT;
        case '[':
            reverse = p[1] == '^';
            if(reverse) /* Inverted character class. */
                p++;
            matched = MATCH_FAILED;
            if(p[1] == ']' || p[1] == '-')
                if(*++p == *text)
                    matched = MATCH_SUCCESS;
            for(last = *p; *++p && *p != ']'; last = *p)
                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
                    matched = MATCH_SUCCESS;
            if(matched == reverse)
                return MATCH_FAILED;
            continue;
        }
    }
    return *text == 0;
}

/* public interface for shell style matching: returns 0 if fails, 1 if matches */
static int shellStyleMatch(char *text, char *pattern)
{
    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
        return 1;
    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
}

/* ------------------------------------------------------------------------- */

int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
{
char    buffer[256];
int     rval, i;

    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
        return rval;
    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
        return rval;
    if(buffer[1] != USB_DT_STRING){
        *buf = 0;
        return 0;
    }
    if((unsigned char)buffer[0] < rval)
        rval = (unsigned char)buffer[0];
    rval /= 2;
    /* lossy conversion to ISO Latin1: */
    for(i=1;i<rval;i++){
        if(i > buflen)              /* destination buffer overflow */
            break;
        buf[i-1] = buffer[2 * i];
        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
            buf[i-1] = '?';
    }
    buf[i-1] = 0;
    return i-1;
}

/* ------------------------------------------------------------------------- */

int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
{
struct usb_bus      *bus;
struct usb_device   *dev;
usb_dev_handle      *handle = NULL;
int                 errorCode = USBOPEN_ERR_NOTFOUND;

    usb_find_busses();
    usb_find_devices();
    for(bus = usb_get_busses(); bus; bus = bus->next){
        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
                        && (productID == 0 || dev->descriptor.idProduct == productID)){
                char    vendor[256], product[256], serial[256];
                int     len;
                handle = usb_open(dev); /* we need to open the device in order to query strings */
                if(!handle){
                    errorCode = USBOPEN_ERR_ACCESS;
                    if(warningsFp != NULL)
                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
                    continue;
                }
                /* now check whether the names match: */
                len = vendor[0] = 0;
                if(dev->descriptor.iManufacturer > 0){
                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
                }
                if(len < 0){
                    errorCode = USBOPEN_ERR_ACCESS;
                    if(warningsFp != NULL)
                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
                }else{
                    errorCode = USBOPEN_ERR_NOTFOUND;
                    /* printf("seen device from vendor ->%s<-\n", vendor); */
                    if(shellStyleMatch(vendor, vendorNamePattern)){
                        len = product[0] = 0;
                        if(dev->descriptor.iProduct > 0){
                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
                        }
                        if(len < 0){
                            errorCode = USBOPEN_ERR_ACCESS;
                            if(warningsFp != NULL)
                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
                        }else{
                            errorCode = USBOPEN_ERR_NOTFOUND;
                            /* printf("seen product ->%s<-\n", product); */
                            if(shellStyleMatch(product, productNamePattern)){
                                len = serial[0] = 0;
                                if(dev->descriptor.iSerialNumber > 0){
                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
                                }
                                if(len < 0){
                                    errorCode = USBOPEN_ERR_ACCESS;
                                    if(warningsFp != NULL)
                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
                                }
                                if(shellStyleMatch(serial, serialNamePattern)){
                                    if(printMatchingDevicesFp != NULL){
                                        if(serial[0] == 0){
                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
                                        }else{
                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
                                        }
                                    }else{
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                usb_close(handle);
                handle = NULL;
            }
        }
        if(handle)  /* we have found a deice */
            break;
    }
    if(handle != NULL){
        errorCode = 0;
        *device = handle;
    }
    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
        errorCode = 0;
    return errorCode;
}

/* ------------------------------------------------------------------------- */
/* Name: osccal.c
 * Author: Christian Starkjohann
 * Creation Date: 2008-04-10
 * Tabsize: 4
 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
 * This Revision: $Id: osccal.c 762 2009-08-12 17:10:30Z cs $
 */

#include <avr/io.h>

#ifndef uchar
#define uchar   unsigned char
#endif

/* ------------------------------------------------------------------------- */
/* ------------------------ Oscillator Calibration ------------------------- */
/* ------------------------------------------------------------------------- */

/* Calibrate the RC oscillator. Our timing reference is the Start Of Frame
 * signal (a single SE0 bit) repeating every millisecond immediately after
 * a USB RESET. We first do a binary search for the OSCCAL value and then
 * optimize this value with a neighboorhod search.
 */
void    calibrateOscillator(void)
{
uchar       step = 128;
uchar       trialValue = 0, optimumValue;
int         x, optimumDev, targetValue = (unsigned)(1499 * (double)F_CPU / 10.5e6 + 0.5);

    /* do a binary search: */
    do{
        OSCCAL = trialValue + step;
        x = usbMeasureFrameLength();    /* proportional to current real frequency */
        if(x < targetValue)             /* frequency still too low */
            trialValue += step;
        step >>= 1;
    }while(step > 0);
    /* We have a precision of +/- 1 for optimum OSCCAL here */
    /* now do a neighborhood search for optimum value */
    optimumValue = trialValue;
    optimumDev = x; /* this is certainly far away from optimum */
    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
        x = usbMeasureFrameLength() - targetValue;
        if(x < 0)
            x = -x;
        if(x < optimumDev){
            optimumDev = x;
            optimumValue = OSCCAL;
        }
    }
    OSCCAL = optimumValue;
}
/*
Note: This calibration algorithm may try OSCCAL values of up to 192 even if
the optimum value is far below 192. It may therefore exceed the allowed clock
frequency of the CPU in low voltage designs!
You may replace this search algorithm with any other algorithm you like if
you have additional constraints such as a maximum CPU clock.
For version 5.x RC oscillators (those with a split range of 2x128 steps, e.g.
ATTiny25, ATTiny45, ATTiny85), it may be useful to search for the optimum in
both regions.
*/
#include <avr/io.h>
#define F_CPU 1000000  // 1 MHz 
#include <util/delay.h>

#define sbi(port,bit) port |= (1 << (bit))
#define cbi(port,bit) port &= ~(1 << (bit))

#define WAIT1 500
#define WAIT0 200
#define LED 4

typedef unsigned char byte;

void writeByte(byte c){
	for (char i = 7; i >= 0; i--){
		if ((c >> i) & 1){
			sbi(PORTB, LED);
			_delay_ms(WAIT1);
		}
		else{
			cbi(PORTB, LED);
			_delay_ms(WAIT0);
		}
	}
}

// DATA_FROM_PYTHON

void main(void) {
    DDRB = 0xFF; // nastavit vsechny piny portu B na vystupy
    PORTB = 0; // na zacatek je nechat v 0

    for (byte i = 0; i < DATA_LEN; i++)
		writeByte(data[i]);
	PORTB = 0;
}
#include <avr/io.h>
#define F_CPU 1000000  // 1 MHz 
#include <util/delay.h>

#define OUTC  0
#define OUTI  1
#define OUTS  2
#define OUTD  3
#define SNZ   4  // senzor

#define sbi(port,bit) port |= (1 << (bit))
#define cbi(port,bit) port &= ~(1 << (bit))

// clear display
#define clr(port) port = ~ _BV(SNZ);    // display use negative logic - log. 0 make LED light

void show0(void) {
    clr(PORTB);
    cbi(PORTB, OUTC);
    cbi(PORTB, OUTI);
}

void show1(void) {
    clr(PORTB);
    cbi(PORTB, OUTI);
}

void showE(void) {
    clr(PORTB);
    cbi(PORTB, OUTC);
    cbi(PORTB, OUTS);
}

int main(void) {
    DDRB = ~_BV(SNZ);
    PORTB = ~_BV(SNZ);

    unsigned char i = 0, correct = 0, inval = 0, tmpval = 0;

    while (1) {
        for (correct = 0, i = 0; i < 50; i++) {
            inval = (PINB & _BV(SNZ));
            _delay_ms(1);
            tmpval = (PINB & _BV(SNZ));

            if (inval == tmpval)
                correct++;
        }

        if (correct != i) {
            showE();
            _delay_ms(50);
        } else {
            if (inval) {
                show1();
                _delay_ms(50);
            } else {
                show0();
                _delay_ms(50);
            }
        }
    }
    return 1;
}
/* Prace na PHS v0.1.0 (17.05.2010) by Bystroushaak (bystrousak@kitakitsune.org)
 * 
 * Poznamky;
 *  
*/

#include "displej.c"

typedef unsigned char byte;

/* Vypise binarni reprezentaci promenne var */
void printBin(byte var){
    char tmp = 0;
    int pocetbitu = sizeof(var) * 8;
    
    int i;
    for(i = 0; i < pocetbitu; i++){
        tmp = var >> (pocetbitu - i - 1) & 1;
        if (tmp){
            putchar('1');
        }else{
            putchar('0');
        }
    }
}

/* Nastavi hodnotu b u bitu na pozici n promenne var */
void setBit(byte *var, byte n, byte b){
    if (b){
        *var = *var | (1 << n);
    }else{
        *var = *var & ~(1 << n);
    }
}

/* Vrati hodnotu bitu na pozici n promenne var */
int getBit(byte var, byte n){
    return var & (1 << n) && 1;
}

/* Precte sloupce na klavesnici */
byte readRows(void){
    byte i;
    for (i = 0; i < 4; i++){
        if (getBit(_P0, i))
            return i + 1;
    }
    
    return 0;
}

/* Z klavesnice precte znak, pokud na zadny nenarazi vrati 0 */
char getchar(void){
    _P0 = ~0;   /* nastavi vsechny bity na 1 */
    byte row = 0;
    
    /* maticova klavesnice */
    char matrix[4][4] = {
        {'1', '2', '3', 'A'},
        {'4', '5', '6', 'B'},
        {'7', '8', '9', 'C'},
        {'*', '0', '#', 'D'}
    };
    
    byte i;
    for (i = 4; i < 8; i++){
        setBit(&_P0, i, 0);
        
        row = readRows();
        if (row){
            return matrix[i - 4][row - i];
        }
        
        setBit(&_P0, i, 1);
    }
    
    return 0;
}

/* vypise retezec */
puts(char *str){
    char ch;
    while((ch = *(str++)) != 0){
        putchar(ch);
    }
}

void main(void){
    init_interrupts();
    LCD_Init();

    while(1)
      {
        putchar('a');
      }   
}
/* pstack.h v 1.1.0 (16.10.2009) by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * Simple implementation of stack.
*/

#include <stdlib.h>
#include <stdint.h>
#include "pstack.h"


/*= pstackNew ==================================================================
  Name         :  pstackNew
  Description  :  Create new stack.
  Argument(s)  :  None.
  Return value :  New pstack.
*/
pstack *pstackNew(void){
    pstack *s = malloc(sizeof(pstack));

    s->stack_len = 0;

    return s;
}
//==============================================================================


/*= pstackPush ==================================================================
  Name         :  pstackPush
  Description  :  Push one pointer into top of stack.
  Argument(s)  :  Structure pstack,
                  p -> what to put into stack.
  Return value :  None.
*/
void pstackPush(pstack *s, void *p){
    s->stack_len++;

    if (s->stack_len == 1){
        s->stack = (void **) malloc(sizeof(void *) * s->stack_len);
    }else{
        s->stack = (void **) realloc(s->stack, sizeof(void *) * s->stack_len);
    }
    
    s->stack[s->stack_len - 1] = p;
}
//==============================================================================


/*= pstackTop ===================================================================
  Name         :  pstackTop
  Description  :  Return pointer from top of stack.
  Argument(s)  :  Structure pstack.
  Return value :  Pointer from top of stack.
*/
void *pstackTop(pstack *s){
    if (s->stack_len >= 1){
        return s->stack[s->stack_len - 1];
    }else{
        return EOS;
    }
}
//==============================================================================


/*= pstackPop ===================================================================
  Name         :  pstackPop
  Description  :  Return and delete pointer from top of stack.
  Argument(s)  :  Structure pstack.
  Return value :  Pointer which was on top of stack.
*/
void *pstackPop(pstack *s){
    if (s->stack_len >= 1){
        s->stack_len--;
        
        void *p = s->stack[s->stack_len];
        s->stack = (void **) realloc(s->stack, sizeof(void *) * s->stack_len);

        return p;
    }else{
        return EOS;
    }
}
//==============================================================================


/*= pstackPop ===================================================================
  Name         :  pstackLen
  Description  :  Return lenght of pstackt.
  Argument(s)  :  Structure pstack.
  Return value :  Lenght of stack.
*/
uint16_t pstackLen(pstack *s){
    return s->stack_len;
}
//==============================================================================


/*= pstackFree =================================================================
  Name         :  pstackFree
  Description  :  Free pstack.
  Argument(s)  :  pstack which will be cleaned.
  Return value :  None.
*/
void pstackFree(pstack *s){
    free(s->stack);
    free(s);
}
//==============================================================================#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#define SIZE 100

int main(int argc, char *argv[]){
    char *b;
    int i;
    
    while (1){
        b = (char *) malloc(SIZE * sizeof(char));
        
        for(i = 0; i < SIZE; i++)
            if (b[i] > 32 && b[i] < 128 || b[i] == '\t' || b[i] == ' ' || b[i] == '\n')
                putchar(b[i]);
        puts("");
    }

    return 0;
}

/* shunting_yard.c v1.0.0 (05.10.2009) by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * Convert infix notation into RPN.
 *
 * http://cs.wikipedia.org/wiki/Shunting-yard_%28algoritmus%29
 *
*/

#include <stdint.h>
#include <stdlib.h>
#include "stcelements.h"
#include "stcparser.h"
#include "stcstack.h"



//= Definitions: ===============================================================
#define ARGUMENTS_SEPARATOR ',' // funtion arguments separator hello(one, two, three)
//==============================================================================




/*= STCelementsToRPN ===========================================================
  Name         :  STCprepareElements
  Description  :  Convert globbal array elenements from infix into reverse polish
                  notation.

                  Thx;
                    http://en.wikipedia.org/wiki/Shunting-yard_algorithm
  Argument(s)  :  None,
  Return value :  Possible error code (see STCerrors in head of this file).
*/
uint8_t STCelementsToRPN(void){
    element **output;      // in this array will be elements sorted in Reverse Polish Notation
    uint8_t outlen = 0;

    // count how much elements will be converted to RPN syntax (all elements without '(' && ')')
    for (uint8_t i = 0; i < elnum; i++){
        if (elements[i]->name[0] != '(' && elements[i]->name[0] != ')' && elements[i]->name[0] != ARGUMENTS_SEPARATOR){
            outlen++;
        }
    }
    output = (element **) malloc(sizeof(element *) * outlen);

    // Shunting yard algorithm (http://en.wikipedia.org/wiki/Shunting-yard_algorithm)
    uint8_t outcnt = 0;
    element *el = 0, *tmp = 0;
    for (uint8_t i = 0; i < elnum; i++){
        el = elements[i];               // Read token.
        if (el->type != OPERATOR_TYPE && el->type != FUNCTION_TYPE && el->type != SEPARATOR_TYPE)    // If the token is a number (string, or other),
            output[outcnt++] = el;          // then add it to the output queue.

        if (el->type == FUNCTION_TYPE)  // If the token is a function token,
            STCstackPush(el);               // then push it onto the stack.

        // If the token is a function argument separator (e.g., a comma):
        if (el->name[0] == ARGUMENTS_SEPARATOR){
            STCfreeThisElement(el); // this elemet

            while((tmp = STCstackTop()) != EOS && tmp->name[0] != '('){  // Until the token at the top of the stack is a left parenthesis,
                output[outcnt++] = STCstackPop();                           // pop operators off the stack onto the output queue.
            }
            if (tmp == EOS)                 // If no left parentheses are encountered
                return 3;                       // either the separator was misplaced or parentheses were mismatched

            continue;
        }

        // If the token is an operator, o1, then:
        if (el->type == OPERATOR_TYPE){
            while((tmp = STCstackTop()) != EOS && tmp->type == OPERATOR_TYPE){   // while there is an operator, o2, at the top of the stack (this excludes left parenthesis), and either
                if (STCgetAssoc(el->name) == L && (el->priority <= tmp->priority)){ // o1 precedence is less than (lower precedence) or equal to that of o2
                    output[outcnt++] = STCstackPop();                            // pop o2 off the stack, onto the output queue;
                }else if(STCgetAssoc(el->name) == R && (el->priority < tmp->priority)){
                    output[outcnt++] = STCstackPop();
                }else{
                    break;
                }
            }

            STCstackPush(el);                   // push o1 onto the stack
        }

        // If the token is a left parenthesis
        if (el->name[0] == '(')
            STCstackPush(el);                   // then push it onto the stack

        // If the token is a right parenthesis:
        if (el->name[0] == ')'){
            while((tmp = STCstackTop()) != EOS && tmp->name[0] != '('){  // Until the token at the top of the stack is a left parenthesis,
                output[outcnt++] = STCstackPop();   // pop operators off the stack onto the output queue.
            }
            if (tmp == EOS)                     // If the stack runs out without finding a left parenthesis,
                return 4;                           // then there are mismatched parentheses.

            STCfreeThisElement(STCstackPop());  // Pop the left parenthesis from the stack, but not onto the output queue.

            if ((tmp = STCstackTop()) != EOS && tmp->type == FUNCTION_TYPE)  // If the token at the top of the stack is a function token,
                output[outcnt++] = STCstackPop();   // pop it onto the output queue.

            STCfreeThisElement(el);
        }
    }

    // When there are no more tokens to read:
    while((tmp = STCstackPop()) != EOS){    // While there are still operator tokens in the stack:
        if (tmp->name[0] == '(')    // If the operator token on the top of the stack is a parenthesis,
            return 4;                   // then there are mismatched parentheses.
        output[outcnt++] = tmp;
    }

    // save output into elements
    elements = (element **) realloc(elements, sizeof(element *) * outcnt);
    elnum = outcnt;
    for (uint8_t i = 0; i < outcnt; i++){
        elements[i] = output[i];
    }

    free(output);

    return 0;
}
//==============================================================================//#include <sys/types.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <unistd.h>
#include <fcntl.h>
#include <sys/kd.h>

static void Beep(unsigned int, unsigned int);

int main(int argc, char **argv)
{
	Beep(1000, 2000);
	Beep(1000, 2000);
	//beep(1, 4000);
	return 0;
}

static void Beep(unsigned int ms, unsigned int freq){   // thx 2 http://lkml.org/lkml/2003/7/15/55
    int fd, arg;
    fd = open("/dev/tty0", O_RDWR);
    if (fd < 0)
	    return;
    arg = (ms << 16) | freq;
    ioctl(fd, KDMKTONE, arg);
    close(fd);
    usleep(ms*1000);
}

/* stc.c v0.7.0s (05.10.2009) by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * TODO:
 *  Predelat for smycky na uint8_t, nebo na uint16_t.
 *  Pocitat s tim, ze cislo muze vzdy obsahovat jeste - a +.
 *  Pridat v parseru podporu pro += atp..
*/

//#include <ctype.h>
//#include <string.h>
#include <stdint.h>
#include <stdio.h>  // only for test!
//#include <stdbool.h>
//#include <stdlib.h>
#include "stc.h"
//#include "stcstack.h"
#include "stcprint.h"
#include "stcparser.h"
#include "stcelements.h"
#include "shunting_yard.h"
#include "stcore.h"

//= Structures =================================================================
// pridat popis!!!

typedef struct{
    uint32_t linenum;
    char *name;
} user_function;

//==============================================================================

//= Global variables ===========================================================
uint32_t linenum = 0;   // incremented by every parsed line

char *STCerrors[]= {
    "", 
    "Line too long!",
    "Unclosed string!",
    "Misplaced separator or mismatched parentheses!",
    "Mismatched parentheses!",
    "Unknown type!",                                    // 5
    "Number too big!",
    "Bad assignment!",
    "Variable not found!",
    "Too fev arguments!"
};
// pridat pole s pameti na jakem radku nachazi ktera basic fce
// pridat pole obsahujici systemove fce
// errors?
//==============================================================================

//= STCsh ======================================================================
uint8_t STCsh(const char *line){
    uint8_t err = 0;
    //element *el;    // jen pro testovani!
    
    if ((err = STCparser(line)) != 0){
        STCprint("Error - ");
        STCprintln(STCerrors[err]);
        STCfreeElements();
        elnum = 0;
        
        return err;
    }

    /*printf("Vzorec;\n\t");
    for (int i = 0; i < elnum; i++){
        el = elements[i];
        printf("%s ", el->name);
    }
    printf("\nKonvertovan do;\n\t");*/

    // Convert elements into RPN (
    if ((err = STCelementsToRPN()) != 0){
        STCprint("Error - ");
        STCprintln(STCerrors[err]);
        STCfreeElements();
        elnum = 0;

        return err;
    }

    STCore();
    
    /* testovaci vypis
    for (int i = 0; i < elnum; i++){
        el = elements[i];
        //printf("Name: %s\nType: %d\nPriotity: %d\n\n", el->name, el->type, el->priority);
        printf("%s ", el->name);
    }
    puts("");*/
    
    STCfreeElements();
    elnum = 0;
    
    return 0;
}
//==============================================================================

void STClean(void){
    STCoreClean();
    linenum = 0;
}
/* stcelements.c v1.0.0 (03.10.2009) by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * Functions for manipulating with lexical elements of STC.
 *
*/

#include <stdint.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "stcelements.h"
#include "stcparser.h"



//= Global variables ===========================================================
uint8_t elnum = 0;
element **elements = 0;
//==============================================================================



/*= STCappendElements ==========================================================
  Name         :  STCappendElements
  Description  :  Add new element into elements (global array). Function detects
                  type of element and his priority.
  Argument(s)  :  New element.
  Return value :  None.
*/
void STCappendElements(char *str){
    elnum++;
    element *el = (element *) malloc(sizeof(element));

    // When array exist, append new element
    if (elnum > 1){
        elements = (element **) realloc(elements, sizeof(element *) * elnum);
    }else{  // or create new array
        elements = (element **) malloc(sizeof(element *) * elnum);
    }

    el->name = (char *) malloc(sizeof(char) * (strlen(str) + 1));
    el->name = strcpy(el->name, str);
    el->type = STCgetType(str);

    // if element is operator, remember his priority
    if (el->type == OPERATOR_TYPE){
        el->priority = STCisOperator(str);
    }else{
        el->priority = 0;
    }

    //elements[elnum - 1] = malloc(sizeof(element));
    elements[elnum - 1] = el;
}
//==============================================================================

/*= STCelementsCat =============================================================
  Name         :  STCelementsCat
  Description  :  Join first element with second element. Type and priority will
                  be taken from second element.
  Argument(s)  :  first -> Firs element.
                  second -> Second element.
  Return value :  None.
*/
void STCelementsCat(uint8_t first, uint8_t second){
    element **output = malloc(sizeof(element *) * (elnum - 1));
    element *newel = malloc(sizeof(element));

    // copy some elements from "elements" into output
    uint8_t i;
    for (i = 0; i < first; i++){
        output[i] = elements[i];
    }

    // allocate space for joined strings
    newel->name = (char *) malloc(sizeof(char) * (strlen(elements[first]->name) + strlen(elements[second]->name) + 1));

    // join strings
    newel->name = strcat(newel->name, elements[first]->name);
    newel->name = strcat(newel->name, elements[second]->name);
    //newel->name = strcpy(newel->name, strcat(elements[first]->name, elements[second]->name));

    // copy type and priority of second element
    newel->type = elements[second]->type;
    newel->priority = elements[second]->priority;

    // free unused elements
    STCfreeElement(first);
    STCfreeElement(second);

    // add new element into output
    output[i++] = newel;

    // add others elements in "elements" into output
    for (uint8_t j = i + 1; j < elnum; j++){
        output[i++] = elements[j];
    }

    // reallocate "elements"
    elements = realloc(elements, sizeof(element *) * --elnum);

    // copy output into elements
    for (uint8_t j = 0; j < elnum; j++){
        elements[j] = output[j];
    }

    free(output);
}
//==============================================================================

/*= STCfreeElement =============================================================
  Name         :  STCfreeElement
  Description  :  Release memory which was taken element.
  Argument(s)  :  Index of element in global array elements.
  Return value :  None.
*/
void STCfreeElement(uint8_t i){
    free(elements[i]->name);
    free(elements[i]);
}

void STCfreeThisElement(element *el){
    free(el->name);
    free(el);
}
//==============================================================================

/*= STCfreeElements ============================================================
  Name         :  STCfreeElements
  Description  :  Release memory which was taken by parts of elements (global array).
  Argument(s)  :  None.
  Return value :  None.
*/
void STCfreeElements(void){
    for (int i = 0; i < elnum; i++){
        STCfreeElement(i);
    }

    free(elements);
}
//==============================================================================
/*
 *
 * Todo:
 *  Kazdy element prvne predelat na variable, potom se snima bude lepe pracovat..
 *  Okomentovat strukturu.
 *  Pridat vyprazdneni stacku atp..
 *  Do shunting yardu pridat link na wiki, predelat na pstack.
 *
*/

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdio.h>
#include <float.h>
#include "stcelements.h"
#include "stcstack.h"
#include "stcparser.h"
#include "stcprint.h"



//= Definitions ================================================================
#define STRING  0
#define CHAR    1
#define INT32   2
//#define INT64   3
#define UINT32  4
//#define UINT64  5
//#define DOUBLE  6
#define FLOAT   5
//==============================================================================



//= Global variables ===========================================================
typedef struct {
    char *name;
    uint8_t type;
    union{
        char        *str;
        char        chr;
        int32_t     int32;
        //int64_t     int64;
        uint32_t    uint32;
        //uint64_t    uint64;
        //double      dbl;
        float       flt;
    } val;
} variable;

// for storing variables
static variable    **variables;
static uint16_t    varlen = 0;

/* Temporary variable for errors (some functions returns numbers (cant return 
 * error, so type of error is temporary stored in this var). Variable is reset
 * to 0 by calling STCore().*/
static uint8_t     error = 0;
//==============================================================================



/*==============================================================================
======================= Functions for managing variables =======================
==============================================================================*/

/*= addVar =====================================================================
  Name         :  addVar
  Description  :  Add variable into array with variables. If variable is in array
                  change only value.
  Argument(s)  :  Name of variable, value.
  Return value :  Error specified in stc.c.
*/
static uint8_t addVar(char *name, variable *value){
    variable *out;
    uint8_t isIn = isInVar(name);

    if (isIn){
        out = variables[isIn - 1];

        value->name = out->name;

        freeVal(out);

        out = value;
        //printf("\nIs in! -> %s\n\n", out->name);
    }else{
        varlen++;

        if (varlen == 1){
            variables = (variable **) malloc(sizeof(variable) * 1);
        }else{
            variables = (variable **) realloc(variables, sizeof(variable) * varlen);
        }

        out = value;

        out->name = (char *) malloc(sizeof(char) * (strlen(name) + 1));
        out->name = strcpy(out->name, name);
        //v->name[strlen(name)] = 0;
    }

    if (isIn)
        variables[isIn - 1]   = out;
    else
        variables[varlen - 1] = out;

    return 0;
}
//==============================================================================

/*= isInVar ====================================================================
  Name         :  isInVar
  Description  :  Search for "name" in array with variables and return index + 1
                  if find variable or false if not.
  Argument(s)  :  Name of variable.
  Return value :  (Index + 1) or false.
*/
static uint8_t isInVar(char *name){
    for (uint8_t i = 0; i < varlen; i++){
        if (strcmp(variables[i]->name, name) == 0)
            return i + 1;
    }

    return false;
}
//==============================================================================

/*= freeVal ====================================================================
  Name         :  freeVal
  Description  :  Free content of variable, but not his name.
  Argument(s)  :  Pointer to varriable.
  Return value :  None.
*/
static void freeVal(variable *v){
    if (v->type == STRING)
        free(v->val.str);

    free(v);
}
//==============================================================================

/*= freeVar ====================================================================
  Name         :  freeVar
  Description  :  Free variable and his name.
  Argument(s)  :  Pointer to varriable.
  Return value :  None.
*/
static void freeVar(variable *v){
    free(v->name);

    freeVal(v);
}
//==============================================================================

/*= getVarCpy ====================================================================
  Name         :  getVarCpy
  Description  :  Allocate space and copy all values from variable given by pointer.
  Argument(s)  :  Pointer to varriable.
  Return value :  Copy of variable.
*/
static variable *getVarCpy(variable *v){
    variable *out = (variable *) malloc(sizeof(variable));

    out->name = (char *) malloc(sizeof(char) * (strlen(v->name) + 1));
    out->name = strcpy(out->name, v->name);

    switch(v->type){
        case STRING:
            out->type = STRING;
            out->val.str = (char *) malloc(sizeof(char) * (strlen(v->val.str) + 1));
            out->val.str = strcpy(out->val.str, v->val.str);
            break;
        case CHAR:
            out->type = CHAR;
            out->val.chr = v->val.chr;
            break;
        case UINT32:
            out->type = UINT32;
            out->val.uint32 = v->val.uint32;
            break;
        case INT32:
            out->type = INT32;
            out->val.int32 = v->val.int32;
            break;
        case FLOAT:
            out->type = FLOAT;
            out->val.flt = v->val.flt;
            break;
    }

    return out;
}
//==============================================================================

/*= el2var =====================================================================
  Name         :  el2var
  Description  :  Convert element into variable.
  Argument(s)  :  Pointer element.
  Return value :  Pointer to variable.
*/
static variable *el2var(element *el){
    uint8_t len = strlen(el->name);
    variable *v = (variable *) malloc(sizeof(variable));

    // if name is in variables
    if (el->type == OTHER_TYPE && isInVar(el->name))
        return getVarCpy(variables[isInVar(el->name) - 1]);

    // choose a type of variable
    if (el->type == NUMBER_TYPE){                   // if element is number, create number variable
        // float point type detection
        bool flt = false;
        for (uint8_t i = 0; i < len; i++){
            if (el->name[i] == NUM_POINT)
                flt = true;
        }

        // add variable into variables
        if (flt){                       // if variable is float
            v->type = FLOAT;                // create float variable
            v->val.flt  = (float) atof(el->name);
        }else{                          // else create integer var
            int64_t num = atoi(el->name);

            if (num >= 0){              // variables with minus are stored in int32, unsigned in uint32
                if (num <= UINT32_MAX){
                    v->type   = UINT32;
                    v->val.uint32 = (uint32_t) num;
                }else{
                    error = 6;
                    return 0;   // Number too big!
                }
            }else{
                if (num >= INT32_MIN){
                    v->type   = INT32;
                    v->val.int32  = (int32_t) num;
                }else{
                    error = 6;
                    return 0;   // Number too big!
                }
            }
        }
    }else if (el->type == STRING_TYPE){
        if (el->name[0] == '\''){
            v->type    = CHAR;
            v->val.chr = el->name[1];
        }else{
            v->type    = STRING;
            v->val.str = (char *) malloc(sizeof(char) * (len - 1));
            v->val.str = strncpy(v->val.str, el->name + 1, len - 2);
            v->val.str[len - 2] = 0;
        }
    }else{
        error = 8;
        return 0;
    }

    return v;
}
//==============================================================================

/*= getIntVal ==================================================================
  Name         :  getIntVal
  Description  :  Return value of integer type as 64b int.
  Argument(s)  :  Variable (must be integer!)
  Return value :  int64_t with value of *v.
*/
static int64_t getIntVal(variable *v){
    if (v->type == UINT32)
        return v->val.uint32;
    else
        return v->val.int32;
}
//==============================================================================

/*= remVar =====================================================================
  Name         :  remVar
  Description  :  Remove variable from variables.
  Argument(s)  :  Name of variable.
  Return value :  Error 8 if variable not found.
*/
static uint8_t remVar(char *name){
    variable **output = malloc(sizeof(variable *) * (varlen - 1));
    variable *v;        // temporary variable for easiest work with variables
    uint8_t outlen = 0;
    bool removed = false;

    // find and delete variable
    for (uint8_t i = 0; i < varlen; i++){
        v = variables[i];
        
        if (strcmp(v->name, name) == 0){
            freeVar(v);
            removed = true;
        }else{
            output[outlen++] = v;
        }
    }

    // if variable was found and removed, realloc variables
    if (removed){
        varlen--;
        variables = (variable **) realloc(variables, sizeof(variable *) * varlen);

        for (uint8_t i = 0; i < varlen; i++){
            variables[i] = output[i];
        }
    }

    free(output);

    if (removed)
        return 0;
    else
        return 8;   // Error - Variable not found!
}
//==============================================================================



/*==============================================================================
=========================== Language functions =================================
==============================================================================*/

/*= saveInto ===================================================================
  Name         :  saveInto (=)
  Description  :  Create variable.
  Argument(s)  :  None.
  Return value :  Error defined in stc.c.
*/
static uint8_t OPsaveInto(void){
    element *into, *what;

    what = STCstackPop();
    into = STCstackPop();

    if (!what || !into)
        return 9;   // Too few arguments!

    if (into->type != OTHER_TYPE)
        return 7;   // Bad assignment!

    if (addVar(into->name, el2var(what)) != 0)
        return error;
    else
        return 0;
}
//==============================================================================

static uint8_t OPplus(void){
    element  *e1, *e2;
    variable *v1, *v2, *retval;

    e1 = STCstackPop();
    e2 = STCstackPop();

    if (!e1 || !e2)
        return 9;   // Too few arguments!

    v1 = el2var(e1);
    v2 = el2var(e2);

    if ((v1->type != CHAR && v1->type != STRING) && (v2->type != CHAR && v2->type != STRING)){  // if both variables are number
        if (v1->type != FLOAT && v2->type != FLOAT){     // if value isnt float (is some type of int)
            int64_t val;
            val = getIntVal(v1) + getIntVal(v2);

            if (val > UINT32_MAX || val < INT32_MIN)    // if number is too big
                return 6;                                   // return Number too big!

            retval = (variable *) malloc(sizeof(variable));
            if (val >= 0){
                retval->type = UINT32;
                retval->val.uint32 = (uint32_t) val;
            }else{
                retval->type = INT32;
                retval->val.int32  = (int32_t) val;
            }
        }else{                                      // if one variable is float
            double val1, val2, val;

            // save v1 into val1 as float
            if (v1->type == FLOAT)
                val1 = (double) v1->val.flt;
            else
                val1 = (double) getIntVal(v1);

            // save v2 into val2 as float
            if (v2->type == FLOAT)
                val2 = (double) v2->val.flt;
            else
                val2 = (double) getIntVal(v2);

            val = val1 + val2;

            if (val >= FLT_MAX || val < FLT_MIN)
                return 6;

            retval = (variable *) malloc(sizeof(variable));
            retval->type = FLOAT;
            retval->val.flt = (float) val;
        }
    }else if ((v1->type == STRING || v1->type == CHAR) && (v2->type == STRING || v2->type == CHAR)){
        char *val1, *val2;
        retval = (variable *) malloc(sizeof(variable));

        if (v1->type == CHAR){
            val1 = malloc(sizeof(char) * 2);
            val1[0] = v1->val.chr;
            val1[1] = 0;
        }else
            val1 = v1->val.str;

        if (v2->type == CHAR){
            val2 = malloc(sizeof(char) * 2);
            val2[0] = v2->val.chr;
            val2[1] = 0;
        }else
            val1 = v2->val.str;

        retval->type = STRING;
        retval->val.str = (char *) malloc(sizeof(char) * (strlen(val1) + strlen(val2) + 1));
        retval->val.str = strcat(retval->val.str, val1);
        retval->val.str = strcat(retval->val.str, val2);

        if (v1->type == CHAR)
            free(val1);
        if (v2->type == CHAR)
            free(val2);
    }

    // dont forget free all stuff
    //STCstackPush()
}


/*==============================================================================
==================================== CORE ======================================
==============================================================================*/
uint8_t STCore(void){
    element *el;
    error = 0;
    uint8_t retval = 0;

    for (uint8_t i = 0; i < elnum; i++){
        el = elements[i];

        if (el->type != OPERATOR_TYPE && el->type != FUNCTION_TYPE){    // some kind of value
            STCstackPush(el);
        }else if (el->type == OPERATOR_TYPE){
            // sem pridat viceznake operatory

            switch (el->name[0]){
                case '=':
                    OPsaveInto();
                    break;
                case '+':
                    OPplus();
                    break;
            }
        }else if (el->type == FUNCTION_TYPE){
            
        }else{  // error unknown type!
            return 5;
        }
    }

    while ((el = STCstackPop()) != EOS){
        STCprintln(el->name);
    }

    
    puts("Variables;");
    for (uint8_t i = 0; i < varlen; i++){
        printf("\tName:\t%s\n\tType:\t%d ", variables[i]->name, variables[i]->type);
        switch(variables[i]->type){
            case STRING:
                puts("(string)");
                printf("\tVal:\t%s\n", variables[i]->val.str);
                break;
            case CHAR:
                puts("(char)");
                printf("\tVal:\t%c\n", variables[i]->val.chr);
                break;
            case INT32:
                puts("(int32_t)");
                printf("\tVal:\t%d\n", variables[i]->val.int32);
                break;
            case UINT32:
                puts("(uint32_t)");
                printf("\tVal:\t%d\n", variables[i]->val.uint32);
                break;
            case FLOAT:
                puts("(float)");
                printf("\tVal:\t%f\n", variables[i]->val.flt);
                break;
        }

        puts("");
    }

    return retval;
}

void STCoreClean(void){
    for (uint8_t i = 0; i < varlen; i++){
        freeVar(variables[i]);
    }

    free(variables);
    varlen = 0;
}/* stcparser.c v1.1.0 (05.10.2009) by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * Parse input text into lexical elements (numbers, strings, functions, operators,
 * variables, etc..).
 *
 * Todo:
 *  Podpora ==, !=, >=, <=
*/

#include <stdint.h>
#include <ctype.h>
#include <string.h>
#include <stdbool.h>
#include "stc.h"
#include "stcparser.h"
#include "stcelements.h"



//= Configuration: =============================================================
#define OPERATORS      {"^", "*", "/", "%", "+", "-", "="}   // all possible operators
#define OP_PRIORITY    { 7,   6 ,  6,   6,   5,   5,   1}    // priority
#define OP_ASSOC       { R,   L,   L,   L,   L,   L,   L}    // associativity
//==============================================================================



/*= STCisFunction ==============================================================
  Name         :  STCisFunction
  Description  :  Return true or false if argument is/isn't name of function.
  Argument(s)  :  Name of function.
  Return value :  True or false.
*/
static bool STCisFunction(char *str){
    // zde bude nejaky generovani jmen fci
    char *functions[] = {"print", "for"};
    uint8_t size = sizeof(functions) / sizeof(char *);

    for (int i = 0; i < size; i++){
        if (strcmp(functions[i], str) == 0)
            return true;
    }

    return false;
}
//==============================================================================

/*= STCisOperator ==============================================================
  Name         :  STCisOperator
  Description  :  If argument is operator, return priority of operator, or false
                  when argument isn't operator.
  Argument(s)  :  Name of possible operator.
  Return value :  Priority of operator or false.
*/
uint8_t STCisOperator(char *str){
    char *operators[]  = OPERATORS;
    uint8_t priority[] = OP_PRIORITY;
    uint8_t size = sizeof(operators) / sizeof(char *);

    for (uint8_t i = 0; i < size; i++){
        if (strcmp(str, operators[i]) == 0){
            return priority[i];
        }
    }

    return false;
}
//==============================================================================

/*= STCgetAssoc ================================================================
  Name         :  STCgetAssoc
  Description  :  Return L or R (see definition in stcparser.h and head of this
                  file) if parametr is left or right associative.
 
                  Txh to;
                   http://en.wikipedia.org/wiki/Operator_associativity
                   http://en.literateprograms.org/Shunting_yard_algorithm_%28C%29
  Argument(s)  :  String with operator.
  Return value :  L or R when operator is left/right associative.
*/
uint8_t STCgetAssoc(char *str){
    char *operators[]  = OPERATORS;
    bool assoc[]       = OP_ASSOC;

    uint8_t size = sizeof(operators) / sizeof(char *);
    for (uint8_t i = 0; i < size; i++){
        if (strcmp(str, operators[i]) == 0){
            return assoc[i];
        }
    }

    return 0;
}
// =============================================================================


/*= STCisNum ===================================================================
  Name         :  STCisNum
  Description  :  Return true if all chars represent digits.
  Argument(s)  :  String.
  Return value :  True / false.
*/
static bool STCisNum(char *str){
    uint8_t len = strlen(str);

    for (uint8_t i = 0; i < len; i++){
        if (!isdigit(str[i]))
            return false;
    }

    return true;
}
//==============================================================================

/*= STCgetType =================================================================
  Name         :  STCgetType
  Description  :  Detect type of element.
  Argument(s)  :  String with name of element.
  Return value :  Type of element (see _TYPE definitions in top of this file).
*/
uint8_t STCgetType(char *str){
    if (str[0] == '"' || str[0] == '\''){
        return STRING_TYPE;
    }else if (STCisNum(str)){
        return NUMBER_TYPE;
    }else if (STCisOperator(str)){
        return OPERATOR_TYPE;
    }else if (STCisFunction(str)){
        return FUNCTION_TYPE;
    }else if (ispunct((char) str[0])){  // separators are ever only one char
        return SEPARATOR_TYPE;
    }else{
        return OTHER_TYPE;
    }
}
//==============================================================================

/*= STCprepareElements =========================================================
  Name         :  STCprepareElements
  Description  :  
  Argument(s)  :  None,
  Return value :  None.
*/
static void STCprepareElements(void){
    if (elnum > 2){
        for (uint8_t i = 2; i < elnum; i++){

            // join - and number when you mean -n
            if (elements[i-2]->type != NUMBER_TYPE){
                if (elements[i - 1]->name[0] == '-' || elements[i - 1]->name[0] == '+'){
                    if (elements[i]->type == NUMBER_TYPE){
                        STCelementsCat(i-1, i);
                    }
                }
            }

            // join num . num into num.num (for example: 3 . 1 into 3.1)
            if (elements[i-2]->type == NUMBER_TYPE && elements[i-1]->name[0] == NUM_POINT && elements[i]->type == NUMBER_TYPE){
                STCelementsCat(i-2, i-1);
                STCelementsCat(i-2, i-1);
            }
        }
    }else if (elnum == 2){
        // join - and number when you mean -n
        if ((elements[0]->name[0] == '-' || elements[0]->name[0] == '+') && elements[1]->type == NUMBER_TYPE){
            STCelementsCat(0, 1);
        }
    }
}
//==============================================================================

/*= STCparser ==================================================================
  Name         :  STCparser
  Description  :  Split input line into lexical elements.
  Argument(s)  :  *line -> Text which will be splited.
  Return value :  Errors defined in "STCerrors" (see top of this file).
*/
uint8_t STCparser(const char *line){
    uint8_t linelen = strlen(line);

    linenum++;
    elnum = 0;

    if (linelen <= 0)
        return 0;

    // if line is loger then MAX_IN_LINE_LEN chars, return error 1 (Line too long)
    if (linelen > MAX_IN_LINE_LEN){
        // pridat for smycku, ktera od konce projizdi na zacatek a hleda # ..
        // taky nejakou ochranu proti retezcum
        return 1;
    }

    // parse elements
    if (linelen > 2){   // minimum length of line (buffer is 2 chars)
        char rold = 0, old = 0, act = 0, strend = 0;
        char buffer[PARSER_BUFFER_LEN];
        bool strlck= false;

        old = line[0];
        for (uint8_t i = 1, j = 0; i < linelen + 1; i++, rold = old, old = act){
            act = line[i];

            // Comments parser
            // If found COMMENT_CHAR, skip other text
            if (rold != '\\' && old == COMMENT_CHAR)
                break;

            // string parser
            if (old == '\'' || old == '\"'){
                strend= old;
                buffer[j++]= old;
                strlck= false;

                // do next step (read next chars into buffer) (in firs iteration, old cant be equal strend)
                rold= old;
                old= act;
                act= line[++i];

                // read until old != strend
                for (; i < linelen + 1; i++, rold = old, old = act){
                    act= line[i];
                    buffer[j++]= old;

                    // when old == \, read next char and continue (char after \ is part of escape sequence)
                    if (old == '\\'){
                        buffer[j++]= act;
                        act= line[++i];
                        continue;
                    }

                    // if this is end of string, close buffer, reset j and break
                    if (old == strend){
                        buffer[j]= 0;
                        j= 0;
                        break;
                    }
                }

                // if string is unclosed, return error 2 (Unclosed string!)
                if (i >= linelen + 1){
                    return 2;
                }

                // append element
                STCappendElements(buffer);

            }else if (isalpha(old) || (ispunct(old) && old != '"') || isdigit(old)){
                // strend identify what is actual block of text
                if (isalnum(old)){  // numbers and chars (orchoj43, 32an)
                    strend= 0;
                }else if (ispunct(old)){    // others (+-/%.,, etc..)
                    strend= 1;
                }else if (isdigit(old)){    // numbers (435)
                    strend= 2;
                }

                // read continuous text block
                for (; i < linelen + 1; i++, rold = old, old = act){
                    act= line[i];

                    buffer[j++]= old;

                    if (strend == 0 && !isalnum(act)){
                        break;
                    }else if ((act == '"' || act == '\'' || act == '#') || (strend == 1)){// && !ispunct(act))){
                        break;
                    }else if (strend == 2 && !isdigit(act)){
                        break;
                    }
                }

                buffer[j]= 0;
                j= 0;

                // append element
                STCappendElements(buffer);
            }
        }
    }else{  // if line is
        if (isalnum(line[0]) && isalnum(line[1])){
            char buffer[3];

            buffer[0] = line[0];
            buffer[1] = line[1];
            buffer[2] = 0;

            STCappendElements(buffer);
        }else{
            char buffer[2];

            buffer[0] = line[0];
            STCappendElements(buffer);

            buffer[0] = line[1];
            STCappendElements(buffer);
        }
    }

    STCprepareElements();

    return 0;
}
//==============================================================================/* stcprint.c v1.0.0 (03.10.2009) by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * Simple print functions.
 * 
*/

#include <stdio.h>  // only for computers
#include <stdint.h>
#include <string.h>



//= Definitions ================================================================
// how much long can be line printed on output device (standard conzole have 80 chars)
#define MAX_OUT_LINE_LEN    80 // max len is 255 chars - see "uint8_t" in STCprint()
//==============================================================================



/*= STCputchar =================================================================
  Name         :  STCputchar
  Description  :  Print one character into output. If you port this source code
                  into uprocessor, replace putchar(c) with your own putchar
                  function (for example; Serial.print() in arduino).
  Argument(s)  :  c -> Character.
  Return value :  None.
*/
void STCputchar(const char c){
    // put your putchar fcion here
    putchar(c);
}
//==============================================================================


/*= STCprint ===================================================================
  Name         :  STCprint
  Description  :  Print line.
  Argument(s)  :  *line -> Text which will be printed.
  Return value :  None.
*/
void STCprint(const char *line){
    uint8_t linelen = strlen(line);

    // this block break long lines into MAX_OUT_LINE_LEN
    for (uint8_t i = 0, cnt = 0; i < linelen; i++){
        if (cnt >= MAX_OUT_LINE_LEN){
            STCputchar('\n');
            cnt = 0;
        }

        if (line[i] == '\n'){
            cnt = 0;
        }else{
            cnt++;
        }

        putchar(line[i]);
    }
}
//==============================================================================


/*= STCprintln =================================================================
  Name         :  STCprintln
  Description  :  Print line with '\n' at the end of line.
  Argument(s)  :  *line -> Text which will be printed.
  Return value :  None.
*/
void STCprintln(const char *line){
    STCprint(line);
    STCputchar('\n');
}
//==============================================================================/* stcstack.h v 1.0.0 (04.10.2009) by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * Simple implementation of elements stack.
 *
*/

#include <stdlib.h>
#include <stdint.h>
#include "stcstack.h"
#include "stcelements.h"



//= Global variables ===========================================================
static element **stack   = 0;
static uint8_t stack_len = 0;
//==============================================================================



/*= STCstackPush ===============================================================
  Name         :  STCstackPush
  Description  :  Push one element into top of stack.
  Argument(s)  :  word -> what to put into stack.
  Return value :  None.
*/
void STCstackPush(element *el){
    stack_len++;

    if (stack_len == 1){
        stack = (element **) malloc(sizeof(element *) * stack_len);
    }else{
        stack = (element **) realloc(stack, sizeof(element *) * stack_len);
    }
    
    stack[stack_len - 1] = el;
}
//==============================================================================


/*= STCstackTop ================================================================
  Name         :  STCstackTop
  Description  :  Return value from top of stack.
  Argument(s)  :  None.
  Return value :  String from top of stack.
*/
element *STCstackTop(void){
    if (stack_len >= 1){
        return stack[stack_len - 1];
    }else{
        return EOS;
    }
}
//==============================================================================


/*= STCstackPop ================================================================
  Name         :  STCstackPop
  Description  :  Return and delete value from top of stack.
  Argument(s)  :  None.
  Return value :  String which was on top of stack.
*/
element *STCstackPop(void){
    if (stack_len >= 1){
        stack_len--;
        
        element *el = stack[stack_len];
        stack = (element **) realloc(stack, sizeof(element *) * stack_len);

        return el;
    }else{
        return EOS;
    }
}
//==============================================================================

#include <stdio.h>

int main(int argc, char *argv[]){

    system("swapoff -a");
    system("swapon -a");
    
    return 0;
}

//#include <stdio.h>

int main(int argc, char *argv[]){

    system("ls");
    
    return 0;
}

/** Ukazatele 
 * @version v1.0.0 (14.05.09)
 * @author Bystroushaak (bystrousak@kitakitsune.org)
 * @tags C, ukazatele
 *
 * Jednoduchy priklad ilustrujici funkci ukazatelu.
*/

#include <stdio.h>

int main(void){
    char i= 22;
    printf("char i= 22;\n");
    printf("i:\t%d\n", i);
    printf("&i:\t0x%x\n", &i);
    
    char *p;
    printf("\n---\nchar *p;\n");
    printf("p:\t0x%x\n", p);
    printf("*p:\t%d\n", *p);
    printf("&p:\t0x%x\n", &p);
          
    p= &i;
    printf("\n---\np= &i;\n");
    printf("p:\t0x%x\n", p);
    printf("*p:\t%d\n", *p);
    printf("&p:\t0x%x\n", &p);
          
    return 0;
}
/* Name: usbdrv.c
 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
 * Author: Christian Starkjohann
 * Creation Date: 2004-12-29
 * Tabsize: 4
 * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
 * This Revision: $Id: usbdrv.c 763 2009-08-22 10:27:24Z cs $
 */

#include "usbportability.h"
#include "usbdrv.h"
#include "oddebug.h"

/*
General Description:
This module implements the C-part of the USB driver. See usbdrv.h for a
documentation of the entire driver.
*/

/* ------------------------------------------------------------------------- */

/* raw USB registers / interface to assembler code: */
uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but not used */
volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow control */
uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 0 */
uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handshake token */
uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains handshake token */
#if USB_COUNT_SOF
volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
#endif
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
usbTxStatus_t  usbTxStatus1;
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
usbTxStatus_t  usbTxStatus3;
#   endif
#endif
#if USB_CFG_CHECK_DATA_TOGGLING
uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
#endif

/* USB status registers / not shared with asm code */
uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
static uchar        usbMsgFlags;    /* flag values see below */

#define USB_FLG_MSGPTR_IS_ROM   (1<<6)
#define USB_FLG_USE_USER_RW     (1<<7)

/*
optimizing hints:
- do not post/pre inc/dec integer values in operations
- assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
- use narrow scope for variables which should be in X/Y/Z register
- assign char sized expressions to variables to force 8 bit arithmetics
*/

/* -------------------------- String Descriptors --------------------------- */

#if USB_CFG_DESCR_PROPS_STRINGS == 0

#if USB_CFG_DESCR_PROPS_STRING_0 == 0
#undef USB_CFG_DESCR_PROPS_STRING_0
#define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
PROGMEM char usbDescriptorString0[] = { /* language descriptor */
    4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
    3,          /* descriptor type */
    0x09, 0x04, /* language index (0x0409 = US-English) */
};
#endif

#if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
#undef USB_CFG_DESCR_PROPS_STRING_VENDOR
#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
PROGMEM int  usbDescriptorStringVendor[] = {
    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
    USB_CFG_VENDOR_NAME
};
#endif

#if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
#undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
PROGMEM int  usbDescriptorStringDevice[] = {
    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
    USB_CFG_DEVICE_NAME
};
#endif

#if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
#undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
PROGMEM int usbDescriptorStringSerialNumber[] = {
    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
    USB_CFG_SERIAL_NUMBER
};
#endif

#endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */

/* --------------------------- Device Descriptor --------------------------- */

#if USB_CFG_DESCR_PROPS_DEVICE == 0
#undef USB_CFG_DESCR_PROPS_DEVICE
#define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
    USBDESCR_DEVICE,        /* descriptor type */
    0x10, 0x01,             /* USB version supported */
    USB_CFG_DEVICE_CLASS,
    USB_CFG_DEVICE_SUBCLASS,
    0,                      /* protocol */
    8,                      /* max packet size */
    /* the following two casts affect the first byte of the constant only, but
     * that's sufficient to avoid a warning with the default values.
     */
    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
    USB_CFG_DEVICE_VERSION, /* 2 bytes */
    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
    1,          /* number of configurations */
};
#endif

/* ----------------------- Configuration Descriptor ------------------------ */

#if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
#undef USB_CFG_DESCR_PROPS_HID
#define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
#endif

#if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
#undef USB_CFG_DESCR_PROPS_CONFIGURATION
#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
    USBDESCR_CONFIG,    /* descriptor type */
    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
                (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
                /* total length of data returned (including inlined descriptors) */
    1,          /* number of interfaces in this configuration */
    1,          /* index of this configuration */
    0,          /* configuration name string index */
#if USB_CFG_IS_SELF_POWERED
    (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
#else
    (1 << 7),                           /* attributes */
#endif
    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
/* interface descriptor follows inline: */
    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
    USBDESCR_INTERFACE, /* descriptor type */
    0,          /* index of this interface */
    0,          /* alternate setting for this interface */
    USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of endpoint descriptors to follow */
    USB_CFG_INTERFACE_CLASS,
    USB_CFG_INTERFACE_SUBCLASS,
    USB_CFG_INTERFACE_PROTOCOL,
    0,          /* string index for interface */
#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
    USBDESCR_HID,   /* descriptor type: HID */
    0x01, 0x01, /* BCD representation of HID version */
    0x00,       /* target country code */
    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
    0x22,       /* descriptor type: report */
    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
#endif
#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
    7,          /* sizeof(usbDescrEndpoint) */
    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
    (char)0x81, /* IN endpoint number 1 */
    0x03,       /* attrib: Interrupt endpoint */
    8, 0,       /* maximum packet size */
    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
#endif
#if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
    7,          /* sizeof(usbDescrEndpoint) */
    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
    (char)0x83, /* IN endpoint number 1 */
    0x03,       /* attrib: Interrupt endpoint */
    8, 0,       /* maximum packet size */
    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
#endif
};
#endif

/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
#   endif
#endif
}

static inline void  usbResetStall(void)
{
#if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
        usbTxLen1 = USBPID_NAK;
#if USB_CFG_HAVE_INTRIN_ENDPOINT3
        usbTxLen3 = USBPID_NAK;
#endif
#endif
}

/* ------------------------------------------------------------------------- */

#if !USB_CFG_SUPPRESS_INTR_CODE
#if USB_CFG_HAVE_INTRIN_ENDPOINT
static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
{
uchar   *p;
char    i;

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
    usbCrc16Append(&txStatus->buffer[1], len);
    txStatus->len = len + 4;    /* len must be given including sync byte */
    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus1);
}
#endif

#if USB_CFG_HAVE_INTRIN_ENDPOINT3
USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus3);
}
#endif
#endif /* USB_CFG_SUPPRESS_INTR_CODE */

/* ------------------ utilities for code following below ------------------- */

/* Use defines for the switch statement so that we can choose between an
 * if()else if() and a switch/case based implementation. switch() is more
 * efficient for a LARGE set of sequential choices, if() is better in all other
 * cases.
 */
#if USB_CFG_USE_SWITCH_STATEMENT
#   define SWITCH_START(cmd)       switch(cmd){{
#   define SWITCH_CASE(value)      }break; case (value):{
#   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
#   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
#   define SWITCH_DEFAULT          }break; default:{
#   define SWITCH_END              }}
#else
#   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
#   define SWITCH_CASE(value)      }else if(_cmd == (value)){
#   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
#   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
#   define SWITCH_DEFAULT          }else{
#   define SWITCH_END              }}
#endif

#ifndef USB_RX_USER_HOOK
#define USB_RX_USER_HOOK(data, len)
#endif
#ifndef USB_SET_ADDRESS_HOOK
#define USB_SET_ADDRESS_HOOK()
#endif

/* ------------------------------------------------------------------------- */

/* We use if() instead of #if in the macro below because #if can't be used
 * in macros and the compiler optimizes constant conditions anyway.
 * This may cause problems with undefined symbols if compiled without
 * optimizing!
 */
#define GET_DESCRIPTOR(cfgProp, staticName)         \
    if(cfgProp){                                    \
        if((cfgProp) & USB_PROP_IS_RAM)             \
            flags = 0;                              \
        if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
            len = usbFunctionDescriptor(rq);        \
        }else{                                      \
            len = USB_PROP_LENGTH(cfgProp);         \
            usbMsgPtr = (uchar *)(staticName);      \
        }                                           \
    }

/* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 * internally for all types of descriptors.
 */
static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar       flags = USB_FLG_MSGPTR_IS_ROM;

    SWITCH_START(rq->wValue.bytes[1])
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
            flags = 0;
        len = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
        SWITCH_CASE(1)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
        SWITCH_CASE(2)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
        SWITCH_CASE(3)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumber)
        SWITCH_DEFAULT
            if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
                len = usbFunctionDescriptor(rq);
            }
        SWITCH_END
#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
#endif
    SWITCH_DEFAULT
        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
            len = usbFunctionDescriptor(rq);
        }
    SWITCH_END
    usbMsgFlags = flags;
    return len;
}

/* ------------------------------------------------------------------------- */

/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */
uchar   value = rq->wValue.bytes[0];
#if USB_CFG_IMPLEMENT_HALT
uchar   index = rq->wIndex.bytes[0];
#endif

    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
    SWITCH_START(rq->bRequest)
    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
#if USB_CFG_IMPLEMENT_HALT
        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
            dataPtr[0] = usbTxLen1 == USBPID_STALL;
#endif
        dataPtr[1] = 0;
        len = 2;
#if USB_CFG_IMPLEMENT_HALT
    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
            usbResetDataToggling();
        }
#endif
    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
        usbNewDeviceAddr = value;
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
        len = usbDriverDescriptor(rq);
        goto skipMsgPtrAssignment;
    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
        dataPtr = &usbConfiguration;  /* send current configuration value */
        len = 1;
    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
        usbConfiguration = value;
        usbResetStall();
    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
        len = 1;
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
        usbResetDataToggling();
        usbResetStall();
#endif
    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
        /* Should we add an optional hook here? */
    SWITCH_END
    usbMsgPtr = dataPtr;
skipMsgPtrAssignment:
    return len;
}

/* ------------------------------------------------------------------------- */

/* usbProcessRx() is called for every message received by the interrupt
 * routine. It distinguishes between SETUP and DATA packets and processes
 * them accordingly.
 */
static inline void usbProcessRx(uchar *data, uchar len)
{
usbRequest_t    *rq = (void *)data;

/* usbRxToken can be:
 * 0x2d 00101101 (USBPID_SETUP for setup data)
 * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 * 0...0x0f for OUT on endpoint X
 */
    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
    USB_RX_USER_HOOK(data, len)
#if USB_CFG_IMPLEMENT_FN_WRITEOUT
    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
        usbFunctionWriteOut(data, len);
        return;
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
            return;
        usbMsgLen_t replyLen;
        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
        usbTxLen = USBPID_NAK;              /* abort pending transmit */
        usbMsgFlags = 0;
        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
            replyLen = usbFunctionSetup(data);
        }else{
            replyLen = usbDriverSetup(rq);
        }
#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
            /* do some conditioning on replyLen, but on IN transfers only */
            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
                    replyLen = rq->wLength.bytes[0];
                }else{
                    replyLen = rq->wLength.word;
                }
            }
            usbMsgFlags = USB_FLG_USE_USER_RW;
        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
#endif
        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
                replyLen = rq->wLength.bytes[0];
        }else{
            if(replyLen > rq->wLength.word)     /* limit length to max */
                replyLen = rq->wLength.word;
        }
        usbMsgLen = replyLen;
    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
#if USB_CFG_IMPLEMENT_FN_WRITE
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
            uchar rval = usbFunctionWrite(data, len);
            if(rval == 0xff){   /* an error occurred */
                usbTxLen = USBPID_STALL;
            }else if(rval != 0){    /* This was the final package */
                usbMsgLen = 0;  /* answer with a zero-sized data packet */
            }
        }
#endif
    }
}

/* ------------------------------------------------------------------------- */

/* This function is similar to usbFunctionRead(), but it's also called for
 * data handled automatically by the driver (e.g. descriptor reads).
 */
static uchar usbDeviceRead(uchar *data, uchar len)
{
    if(len > 0){    /* don't bother app with 0 sized reads */
#if USB_CFG_IMPLEMENT_FN_READ
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
            len = usbFunctionRead(data, len);
        }else
#endif
        {
            uchar i = len, *r = usbMsgPtr;
            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
                do{
                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
                    *data++ = c;
                    r++;
                }while(--i);
            }else{  /* RAM data */
                do{
                    *data++ = *r++;
                }while(--i);
            }
            usbMsgPtr = r;
        }
    }
    return len;
}

/* ------------------------------------------------------------------------- */

/* usbBuildTxBlock() is called when we have data to transmit and the
 * interrupt routine's transmit buffer is empty.
 */
static inline void usbBuildTxBlock(void)
{
usbMsgLen_t wantLen;
uchar       len;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
        len += 4;           /* length including sync byte */
        if(len < 12)        /* a partial package identifies end of message */
            usbMsgLen = USB_NO_MSG;
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = USB_NO_MSG;
    }
    usbTxLen = len;
    DBG2(0x20, usbTxBuf, len-1);
}

/* ------------------------------------------------------------------------- */

static inline void usbHandleResetHook(uchar notResetState)
{
#ifdef USB_RESET_HOOK
static uchar    wasReset;
uchar           isReset = !notResetState;

    if(wasReset != isReset){
        USB_RESET_HOOK(isReset);
        wasReset = isReset;
    }
#endif
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbPoll(void)
{
schar   len;
uchar   i;

    len = usbRxLen - 3;
    if(len >= 0){
/* We could check CRC16 here -- but ACK has already been sent anyway. If you
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
#endif
    }
    if(usbTxLen & 0x10){    /* transmit system idle */
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
        uchar usbLineStatus = USBIN & USBMASK;
        if(usbLineStatus != 0)  /* SE0 has ended */
            goto isNotReset;
    }
    /* RESET condition, called multiple times during reset */
    usbNewDeviceAddr = 0;
    usbDeviceAddr = 0;
    usbResetStall();
    DBG1(0xff, 0, 0);
isNotReset:
    usbHandleResetHook(i);
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    usbResetDataToggling();
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    usbTxLen1 = USBPID_NAK;
#if USB_CFG_HAVE_INTRIN_ENDPOINT3
    usbTxLen3 = USBPID_NAK;
#endif
#endif
}

/* ------------------------------------------------------------------------- */
/* Validni cisla RZP.cz v1.0.0 (31.07.09)
 * 
 * Vygeneruje cisla, ktere se daji pouzit k vyhledavani na strankach rzp.cz
*/

#include <stdio.h>

#define ICLEN 8

typedef unsigned long int ulint;

// prevede nejake cislo ve formatu ulint na pole osmi charu (cisla jsou vyjadrena primo, ne v ascii!)
void toDigit(ulint ic, char *strIC){
    int i;
    ulint tmp= ic;
    ulint num= 10000000;    // cislo je osmiznake, proto potrebujem cislo deset milionu (8 cisel)
    
    for (i = 0; i < ICLEN; i++){
        *strIC= (tmp / num);
        tmp%= num;
        num= num / 10;
        strIC++;
    }
}

// thx to http://www.rzp.cz/js/form.js
int isValid(ulint num){
    int i;
    char strIC[]= "00000000";
    
    // prevedeni cisla na pole charu
    toDigit(num, strIC);   
    
    //kontrolni soucet vahovych soucinu
    int lsoucet= 0;
    for (i = 8; i > 1; i--){
        lsoucet+= (i * strIC[8 - i]);
    }
    int lzbytek= lsoucet % 11;
    
    //kontrolni cislice
    int kontrolnicislo= 0;
    switch(lzbytek){
        case 0:
            kontrolnicislo= 1;
            break;
        case 1:
            kontrolnicislo= 0;
            break;
        case 10:
            kontrolnicislo= 1;
            break;
        default:
            kontrolnicislo= 11 - lzbytek;
            break;
    }
    
    if (kontrolnicislo != strIC[7]){
        return 0;
    }
    
    return 1;
}

int main(int argc, char *argv[]){
    ulint num;
    int n=0;

    //printf("## Generator cisel k vyhledavani pro stranky rzp.cz\n##Zacinam generovat:\n");

    // nejmensi validni cislo co se mi podarilo najit je 10110003, nejvetsi 13654000
    for (num = 10110003; num < 13654000; num++){
        if (isValid(num)){
            printf("http://www.rzp.cz/cgi-bin/aps_cacheWEB.sh?VSS_SERV=ZVWSBJFND&Action=Search&PRESVYBER=0&PODLE=subjekt&ICO=%lu&OBCHJM=&JMENO=&PRIJMENI=&ROLE=&OKRES=&OBEC=&CASTOBCE=&ULICE=&COR=&COZ=&CDOM=&VYPIS=1\n", num);
            //n++;
        }
    }
    
    //printf("## Bylo nalezeno celkem %d podnikatelu.\n", n);
    
    return 0;
}
/* WAVInfo.c v1.1.0 - beta (24.09.09) by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * O programu;
 *      Vypise detailni informace o WAV souboru.
 *
 * Licence:
 *  This work is licensed under a Creative Commons Attribution Noncommercial
 *  Share Alike 3.0 Unported License.
 *  (http://creativecommons.org/licenses/by-nc-sa/3.0/cz/)
 *
 * Thx:
 *  http://www.sonicspot.com/guide/wavefiles.html
 *  http://ccrma.stanford.edu/courses/422/projects/WaveFormat/
 *  &
 *  independent, TheDarkAvenger, PiN, warriant, #freedom99@irc.c0renet.sk:6667
 *
 * TODO:
 *  Detekci formatu mozna provadet pomoci strcmp ignore case.
 * 
*/

#include <stdio.h>
#include <string.h>     // kvuli strcmp
#include "WAVheads.h"

// postupne nacita jednotlive chunks a predava je fcim pro vypsani
void printHeads(FILE *f){
    char buffer[5];

    puts("= Chunks: ======================================================================");

    while(fread(buffer, 4, 1, f)){
        buffer[4]= 0;

        if (strncmp(buffer, "RIFF", 4) == 0){
            printRiffChunk(getRiffChunk(f, buffer));
        }else if (strncmp(buffer, "fmt ", 4) == 0){
            printFmtChunk(getFmtChunk(f, buffer));
        }else if (strncmp(buffer, "data", 4) == 0){
            printDataChunk(getDataChunk(f, buffer));
        }else if (strncmp(buffer, "fact", 4) == 0){
            printFactChunk(getFactChunk(f, buffer));
        }else if (strncmp(buffer, "cue ", 4) == 0){
            printCueChunk(getCueChunk(f, buffer));
        }else if (strncmp(buffer, "plst", 4) == 0){
            printPlstChunk(getPlstChunk(f, buffer));
        }else if (strncmp(buffer, "wavl", 4) == 0){
            printWavlChunk(getWavlChunk(f, buffer));
        }else if (strncmp(buffer, "inst", 4) == 0){
            printInstChunk(getInstChunk(f, buffer));
        }else if (strncmp(buffer, "list", 4) == 0){
            printListChunk(f, getListChunk(f, buffer)); // obsahuje ruzne subchunky a protoze se mi nechce vymyslet nejaky slozity zpusob jak je ukladat do list chunku, radsi je rovnou vypisuju
        }else if (strncmp(buffer, "smpl", 4) == 0){
            printSmplChunk(getSmplChunk(f, buffer));
        }else{
            printUnsupportedChunk(getUnsupportedChunk(f, buffer));
        }
        
        puts("---");
    };
}

void printHelp(void){
    puts("usage:  WAVInfo [options] infile.wav\n");
    puts("\t\t\t-v or --version\n\t\t\t\tShow version.\n");
    puts("\t\t\t-h or --help\n\t\t\t\tShow this help.\n");
}

void printVersion(void){
    puts("\n    WAVInfo v1.0.0 - beta (04.09.09)\n");
    puts("Licence:");
    puts("    This work is licensed under a Creative Commons Attribution Noncommercial");
    puts("    Share Alike 3.0 Unported License.");
    puts("    (http://creativecommons.org/licenses/by-nc-sa/3.0/cz/)\n\n");
    puts("Supported chunks:");
    puts("    RIFF - Wave file header");
    puts("    fmt  - Format chunk");
    puts("    fact - Fact chunk");
    puts("    data - Data chunk");
    puts("    cue  - Cue chunk");
    puts("90% plst - Playlist chunk (implemented, but not tested yet)");
    puts("50% wavl - Wave list chunk (only ID & size, all others is skipped) (implemented, but not tested yet)");
    puts("90% inst - Instrument list chunk (implemented, but not tested yet)");
    puts("90% list - Associated Data List Chunk (includes labl, note and ltxt subchunks) (implemented, but not tested yet)");
    puts("90% smpl - Sampler Chunk (implemented, but not tested yet)");
    puts("\n");
    puts("                __.----_         \\`.,~/  Bystroushaak");
    puts("                \\ ;     \\,------'/_  _\\  (bystrousak [at]");
    puts("                 `--.__-;; ,____. '\\/    kitakitsune.org)");
    puts("                        ((/     \\/       289 836 101\n");
}

int main(int argc, char *argv[]){
    FILE *f;
    
    // overeni existence parametru 
    if (argc != 2){
        fprintf(stderr, "Error! Bad arguments!\n\n");
        printHelp();
        return 1;
    }
        
    // vypsani napovedy pokud je to potreba
    if ( !strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")){
        printHelp();
        return 0;   
    }

    // vypsani verze
    if ( !strcmp(argv[1], "-v") || !strcmp(argv[1], "--version")){
        printVersion();
        return 0;
    }
    
    //pokus o otevreni souboru
    if ((f = fopen(argv[1], "rb")) == NULL){
        fprintf(stderr, "Error! File \"%s\" not found!\n\n", argv[1]);
        printHelp();
        return 1;
    }
    
    // vypsani informaci (vsech hlavicek)
    printHeads(f);
    
    fclose(f);
    return 0;
}
/* WAVInfo.c v1.0.0 - beta (04.09.09) by Bystroushaak (bystrousak@kitakitsune.org)
 *
 * O programu;
 *      Vypise detailni informace o WAV souboru.
 *
 * Licence:
 *  This work is licensed under a Creative Commons Attribution Noncommercial
 *  Share Alike 3.0 Unported License.
 *  (http://creativecommons.org/licenses/by-nc-sa/3.0/cz/)
 *
 * Thx:
 *  http://www.sonicspot.com/guide/wavefiles.html
 *  http://ccrma.stanford.edu/courses/422/projects/WaveFormat/
 *  &
 *  independent, TheDarkAvenger, PiN, warriant, #freedom99@irc.c0renet.sk:6667
 *
 * TODO:
 *  Detekci formatu mozna provadet pomoci strcmp ignore case.
 * 
*/

#include <stdio.h>
#include <string.h>     // kvuli strcmp
#include <stdint.h>     // podpora jasne definovanych intu
#include <stdlib.h>     // kvuli malloc

#define KILOBYTE 1024
#define MEGABYTE 1048576
#define GIGABYTE 1073741824

char *convertB(int32_t bytes){
    static char buffer[30];

    if (bytes < KILOBYTE){
        sprintf(buffer, "%d B", bytes);
    }else if (bytes < MEGABYTE){
        sprintf(buffer, "%d B (%3.1f KB)", bytes, (double) bytes / KILOBYTE);
    }else if (bytes < GIGABYTE){
        sprintf(buffer, "%d B (%3.1f MB)", bytes, (double) bytes / MEGABYTE);
    }else{
        sprintf(buffer, "%d B (%6.1f GB)", bytes, (double) bytes / GIGABYTE);
    }

    return buffer;
}

//= RIFF chunk: ================================================================
typedef struct {
    char id[5];         // "RIFF"
    int32_t size;
    char format[5];     // "WAVE"
} riff_chunk;

riff_chunk *getRiffChunk(FILE *f, char *buffer){
    riff_chunk *chunk= (riff_chunk *) malloc(sizeof(riff_chunk));   // whoho, pro cloveka co nikdy neprogramoval v Ccku je tohle docela tezky vykoumat :)
    // na tom ze mam pouzit malloc jsem se snad na hodinu zasekl (^-^), ale chybama se clovek uci.. ;)

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;

    fread(&chunk->size, 4, 1, f);

    fread(chunk->format, 1, 4, f);
    chunk->format[4]= 0;

    return chunk;
}

void printRiffChunk(riff_chunk *chunk){
    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));
    printf("Chunk format:\t  %s\n", chunk->format);
}

//= fmt chunk: =================================================================
typedef struct {
    char id[5];         // "fmt "
    int32_t size;
    int16_t compression_code;   // viz ccode2Str();
    int16_t num_channels;   // pocet kanalu
    int32_t sample_rate;    // pocet vzorku za sekundu
    int32_t byte_rate;      // pocet bytu za sekundu
    int16_t block_align;    //
    int16_t bits_per_sample;    // urcuje kolika bitovy je jeden sample
    int16_t extra_param_size;   // pokud size == 18, tak urcuje velikost extra parametru
    char *extra_param;          // extra parametr (treba nejak popisek, nebo tak neco)
} fmt_chunk;

fmt_chunk *getFmtChunk(FILE *f, char *buffer){
    fmt_chunk *chunk= (fmt_chunk *) malloc(sizeof(fmt_chunk));

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;

    fread(&chunk->size, 4, 1, f);

    fread(&chunk->compression_code, 2, 1, f);
    fread(&chunk->num_channels, 2, 1, f);
    fread(&chunk->sample_rate, 4, 1, f);
    fread(&chunk->byte_rate, 4, 1, f);
    fread(&chunk->block_align, 4, 1, f);

    if (chunk->size == 18){
        fread(&chunk->extra_param_size, 2, 1, f);

        if (chunk->extra_param_size > 0){
            chunk->extra_param= (char *) malloc(sizeof(char) * (chunk->extra_param_size + 1));
            fread(chunk->extra_param, chunk->extra_param_size, 1, f);
            chunk->extra_param[chunk->extra_param_size]= 0;
        }else{
            chunk->extra_param= "";
        }
    }

    return chunk;
}

// Prevedeny compression code na cloveku srozumitelnejsi format.
char *ccode2Str(int32_t num){
    static char buffer[30];

    switch(num){
        case 0:
            return "Unknown";
        case 1:
            return "PCM/uncompressed";
        case 2:
            return "Microsoft ADPCM";
        case 6:
            return "ITU G.711 a-law";
        case 7:
            return "ITU G.711 -law";
        case 17:
            return "IMA ADPCM";
        case 20:
            return "ITU G.723 ADPCM (Yamaha)";
        case 49:
            return "GSM 6.10";
        case 64:
            return "ITU G.721 ADPCM";
        case 80:
            return "MPEG";
        case 65535:
            return "Experimental";
        default:
            sprintf(buffer, "Unknown (code %d)", num);
            return buffer;
    }
}

void printFmtChunk(fmt_chunk *chunk){
    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));

    printf("Compression code: %s\n", ccode2Str(chunk->compression_code));
    printf("Number of channs: ");
    switch (chunk->num_channels){
        case 0:
            puts("0 (Omg, it a lion get in the car!)");
            break;
        case 1:
            puts("1 (mono)");
            break;
        case 2:
            puts("2 (stereo)");
            break;
        case 4:
            puts("4 (quadro)");
            break;
        default:
            printf("%d\n", chunk->num_channels);
            break;
    }
    printf("Sample rate:\t  %d Hz (%3.1f kHz)\n", chunk->sample_rate, ((float) chunk->sample_rate) / 1000);
    printf("Byte rate:\t  %d B/s (%3.1f kB/s)\n", chunk->byte_rate, ((float) chunk->byte_rate) / 1024);
    printf("Block align:\t  %d B\b\n", chunk->block_align);
    printf("Bits per sample:  %d b\n", chunk->bits_per_sample);

    if (chunk->size == 18){
        printf("Extra param size: %d\n", chunk->extra_param_size);

        if (chunk->extra_param_size > 0){
            printf("Extra param:\t  %s\n", chunk->extra_param);
        }else{
            puts("Extra param:\t  not found");
        }
    }
}

//= fact chunk: ================================================================
typedef struct {
    char id[5];         // "fact"
    int32_t size;       // pokud je vetsi jak 4, jsou data ulozena v char *data, jinak v int32_t idata
    int32_t idata;
    char *data;         // zde se ulozi data - nenapadlo me kam jinam nez do pole charu
} fact_chunk;

fact_chunk *getFactChunk(FILE *f, char *buffer){
    fact_chunk *chunk= (fact_chunk *) malloc(sizeof(fact_chunk));

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;

    fread(&chunk->size, 4, 1, f);

    if (chunk->size == 4){
        fread(&chunk->idata, 4, 1, f);
    }else{
        chunk->data= (char *) malloc(sizeof(char) * (chunk->size + 1));
        fread(chunk->data, chunk->size, 1, f);
        chunk->data[chunk->size]= 0;
    }

    return chunk;
}

void printFactChunk(fact_chunk *chunk){
    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));
    if (chunk->size == 4){
        printf("Num of samples:\t  %d\n", chunk->idata);
    }else{
        puts("Num of samples:\t  too big number O.o");
    }
}

//= data chunk: ================================================================
typedef struct {
    char id[5];         // "data"
    int32_t size;
    long int pos;       // zaznamenana pozice (pomoci ftell())
} data_chunk;

data_chunk *getDataChunk(FILE *f, char *buffer){
    data_chunk *chunk= (data_chunk *) malloc(sizeof(data_chunk));
    int32_t i;
    char tmp;

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;

    fread(&chunk->size, 4, 1, f);
    chunk->pos= ftell(f);   // ulozeni aktualni pozice

    // preskoceni datove oblasti
    for (i= 0; i < chunk->size; i++){
        fread(&tmp, 1, 1, f); 
    }
    
    return chunk;
}

void printDataChunk(data_chunk *chunk){
    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));

    // prizpusobene vypsani kolik bylo preskoceno dat
    printf("[[ Follows ");
    if (chunk->size < KILOBYTE){
        printf("%d B", chunk->size);
    }else if (chunk->size < MEGABYTE){
        printf("%3.1f KB",(double) chunk->size / KILOBYTE);
    }else if (chunk->size < GIGABYTE){
        printf("%3.1f MB",(double) chunk->size / MEGABYTE);
    }else{
        printf("%6.1f GB",(double) chunk->size / GIGABYTE);
    }
    puts(" of WAV data ]]");
}

//= cue chunk: =================================================================    // prozatim nebylo otestovano, takze to klidne muze padat
typedef struct {
    int32_t id;         // cislo - zacina se od nuly
    int32_t position;
    char data_chunk_id[5];
    int32_t chunk_start;
    int32_t block_start;
    int32_t sample_offset;
}cue_point;

typedef struct {
   char id[5];         // "cue "
   int32_t size;
   int32_t num_cue_points;  // pocet cue pointu - sub chunku
   cue_point **array;
}cue_chunk;

cue_point *getCuePoint(FILE *f){
    cue_point *point= (cue_point *) malloc(sizeof(cue_point));

    fread(&point->id, 4, 1, f);
    fread(&point->position, 4, 1, f);

    fread(point->data_chunk_id, 4, 1, f);

    fread(&point->chunk_start, 4, 1, f);
    fread(&point->block_start, 4, 1, f);
    fread(&point->sample_offset, 4, 1, f);

    return point;
}

cue_chunk *getCueChunk(FILE *f, char *buffer){
    cue_chunk *chunk= (cue_chunk *) malloc(sizeof(cue_chunk));
    int i;

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;

    fread(&chunk->size, 4, 1, f);

    fread(&chunk->num_cue_points, 4, 1, f); // obsahuje pocet subchunku

    // pokud obsahuje subchunky (cue_point), tak vytvori pole ktere bude obsahovat ukazatele na ne
    if (chunk->num_cue_points > 0){
        chunk->array= malloc(sizeof(cue_point *) * chunk->num_cue_points);

        for (i= 0; i < chunk->num_cue_points; i++){
            chunk->array[i]= getCuePoint(f);
        }
    }

    return chunk;
}

void printCuePoint(cue_point *point){
    printf("\tPoint ID:\t  %d\n", point->id);
    printf("\tPoint position:\t  %d\n", point->position);
    printf("\tData chunk ID:\t  %s\n", point->data_chunk_id);
    printf("\tChunk start:\t  %d\n", point->chunk_start);
    printf("\tBlock start:\t  %d\n", point->block_start);
    printf("\tSample offset:\t  %d\n", point->sample_offset);
}

void printCueChunk(cue_chunk *chunk){
    int i;

    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));
    printf("Num chunk points: %d\n", chunk->num_cue_points);

    // pokud se zde nachazi nejake subchunky, tak je vypise
    if (chunk->num_cue_points > 0){
        puts("");
        for(i= 0; i < chunk->num_cue_points; i++){
            printCuePoint(chunk->array[i]);
            
            if (i < chunk->num_cue_points - 1){
                puts("");
            }
        }
    }
}

//= plst (playlist) chunk: =====================================================
typedef struct{
    int32_t cue_point_id;   // ID prislusneho cue_point
    int32_t length;         // length (v samplech)
    int32_t num_repeats;    // pocet opakovani
} plst_segment;

typedef struct {
    char id[5];     // "plst"
    int32_t size;
    int32_t number_of_segment;  // pocet plst_segment
    plst_segment **array;       // pole obsahujici pointery na plst_segment
} plst_chunk;

plst_segment *getPlstSegment(FILE *f){
    plst_segment *segment= (plst_segment *) malloc(sizeof(plst_segment));

    fread(&segment->cue_point_id, 4, 1, f);
    fread(&segment->length, 4, 1, f);
    fread(&segment->num_repeats, 4, 1, f);

    return segment;
}

plst_chunk *getPlstChunk(FILE *f, char *buffer){
    plst_chunk *chunk= (plst_chunk *) malloc(sizeof(plst_chunk));
    int i;

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;

    fread(&chunk->size, 4, 1, f);
    fread(&chunk->number_of_segment, 4, 1, f);

    // pokud je pritomen aspon jeden plst_segment, tak ho nacte
    if (chunk->number_of_segment > 0){
        chunk->array= malloc(sizeof(plst_segment *) * chunk->number_of_segment);

        for (i= 0; i < chunk->number_of_segment; i++){
            chunk->array[i]= getPlstSegment(f);
        }
    }

    return chunk;
}

void printPlstSegment(plst_segment *segment){
    printf("\tCue point id:\t  %d\n", segment->cue_point_id);
    printf("\tLengt:\t  %d samples\n", segment->length);
    printf("\tNum of repeats:\t  %d repeats\n", segment->num_repeats);
}

void printPlstChunk(plst_chunk *chunk){
    int i;

    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));
    printf("Num of segments:\t  %d segments\n", chunk->number_of_segment);

    // pokud je pritomen jeden nebo vice plst_segment, tak je vypise
    if (chunk->number_of_segment > 0){
        puts("--");
        for(i= 0; i < chunk->number_of_segment; i++){
            printPlstSegment(chunk->array[i]);

            if (i < chunk->number_of_segment - 1){
                puts("--");
            }
        }
    }
}
//= wavl (wave list) chunk: ====================================================
typedef struct {
    char id[5];     // "wavl"
    int32_t size;
    // zde by melo byt pole alternativnich chunku, ale nejspis je pekne na hovno je cist, takze jsou vynechany
} wavl_chunk;

wavl_chunk *getWavlChunk(FILE *f, char *buffer){
    wavl_chunk *chunk= (wavl_chunk *) malloc(sizeof(wavl_chunk));
    int32_t i;
    char tmp;

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;
    fread(&chunk->size, 4, 1, f);

    // jelikoz nasledujici blok by byl pro vypisovani moc dlouhy, rozhodl jsem se ho nenacitat
    for (i= 0; i < chunk->size; i++){
        fread(&tmp, 1, 1, f);
    }

    return chunk;
}

void printWavlChunk(wavl_chunk *chunk){
    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));
    puts("There should be list of alternate chunks, but autor of this program was too lazy to implement it, so there is nothing..");
    puts("More about this ugly chunk; http://www.sonicspot.com/guide/wavefiles.html#wavl");
}

//= inst (instrument) chunk: ===================================================
typedef struct {    // koho zajma popis, tak at si ho najde na http://www.sonicspot.com/guide/wavefiles.html#inst
    char id[5];     // "inst"
    int32_t size;
    char unshifted_note;
    char fine_tune;
    char gain;
    char low_note;
    char high_note;
    char low_velocity;
    char high_velocity;
} inst_chunk;

inst_chunk *getInstChunk(FILE *f, char *buffer){
    inst_chunk *chunk= (inst_chunk *) malloc(sizeof(inst_chunk));

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;
    fread(&chunk->size, 4, 1, f);

    fread(&chunk->unshifted_note, 1, 1, f);
    fread(&chunk->fine_tune, 1, 1, f);
    fread(&chunk->gain, 1, 1, f);
    fread(&chunk->low_note, 1, 1, f);
    fread(&chunk->high_note, 1, 1, f);
    fread(&chunk->low_velocity, 1, 1, f);
    fread(&chunk->high_velocity, 1, 1, f);

    return chunk;
}

void printInstChunk(inst_chunk *chunk){
    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));
    printf("Unshifted note:\t  %d\n", chunk->unshifted_note);
    printf("Fine tune:\t  %d dB\n", chunk->fine_tune);
    printf("Gain:\t  %d dB\n", chunk->gain);
    printf("Low note:\t  %d\n", chunk->low_note);
    printf("High note:\t  %d\n", chunk->high_note);
    printf("Low velocity:\t  %d\n", chunk->low_velocity);
    printf("High velocity:\t  %d\n", chunk->high_velocity);
}

//= unsupported chunk: ================================================================
typedef struct {
    char id[5];
    int32_t size;
} unsupported_chunk;

unsupported_chunk *getUnsupportedChunk(FILE *f, char *buffer){
    unsupported_chunk *chunk= (unsupported_chunk *) malloc(sizeof(unsupported_chunk));
    int32_t i;
    char tmp;

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;
    fread(&chunk->size, 4, 1, f);

    // nepodporovany chunk bude preskocen
    for (i= 0; i < chunk->size; i++){
        fread(&tmp, 1, 1, f);
    }

    return chunk;
}

void printUnsupportedChunk(unsupported_chunk *chunk){
    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));
    puts("This chunk isn't supported yet. No data available.");
}

//= list (Associated Data List) chunk: =========================================
typedef struct {
    char id[5];     // "labl"
    int32_t size;
    int32_t cue_point_id;
    char *text;
} labl_note_chunk;

typedef struct {
    char id[5];             // "ltxt"
    int32_t size;
    int32_t cue_point_id;
    int32_t sample_length;
    char purpose_id[5];     // urcuje k cemu je text urcen - napr. scrp znamena script
    int16_t country;        // jaj :/
    int16_t language;       // bohuzel se mi nepodarilo sehnat wav s ltxt chunkem, takze nemuzu rict jestli je to text nebo cislo
    int16_t dialect;
    int16_t code_page;
    char *text;             // obsahuje popisek - velikost bude nutno nejak vypocitat
} ltxt_chunk;

typedef struct {
    char id[5];             //  "labl" ||"note"
    int32_t size;
    char type_id[5];        // textovy popis
} list_chunk;

labl_note_chunk *getLablNoteChunk(FILE *f, char *buffer){
    labl_note_chunk *chunk= (labl_note_chunk *) malloc(sizeof(labl_note_chunk));

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;
    fread(&chunk->size, 4, 1, f);

    fread(&chunk->cue_point_id, 4, 1, f);

    chunk->text= (char *) malloc(sizeof(char) * (chunk->size + 1 - 4));
    fread(chunk->text, 1, chunk->size - 4, f);
    chunk->text[chunk->size - 20]= 0;

    return chunk;
}

ltxt_chunk *getLtxtChunk(FILE *f, char *buffer){
    ltxt_chunk *chunk= (ltxt_chunk *) malloc(sizeof(ltxt_chunk));

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;
    fread(&chunk->size, 4, 1, f);

    fread(&chunk->cue_point_id, 4, 1, f);
    fread(&chunk->sample_length, 4, 1, f);
    fread(&chunk->purpose_id, 1, 4, f);
    chunk->purpose_id[4]= 0;

    fread(&chunk->country, 2, 1, f);
    fread(&chunk->language, 2, 1, f);
    fread(&chunk->dialect, 2, 1, f);
    fread(&chunk->code_page, 2, 1, f);

    chunk->text= (char *) malloc(sizeof(char) * (chunk->size + 1 - 20));    // hlavicka ma 20B, ale jeden potrebuju na \0 (i kdyz \0 by mel byt v souboru, ale jistota je samopal)
    fread(chunk->text, 1, chunk->size - 20, f);
    chunk->text[chunk->size - 20]= 0;               // hmm.. (chunk->size - 20) by mel byt index kam dosadit \0 znak ne?

    return chunk;
}

list_chunk *getListChunk(FILE *f, char *buffer){
    list_chunk *chunk= (list_chunk *) malloc(sizeof(list_chunk));

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;
    fread(&chunk->size, 4, 1, f);

    fread(chunk->type_id, 1, 4, f);
    chunk->type_id[4]= 0;

    return chunk;
}

void printLtxtChunk(ltxt_chunk *chunk){
    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));

    printf("Cue point id:\t  %d\n", chunk->cue_point_id);
    printf("Sample length:\t  %d\n", chunk->sample_length);

    printf("Purpose id:\t  %s\n", chunk->purpose_id);

    // radsi to zobrazim jako cisla..
    printf("Country:\t  %d\n", chunk->country);
    printf("Language:\t  %d\n", chunk->language);
    printf("Dialect:\t  %d\n", chunk->dialect);
    printf("Codepage:\t  %d\n", chunk->code_page);

    printf("Text:\n%s\n", chunk->text);
}

void printLablNoteChunk(labl_note_chunk *chunk){
    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));
    printf("Cue point id:\t  %d\n", chunk->cue_point_id);
    printf("Text:\n%s\n", chunk->text);
}

void printListChunk(FILE *f, list_chunk *chunk){
    int32_t poz= ftell(f) + chunk->size - 4;
    char buffer[5];

    // vypise vsechny subchunky
    while(ftell(f) < poz){
        fread(buffer, 4, 1, f);
        buffer[4]= 0;

        if (strncmp(buffer, "ltxt", 4) == 0){
            printLtxtChunk(getLtxtChunk(f, buffer));
        }else if ((strncmp(buffer, "labl", 4) == 0) || (strncmp(buffer, "note", 4) == 0)){
            printLablNoteChunk(getLablNoteChunk(f, buffer));
        }else{
            printUnsupportedChunk(getUnsupportedChunk(f, buffer));
        }

        puts("--");
    }
}

//= smpl (sample) chunk: =======================================================
typedef struct{
    int32_t cue_point_id;
    int32_t type;
    int32_t start;
    int32_t end;
    int32_t fraction;
    int32_t play_count;
} smpl_loop;

typedef struct {            // http://www.sonicspot.com/guide/wavefiles.html#smpl
    char id[5];             // "smpl"
    int32_t size;
    int32_t manufacturer;   // preklad pomoci nejake fce
    int32_t product;
    int32_t sample_period;
    int32_t MIDI_unity_note;
    int32_t MIDI_pitch_fraction;
    int32_t SMPTE_format;
    int32_t SMPTE_offset;
    int32_t num_sample_loops;
    int32_t sampler_data;
    smpl_loop **array;
} smpl_chunk;

smpl_loop *getSmplLoop(FILE *f){
    smpl_loop *chunk= (smpl_loop *) malloc(sizeof(smpl_loop));

    fread(&chunk->cue_point_id, 4, 1,f);
    fread(&chunk->type, 4, 1,f);
    fread(&chunk->start, 4, 1,f);
    fread(&chunk->end, 4, 1,f);
    fread(&chunk->fraction, 4, 1,f);
    fread(&chunk->play_count, 4, 1,f);

    return chunk;
}

smpl_chunk *getSmplChunk(FILE *f, char *buffer){
    smpl_chunk *chunk= (smpl_chunk *) malloc(sizeof(smpl_chunk));
    int i;
    char tmp;

    strncpy(chunk->id, buffer, 4);
    chunk->id[4]= 0;
    fread(&chunk->size, 4, 1, f);

    fread(&chunk->manufacturer, 4, 1,f);
    fread(&chunk->product, 4, 1,f);
    fread(&chunk->sample_period, 4, 1,f);
    fread(&chunk->MIDI_unity_note, 4, 1,f);
    fread(&chunk->MIDI_pitch_fraction, 4, 1,f);
    fread(&chunk->SMPTE_format, 4, 1,f);
    fread(&chunk->SMPTE_offset, 4, 1,f);
    fread(&chunk->num_sample_loops, 4, 1,f);
    fread(&chunk->sampler_data, 4, 1,f);

    if (chunk->num_sample_loops > 0){
        chunk->array= malloc(sizeof(smpl_loop*) * chunk->num_sample_loops);
        for (i= 0; i < chunk->num_sample_loops; i++){
            chunk->array[0]= getSmplLoop(f);
        }
    }

    // pokud obsahuje nejaka specialni data, tak budou preskocena
    if (chunk->sampler_data > 0){
        for (i= 0; i < chunk->sampler_data; i++){
            fread(&tmp, 1, 1, f);
        }
    }

    return chunk;
}

char *getLoopType(int32_t type){
    static char buffer[50];

    switch(type){
        case 0:
            return "0 - Loop forward (normal)";
        case 1:
            return "1 - Alternating loop (forward/backward, also known as Ping Pong)";
        case 2:
            return "2 - Loop backward (reverse)";
    }

    if (type >= 3 && type <= 31){
        sprintf(buffer, "%d - Reserved for future standard types", type);
    }else{
        sprintf(buffer, "%d - Sampler specific types (defined by manufacturer)", type);
    }

    return buffer;
}

void printSmplLoop(smpl_loop *chunk){
    printf("\tCue point id:\t  %d\n", chunk->cue_point_id);
    printf("\tType:\t\t  %s\n", getLoopType(chunk->type));
    
    printf("\tStart:\t\t  %d (0x%8X)\n", chunk->start, chunk->start);
    printf("\tEnd:\t\t  %d (0x%8X)\n", chunk->end, chunk->end);

    printf("\tFraction:\t  %d (0x%8X)\n", chunk->fraction, chunk->fraction);

    puts("\tPlay count:\t  ");
    if (chunk->play_count == 0){
        puts("0 (infinite)");
    }else{
        printf("%d loops\n", chunk->play_count);
    }
}

// ok, ja vim ze tohle neni uplne nejoptimalnejsi reseni, ale na lepsi nemam naladu
// from http://www.midi.org/techspecs/manid.php (csv - http://openpaste.org/en/16583/)
char *getSmplManufacturer(int32_t manufacturer){
    switch(manufacturer){
        case 116: return "Ta Horng Musical Instrument ";
        case 117: return "e-Tek Labs (Forte Tech)";
        case 118: return "Electro-Voice";
        case 119: return "Midisoft Corporation";
        case 120: return "QSound Labs";
        case 121: return "Westrex";
        case 122: return "Nvidia";
        case 123: return "ESS Technology";
        case 124: return "Media Trix Peripherals";
        case 125: return "Brooktree Corp";
        case 126: return "Otari Corp";
        case 127: return "Key Electronics, Inc.";
        case 16384: return "Crimson Technology Inc.";
        case 16385: return "Softbank Mobile Corp";
        case 16387: return "D&M Holdings Inc.";
        case 256: return "Shure incorporated";
        case 257: return "AuraSound";
        case 258: return "Crystal Semiconductor";
        case 259: return "Conexant (Rockwell)";
        case 260: return "Silicon Graphics";
        case 261: return "M-Audio (Midiman)";
        case 262: return "PreSonus";
        case 264: return "Topaz Enterprises";
        case 265: return "Cast Lighting";
        case 266: return "Microsoft";
        case 267: return "Sonic Foundry";
        case 268: return "Line 6 (Fast Forward)";
        case 269: return "Beatnik Inc";
        case 270: return "Van Koevering Company";
        case 271: return "Altech Systems";
        case 272: return "S & S Research";
        case 273: return "VLSI Technology";
        case 274: return "Chromatic Research";
        case 275: return "Sapphire";
        case 276: return "IDRC";
        case 277: return "Justonic Tuning";
        case 278: return "TorComp Research Inc.";
        case 279: return "Newtek Inc.";
        case 280: return "Sound Sculpture";
        case 281: return "Walker Technical";
        case 282: return "Digital Harmony (PAVO)";
        case 283: return "InVision Interactive";
        case 284: return "T-Square Design";
        case 285: return "Nemesys Music Technology";
        case 286: return "DBX Professional (Harman Intl)";
        case 287: return "Syndyne Corporation";
        case 288: return "Bitheadz";
        case 289: return "Cakewalk Music Software";
        case 290: return "Analog Devices";
        case 291: return "National Semiconductor";
        case 292: return "Boom Theory / Adinolfi Alternative Percussion";
        case 293: return "Virtual DSP Corporation";
        case 294: return "Antares Systems";
        case 295: return "Angel Software";
        case 296: return "St Louis Music";
        case 297: return "Lyrrus dba G-VOX";
        case 298: return "Ashley Audio Inc.";
        case 299: return "Vari-Lite Inc.";
        case 300: return "Summit Audio Inc.";
        case 301: return "Aureal Semiconductor Inc.";
        case 302: return "SeaSound LLC";
        case 303: return "U.S. Robotics";
        case 304: return "Aurisis Research";
        case 305: return "Nearfield Research";
        case 306: return "FM7 Inc";
        case 307: return "Swivel Systems";
        case 308: return "Hyperactive Audio Systems";
        case 309: return "MidiLite (Castle Studios Productions)";
        case 310: return "Radikal Technologies";
        case 311: return "Roger Linn Design";
        case 312: return "TC-Helicon Vocal Technologies";
        case 313: return "Event Electronics";
        case 314: return "Sonic Network Inc";
        case 315: return "Realtime Music Solutions";
        case 316: return "Apogee Digital";
        case 317: return "Classical Organs, Inc.";
        case 318: return "Microtools Inc.";
        case 319: return "Numark Industries";
        case 320: return "Frontier Design Group, LLC";
        case 321: return "Recordare LLC";
        case 322: return "Starr Labs";
        case 323: return "Voyager Sound Inc.";
        case 324: return "Manifold Labs";
        case 325: return "Aviom Inc.";
        case 326: return "Mixmeister Technology";
        case 327: return "Notation Software";
        case 328: return "Mercurial Communications";
        case 329: return "Wave Arts";
        case 330: return "Logic Sequencing Devices";
        case 331: return "Axess Electronics";
        case 332: return "Muse Research";
        case 333: return "Open Labs";
        case 334: return "Guillemot R&D Inc";
        case 335: return "Samson Technologies";
        case 336: return "Electronic Theatre Controls";
        case 337: return "Research in Motion";
        case 338: return "Mobileer";
        case 339: return "Synthogy";
        case 340: return "Lynx Studio Technology Inc.";
        case 341: return "Damage Control Engineering LLC";
        case 342: return "Yost Engineering, Inc.";
        case 343: return "Brooks & Forsman Designs LLC";
        case 344: return "Infinite Response";
        case 345: return "Garritan Corp";
        case 346: return "Plogue Art et Technologie, Inc";
        case 347: return "RJM Music Technology";
        case 348: return "Custom Solutions Software";
        case 349: return "Sonarcana LLC";
        case 350: return "Centrance";
        case 351: return "Kesumo LLC";
        case 352: return "Stanton";
        case 353: return "Livid Instruments";
        case 354: return "First Act / 745 Media";
        case 355: return "Pygraphics, Inc.";
        case 356: return "Panadigm Innovations Ltd";
        case 357: return "Avedis Zildjian Co";
        case 64: return "Kawai Musical Instruments MFG. CO. Ltd";
        case 65: return "Roland Corporation";
        case 66: return "Korg Inc.";
        case 67: return "Yamaha Corporation";
        case 68: return "Casio Computer Co. Ltd";
        case 70: return "Kamiya Studio Co. Ltd";
        case 71: return "Akai Electric Co. Ltd.";
        case 72: return "Victor Company of Japan, Ltd.";
        case 75: return "Fujitsu Limited";
        case 76: return "Sony Corporation";
        case 78: return "Teac Corporation";
        case 80: return "Matsushita Electric Industrial Co. , Ltd";
        case 81: return "Fostex Corporation";
        case 8235: return "Medeli Electronics Co.";
        case 8236: return "Charlie Lab SRL";
        case 8237: return "Blue Chip Music Technology";
        case 8238: return "BEE OH Corp";
        case 8239: return "LG Semicon America";
        case 8240: return "TESI";
        case 8241: return "EMAGIC";
        case 8242: return "Behringer GmbH";
        case 8243: return "Access Music Electronics";
        case 8244: return "Synoptic";
        case 8245: return "Hanmesoft";
        case 8246: return "Terratec Electronic GmbH";
        case 8247: return "Proel SpA";
        case 8248: return "IBK MIDI";
        case 8249: return "IRCAM";
        case 8250: return "Propellerhead Software";
        case 8251: return "Red Sound Systems Ltd";
        case 8252: return "Elektron ESI AB";
        case 8253: return "Sintefex Audio";
        case 8254: return "MAM (Music and More)";
        case 8255: return "Amsaro GmbH";
        case 8256: return "CDS Advanced Technology BV";
        case 8257: return "Touched By Sound GmbH";
        case 8258: return "DSP Arts";
        case 8259: return "Phil Rees Music Tech";
        case 8260: return "Stamer Muiskanlagen GmbH";
        case 8261: return "Musical Muntaner S.A. dba Soundart";
        case 8262: return "C-Mexx Software";
        case 8263: return "Klavis Technologies";
        case 8264: return "Noteheads AB";
        case 8265: return "Algorithmix";
        case 8266: return "Skrydstrup R&D";
        case 8267: return "Professional Audio Company";
        case 8268: return "NewWave Labs (MadWaves)";
        case 8269: return "Vermona";
        case 8270: return "Nokia";
        case 8271: return "Wave Idea";
        case 8272: return "Hartmann GmbH";
        case 8273: return "Lion's Tracs";
        case 8274: return "Analogue Systems";
        case 8275: return "Focal-JMlab";
        case 8276: return "Ringway Electronics (Chang-Zhou) Co Ltd";
        case 8277: return "Faith Technologies (Digiplug)";
        case 8278: return "Showworks";
        case 8279: return "Manikin Electronic";
        case 8280: return "1 Come Tech";
        case 8281: return "Phonic Corp";
        case 8282: return "Dolby Australia (Lake)";
        case 8283: return "Silansys Technologies";
        case 8284: return "Winbond Electronics";
        case 8285: return "Cinetix Medien und Interface GmbH";
        case 8286: return "A&G Soluzioni Digitali";
        case 8287: return "Sequentix Music Systems";
        case 8288: return "Oram Pro Audio";
        case 8289: return "Be4 Ltd";
        case 8290: return "Infection Music";
        case 8291: return "Central Music Co. (CME)";
        case 8292: return "genoQs Machines GmbH";
        case 8293: return "Medialon";
        case 8294: return "Waves Audio Ltd";
        case 8295: return "Jerash Labs";
        case 8296: return "Da Fact";
        case 8297: return "Elby Designs";
        case 8298: return "Spectral Audio";
        case 8299: return "Arturia";
        case 82: return "Zoom Corporation";
        case 8300: return "Vixid";
        case 8301: return "C-Thru Music";
        case 8302: return "Ya Horng Electronic Co LTD";
        case 8303: return "SM Pro Audio";
        case 8304: return "OTO MACHINES";
        case 8305: return "ELZAB S.A., G LAB";
        case 8306: return "Blackstar Amplification Ltd";
        case 84: return "Matsushita Communication Industrial Co., Ltd.";
        case 85: return "Suzuki Musical Instruments MFG. Co., Ltd.";
        case 86: return "Fuji Sound Corporation Ltd.";
        case 87: return "Acoustic Technical Laboratory, Inc.";
        case 89: return "Faith, Inc.";
        case 90: return "Internet Corporation";
        case 92: return "Seekers Co. Ltd.";
        case 95: return "SD Card Association";
        default: return "Unknown";
    }
}

void printSmplChunk(smpl_chunk *chunk){
    int i;

    printf("Chunk ID:\t  %s\n", chunk->id);
    printf("Chunk size:\t  %s\n", convertB(chunk->size));

    printf("Manufacturer:\t  %d - %s\n", chunk->manufacturer, getSmplManufacturer(chunk->manufacturer));
    printf("Product:\t  %d\n", chunk->product);
    printf("Sample period:\t  %d\n", chunk->sample_period);
    printf("MIDI unity note:  %d\n", chunk->MIDI_unity_note);
    printf("MIDI pitch fract: %d\n", chunk->MIDI_pitch_fraction);
    printf("SMPTE format:\t  %d\n", chunk->SMPTE_format);
    printf("SMPTE offset:\t  %d (0x%8X)\n", chunk->SMPTE_offset, chunk->SMPTE_offset);
    printf("Num sample loops: %d\n", chunk->num_sample_loops);
    printf("Sampler data:\t  %s (skipped)\n", convertB(chunk->sampler_data));

    if (chunk->num_sample_loops > 0){
        puts("Loops:");
        for (i= 0; i < chunk->num_sample_loops; i++){
            printSmplLoop(chunk->array[i]);

            if (i < chunk->num_sample_loops - 1){
                puts("--");
            }
        }
    }
}

//==============================================================================

// postupne nacita jednotlive chunks a predava je fcim pro vypsani
void printHeads(FILE *f){
    char buffer[5];

    puts("= Chunks: ======================================================================");

    while(fread(buffer, 4, 1, f)){
        buffer[4]= 0;

        if (strncmp(buffer, "RIFF", 4) == 0){
            printRiffChunk(getRiffChunk(f, buffer));
        }else if (strncmp(buffer, "fmt ", 4) == 0){
            printFmtChunk(getFmtChunk(f, buffer));
        }else if (strncmp(buffer, "data", 4) == 0){
            printDataChunk(getDataChunk(f, buffer));
        }else if (strncmp(buffer, "fact", 4) == 0){
            printFactChunk(getFactChunk(f, buffer));
        }else if (strncmp(buffer, "cue ", 4) == 0){
            printCueChunk(getCueChunk(f, buffer));
        }else if (strncmp(buffer, "plst", 4) == 0){
            printPlstChunk(getPlstChunk(f, buffer));
        }else if (strncmp(buffer, "wavl", 4) == 0){
            printWavlChunk(getWavlChunk(f, buffer));
        }else if (strncmp(buffer, "inst", 4) == 0){
            printInstChunk(getInstChunk(f, buffer));
        }else if (strncmp(buffer, "list", 4) == 0){
            printListChunk(f, getListChunk(f, buffer)); // obsahuje ruzne subchunky a protoze se mi nechce vymyslet nejaky slozity zpusob jak je ukladat do list chunku, radsi je rovnou vypisuju
        }else if (strncmp(buffer, "smpl", 4) == 0){
            printSmplChunk(getSmplChunk(f, buffer));
        }else{
            printUnsupportedChunk(getUnsupportedChunk(f, buffer));
        }
        
        puts("---");
    };
}

void printHelp(void){
    puts("usage:  WAVInfo [options] infile.wav\n");
    puts("\t\t\t-v or --version\n\t\t\t\tShow version.\n");
    puts("\t\t\t-h or --help\n\t\t\t\tShow this help.\n");
}

void printVersion(void){
    puts("\n    WAVInfo v1.0.0 - beta (04.09.09)\n");
    puts("Licence:");
    puts("    This work is licensed under a Creative Commons Attribution Noncommercial");
    puts("    Share Alike 3.0 Unported License.");
    puts("    (http://creativecommons.org/licenses/by-nc-sa/3.0/cz/)\n\n");
    puts("Supported chunks:");
    puts("    RIFF - Wave file header");
    puts("    fmt  - Format chunk");
    puts("    fact - Fact chunk");
    puts("    data - Data chunk");
    puts("    cue  - Cue chunk");
    puts("90% plst - Playlist chunk (implemented, but not tested yet)");
    puts("50% wavl - Wave list chunk (only ID & size, all others is skipped) (implemented, but not tested yet)");
    puts("90% inst - Instrument list chunk (implemented, but not tested yet)");
    puts("90% list - Associated Data List Chunk (includes labl, note and ltxt subchunks) (implemented, but not tested yet)");
    puts("90% smpl - Sampler Chunk (implemented, but not tested yet)");
    puts("\n");
    puts("                __.----_         \\`.,~/  Bystroushaak");
    puts("                \\ ;     \\,------'/_  _\\  (bystrousak [at]");
    puts("                 `--.__-;; ,____. '\\/    kitakitsune.org)");
    puts("                        ((/     \\/       289 836 101\n");
}

int main(int argc, char *argv[]){
    FILE *f;
    
    // overeni existence parametru 
    if (argc != 2){
        fprintf(stderr, "Error! Bad arguments!\n\n");
        printHelp();
        return 1;
    }
        
    // vypsani napovedy pokud je to potreba
    if ( !strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")){
        printHelp();
        return 0;   
    }

    // vypsani verze
    if ( !strcmp(argv[1], "-v") || !strcmp(argv[1], "--version")){
        printVersion();
        return 0;
    }
    
    //pokus o otevreni souboru
    if ((f = fopen(argv[1], "rb")) == NULL){
        fprintf(stderr, "Error! File \"%s\" not found!\n\n", argv[1]);
        printHelp();
        return 1;
    }
    
    // vypsani informaci (vsech hlavicek)
    printHeads(f);
    
    fclose(f);
    return 0;
}#include <stdio.h>
#include <string.h>
#include "WAVheads.h"

int main(int argc, char *argv[]){
    FILE *f;
    
    // overeni existence parametru 
    if (argc != 2){
        fprintf(stderr, "Error! Bad arguments!\n\n");
        //printHelp();
        return 1;
    }
        
    // vypsani napovedy pokud je to potreba
    if ( !strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")){
        //printHelp();
        return 0;   
    }

    // vypsani verze
    if ( !strcmp(argv[1], "-v") || !strcmp(argv[1], "--version")){
        //printVersion();
        return 0;
    }
    
    //pokus o otevreni souboru
    if ((f = fopen(argv[1], "rb")) == NULL){
        fprintf(stderr, "Error! File \"%s\" not found!\n\n", argv[1]);
        printHelp();
        return 1;
    }
    
    // vypsani informaci (vsech hlavicek)
    readHeads(f);
    
    fclose(f);
    return 0;
}
#include <stdio.h>

int main(int argc, char *argv[]){

    system("wpa_supplicant -Dwired -ieth0 -c/etc/wpa_supplicant/wpa_supplicant.conf -d");
    
    return 0;
}

