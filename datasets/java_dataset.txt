package org.apidesign.demo.talk2compiler;

import com.oracle.truffle.api.CallTarget;
import com.oracle.truffle.api.Truffle;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.nodes.Node;
import com.oracle.truffle.api.nodes.RootNode;

public class Main extends RootNode {
    static final Main MAIN = new Main();
    static final CallTarget CODE = Truffle.getRuntime().createCallTarget(MAIN);

    @Child
    private Compute compute;

    private Main() {
        super(null);
    }

    public static void main(String... args) {
        String who = args.length > 0 ? args[0] : "unknown";
        System.err.println(CODE.call(who));
    }

    @Override
    public Object execute(VirtualFrame frame) {
        final int[] name = (int[]) frame.getArguments()[0];
        return compute.compute(name);
    }

    void setProgram(Compute program) {
        compute = insert(program);
    }

    public static abstract class Compute extends Node {
        public abstract int compute(int[] arr);
    }

    public static final class Plus extends Compute {
        @Child Compute left;
        @Child Compute right;

        public Plus(Compute left, Compute right) {
            this.left = left;
            this.right = right;
        }

        @Override
        public int compute(int[] arr) {
            int leftValue = left.compute(arr);
            int rightValue = right.compute(arr);
            return leftValue + rightValue;
        }
    }

    public static final class Arg extends Compute {
        private final int index;

        public Arg(int index) {
            this.index = index;
        }

        @Override
        public int compute(int[] arr) {
            return arr[index];
        }
    }
}
package org.apidesign.demo.talk2compiler;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class MainTest {
    @Before
    public void warmingUp() {
        Main.Plus program = new Main.Plus(
            new Main.Plus(new Main.Arg(0), new Main.Arg(1)),
            new Main.Arg(2)
        );
        Main.MAIN.setProgram(program);

        int count;
        if (Boolean.getBoolean("noigv")) {
            // Skip warmup if IGV dump isn't requested
            count = 1;
        } else {
            count = 10000000;
        }
        for (int i = 0; i < count; i++) {
            sayHelloTruffle();
        }
    }

    @Test
    public void checkSayHello() {
        Assert.assertEquals(7 + 8 + 2, sayHelloTruffle());
    }

    private static Object sayHelloTruffle() {
        final Object arr = new int[] { 7, 8, 2, 4 };
        return Main.CODE.call(arr);
    }
}
// CheckStyle: start generated
package org.apidesign.language.self;

import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;
import com.oracle.truffle.api.dsl.GeneratedBy;
import com.oracle.truffle.api.dsl.UnsupportedSpecializationException;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.nodes.Node;
import com.oracle.truffle.api.nodes.NodeCost;
import org.apidesign.language.self.SelfObjectForeign.UnboxSubNode;

@GeneratedBy(SelfObjectForeign.class)
final class SelfObjectForeignFactory {

    @GeneratedBy(UnboxSubNode.class)
    static final class UnboxSubNodeGen extends UnboxSubNode {

        @CompilationFinal private int state_;

        private UnboxSubNodeGen() {
        }

        @Override
        public Object executeWithTarget(VirtualFrame frameValue, Object arg0Value) {
            int state = state_;
            if (state != 0 /* is-active accessWithTarget(SelfObject) */ && arg0Value instanceof SelfObject) {
                SelfObject arg0Value_ = (SelfObject) arg0Value;
                return accessWithTarget(arg0Value_);
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(arg0Value);
        }

        private Object executeAndSpecialize(Object arg0Value) {
            int state = state_;
            if (arg0Value instanceof SelfObject) {
                SelfObject arg0Value_ = (SelfObject) arg0Value;
                this.state_ = state = state | 0b1 /* add-active accessWithTarget(SelfObject) */;
                return accessWithTarget(arg0Value_);
            }
            throw new UnsupportedSpecializationException(this, new Node[] {null}, arg0Value);
        }

        @Override
        public NodeCost getCost() {
            int state = state_;
            if (state == 0b0) {
                return NodeCost.UNINITIALIZED;
            } else {
                return NodeCost.MONOMORPHIC;
            }
        }

        public static UnboxSubNode create() {
            return new UnboxSubNodeGen();
        }

    }
}
package org.apidesign.language.self;

import com.oracle.truffle.api.CallTarget;
import com.oracle.truffle.api.Truffle;
import com.oracle.truffle.api.dsl.GeneratedBy;
import com.oracle.truffle.api.dsl.Specialization;
import com.oracle.truffle.api.dsl.UnsupportedSpecializationException;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.interop.ForeignAccess;
import com.oracle.truffle.api.interop.ForeignAccess.Factory;
import com.oracle.truffle.api.interop.ForeignAccess.StandardFactory;
import com.oracle.truffle.api.interop.Message;
import com.oracle.truffle.api.interop.TruffleObject;
import com.oracle.truffle.api.interop.UnsupportedTypeException;
import com.oracle.truffle.api.nodes.RootNode;

/**
 * This foreign access factory is generated by {@link org.apidesign.language.self.SelfObject}.
 * You are supposed to use it for the receiver object {@link org.apidesign.language.self.SelfObject}.
 */
@GeneratedBy(org.apidesign.language.self.SelfObject.class)
final class SelfObjectForeign implements StandardFactory, Factory {
    public static final ForeignAccess ACCESS = ForeignAccess.createAccess(new SelfObjectForeign(), null);
    @Deprecated public static ForeignAccess createAccess() { return ForeignAccess.createAccess(new SelfObjectForeign(), null); }

    private SelfObjectForeign() { }

    @Override
    public boolean canHandle(TruffleObject obj) {
        return org.apidesign.language.self.SelfObject.isInstance(obj);
    }

    @Override
    public CallTarget accessIsNull() {
      return Truffle.getRuntime().createCallTarget(RootNode.createConstantNode(false));
    }
    @Override
    public CallTarget accessIsExecutable() {
      return Truffle.getRuntime().createCallTarget(RootNode.createConstantNode(false));
    }
    @Override
    public CallTarget accessIsInstantiable() {
      return Truffle.getRuntime().createCallTarget(RootNode.createConstantNode(false));
    }
    @Override
    public CallTarget accessIsBoxed() {
      return Truffle.getRuntime().createCallTarget(RootNode.createConstantNode(true));
    }
    @Override
    public CallTarget accessHasKeys() {
      return Truffle.getRuntime().createCallTarget(RootNode.createConstantNode(false));
    }
    @Override
    public CallTarget accessHasSize() {
      return Truffle.getRuntime().createCallTarget(RootNode.createConstantNode(false));
    }
    @Override
    public CallTarget accessGetSize() {
      return null;
    }
    @Override
    public CallTarget accessUnbox() {
      return com.oracle.truffle.api.Truffle.getRuntime().createCallTarget(UnboxSubNode.createRoot());
    }
    @Override
    public CallTarget accessRead() {
      return null;
    }
    @Override
    public CallTarget accessWrite() {
      return null;
    }
    @Override
    public CallTarget accessRemove() {
      return null;
    }
    @Override
    public CallTarget accessExecute(int argumentsLength) {
      return null;
    }
    @Override
    public CallTarget accessInvoke(int argumentsLength) {
      return null;
    }
    @Override
    public CallTarget accessNew(int argumentsLength) {
      return null;
    }
    @Override
    public CallTarget accessKeyInfo() {
      return null;
    }
    @Override
    public CallTarget accessKeys() {
      return null;
    }
    @Override
    public CallTarget accessIsPointer() {
      return Truffle.getRuntime().createCallTarget(RootNode.createConstantNode(false));
    }
    @Override
    public CallTarget accessAsPointer() {
      return null;
    }
    @Override
    public CallTarget accessToNative() {
      return null;
    }
    @Override
    public CallTarget accessMessage(Message unknown) {
      return null;
    }

    /**
     * This message resolution is generated by {@link org.apidesign.language.self.SelfObject.Unbox}.
     */
    abstract static class UnboxSubNode extends org.apidesign.language.self.SelfObject.Unbox {
        public abstract Object executeWithTarget(VirtualFrame frame, Object o0);
        @Specialization
        protected Object accessWithTarget(org.apidesign.language.self.SelfObject obj) {
            return access(obj);
        }
        private static final class UNBOXRootNode extends RootNode {
            protected UNBOXRootNode() {
                super(null);
            }

            @Child private UnboxSubNode node = org.apidesign.language.self.SelfObjectForeignFactory.UnboxSubNodeGen.create();
            @Override
            public String getName() {
                return "Interop::UNBOX::" + org.apidesign.language.self.SelfObject.class.getName();
            }

            @Override
            public Object execute(VirtualFrame frame) {
                Object receiver = ForeignAccess.getReceiver(frame);
                try {
                    return node.executeWithTarget(frame, receiver);
                } catch (UnsupportedSpecializationException e) {
                    if (e.getNode() instanceof UnboxSubNode) {
                      throw UnsupportedTypeException.raise(e, e.getSuppliedValues());
                    } else {
                      throw e;
                    }
                }
            }

        }
        public static RootNode createRoot() {
            return new UNBOXRootNode();
        }
    }
}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import com.oracle.truffle.api.profiles.ConditionProfile;
import com.oracle.truffle.api.source.Source;
import static org.apidesign.language.self.PEParser.*;
import org.apidesign.language.self.SelfLexer.ListItem;
import org.netbeans.api.lexer.Token;
import org.netbeans.api.lexer.TokenHierarchy;
import org.netbeans.api.lexer.TokenId;
import org.netbeans.api.lexer.TokenSequence;

final class SelfParser {
    private static final PEParser PARSER;
    static {
        PARSER = new PEParser();
        // create the rules
        Rule<SelfObject> statement = PARSER.rule("statement");
        Rule<SelfObject> objectLiteral = PARSER.rule("object");
        Rule<SelfCode> exprlist = PARSER.rule("exprlist");
        Rule<SelfObject> constant = PARSER.rule("constant");
        Rule<SelfCode> unaryLevel = PARSER.rule("unaryLevel");
        Rule<SelfCode> binaryLevel = PARSER.rule("binaryLevel");
        Rule<SelfCode> keywordLevel = PARSER.rule("keywordLevel");
        Rule<SelfCode> expression = PARSER.rule("expression");

        Element<ListItem<IdArg>> slotId = alt(
                ref(SelfTokenId.IDENTIFIER, (t) -> {
                    return new ListItem<>(null, new IdArg(t, null));
                }),
                seq(ref(SelfTokenId.KEYWORD_LOWERCASE), opt(alt(
                        seq(
                            ref(SelfTokenId.IDENTIFIER), rep(
                                seq(ref(SelfTokenId.KEYWORD), ref(SelfTokenId.IDENTIFIER), (key, arg) -> {
                                    return new IdArg(key, arg);
                                }),
                                ListItem::<IdArg>empty, ListItem::new, ListItem::self
                            ), (id, rest) -> {
                            return new ListItem<>(rest, new IdArg(null, id));
                        }),
                        seq(
                            ref(SelfTokenId.KEYWORD),rep(
                                ref(SelfTokenId.KEYWORD, (key) -> {
                                    return new IdArg(key, null);
                                }),
                                ListItem::<IdArg>empty, ListItem::new, ListItem::self
                            ), (secondKeyword, moreKeywords) -> {
                                return ListItem.firstAndNewer(new IdArg(secondKeyword, null), moreKeywords);
                            }
                        )
                )), (key, alt) -> {
                    if (alt.isPresent()) {
                        ListItem<IdArg> rest = alt.get();
                        if (rest.item.id == null) {
                            return ListItem.firstAndNewer(new IdArg(key, rest.item.arg), rest.prev);
                        } else {
                            return ListItem.firstAndNewer(new IdArg(key, null), rest);
                        }
                    } else {
                        return new ListItem<>(null, new IdArg(key, null));
                    }
                }),
                seq(ref(SelfTokenId.OPERATOR), opt(ref(SelfTokenId.IDENTIFIER)), (op, id) -> {
                    return new ListItem<>(null, new IdArg(op, null));
                })
        );

        Element<SlotInfo> slot = alt(
                seq(
                    slotId, alt(ref(SelfTokenId.EQUAL), ref(SelfTokenId.ARROW)), alt(constant, ref(SelfTokenId.IDENTIFIER), statement),
                    (idsAndArgs, b, c) -> {
                        boolean mutable = b.id() != SelfTokenId.EQUAL;
                        SelfSelector messageSelector = IdArg.toSelector(idsAndArgs);
                        IdArg a = idsAndArgs.item;
                        if (a.arg != null && c instanceof SelfObject) {
                            ListItem<IdArg> at = idsAndArgs;
                            while (at != null) {
                                final String argName = ":" + at.item.arg.text();
                                c = SelfObject.newBuilder((SelfObject) c).argument(argName).build();
                                at = at.prev;
                            }
                        }
                        return new SlotInfo(messageSelector.toString(), mutable, false, c);
                    }
                ),
                ref(SelfTokenId.ARGUMENT, (t) -> SlotInfo.argument(t.text()))
        );

        final Element<SlotInfo> dotAndSlot = seq(ref(SelfTokenId.DOT), slot, ListItem::second);
        Element<ListItem<SlotInfo>> extraSlots = rep(dotAndSlot, ListItem::<SlotInfo>empty, ListItem::new, ListItem::self);

        Element<ListItem<SlotInfo>> slotsDef = alt(
            ref(SelfTokenId.BAR, ListItem::<SlotInfo>empty),
            seq(slot, extraSlots, ref(SelfTokenId.BAR), (t, m, u) -> {
                return new ListItem<>(m, t);
            })
        );

        Element<SelfObject> objectStatement = seq(
                ref(SelfTokenId.LPAREN), alt(
                    seq(ref(SelfTokenId.BAR), slotsDef, opt(exprlist), ref(SelfTokenId.RPAREN), (bar, slts, expr, rparen) -> {
                        SelfObject.Builder builder = SelfObject.newBuilder();
                        while (slts != null) {
                            if (slts.item.argument) {
                                builder.argument(slts.item.id.toString());
                            } else {
                                builder.slot(slts.item.id.toString(), slts.item.value);
                            }
                            slts = slts.prev;
                        }
                        if (expr.isPresent()) {
                            builder.code(expr.get());
                        }
                        return builder;
                    }),
                    seq(exprlist, ref(SelfTokenId.RPAREN), (expr, rparen) -> {
                        return SelfObject.newBuilder().code(expr);
                    }),
                    ref(SelfTokenId.RPAREN, (rparen) -> SelfObject.newBuilder())
                ),
                (t, u) -> {
                    return u.build();
                }
        );
        objectLiteral.define(objectStatement);



        statement.define(alt(constant));

        final Element<SelfObject> constantDef = alt(
            ref(SelfTokenId.BOOLEAN, (t) -> {
                return SelfObject.valueOf(Boolean.valueOf(t.text().toString()));
            }),
            ref(SelfTokenId.STRING, (t) -> {
                return SelfObject.valueOf(t.text().toString());
            }),
            ref(SelfTokenId.NUMBER, (t) -> {
                return SelfObject.valueOf(Integer.valueOf(t.text().toString()));
            }),
            objectLiteral
        );
        constant.define(constantDef);

        Element<Object> unaryExprHead = alt(constant, ref(SelfTokenId.IDENTIFIER));
        Element<ListItem<Token<SelfTokenId>>> unaryExprTail = rep(
            ref(SelfTokenId.IDENTIFIER),
            ListItem::<Token<SelfTokenId>>empty, ListItem::new, ListItem::self
        );
        unaryLevel.define(seq(unaryExprHead, unaryExprTail, (t, u) -> {
            SelfCode[] receiver = { null };
            if (t instanceof SelfObject) {
                // constant
                receiver[0] = SelfCode.constant((SelfObject) t);
            } else {
                final SelfSelector selector = SelfSelector.keyword(((Token<?>)t).text().toString());
                // identifier - default receiver is self
                receiver[0] = SelfCode.unaryMessage(SelfCode.self(), selector);
            }
            ListItem.firstToLast(u, (item) -> {
                final SelfSelector msg = SelfSelector.keyword(u.item.text().toString());
                receiver[0] = SelfCode.unaryMessage(receiver[0], msg);
            });
            return receiver[0];
        }));

        Element<SelfCode> binaryExpr = alt(
            seq(ref(SelfTokenId.OPERATOR), unaryLevel, (t, u) -> {
                return null;
            }),
            seq(unaryLevel, rep(
                seq(ref(SelfTokenId.OPERATOR), unaryLevel, (operator, argument) -> {
                    return new Object[] { operator, argument };
                }), ListItem::<Object[]>empty, ListItem::new, ListItem::self
            ), (unary, operatorAndArgument) -> {
                if (operatorAndArgument == null) {
                    return unary;
                } else {
                    SelfCode[] tree = { unary };
                    String[] previousText = { null };
                    ListItem.firstToLast(operatorAndArgument, (opArg) -> {
                        String operator = ((Token<?>) opArg[0]).text().toString();
                        if (previousText[0] != null && !previousText[0].equals(operator)) {
                            throw new IllegalStateException("no precedence for binary operator - please use parentheses for " + previousText[0] + " and " + operator);
                        }
                        previousText[0] = operator;
                        SelfCode arg = (SelfCode) opArg[1];
                        final SelfSelector msg = SelfSelector.keyword(operator);
                        tree[0] = SelfCode.binaryMessage(tree[0], msg, arg);
                    });
                    return tree[0];
                }
            })
        );
        binaryLevel.define(binaryExpr);

        Element<ListItem<SelectorArg>> keywordSeq = seq(ref(SelfTokenId.KEYWORD_LOWERCASE), expression, rep(
            seq(ref(SelfTokenId.KEYWORD), expression, (selectorPart, arg) -> {
                return new SelectorArg(selectorPart.text().toString(), arg);
            }),
            ListItem::<SelectorArg>empty, ListItem::new, ListItem::self
        ), (selectorPart, arg, subsequent) -> {
            return ListItem.firstAndNewer(new SelectorArg(selectorPart.text().toString(), arg), subsequent);
        });
        keywordLevel.define(seq(keywordSeq, (selectorAndArgList) -> {
            return SelectorArg.createKeywordInvocation(selectorAndArgList, SelfCode.self());
        }));
        expression.define(alt(keywordLevel, seq(
            binaryLevel, opt(keywordSeq), (t, u) -> {
                if (u.isPresent()) {
                    return SelectorArg.createKeywordInvocation(u.get(), t);
                } else {
                    return t;
                }
            }
        )));
        exprlist.define(seq(expression, rep(seq(ref(SelfTokenId.DOT), expression, ListItem::second),
            ListItem::<SelfCode>empty, ListItem::new, ListItem::self), (head, tail) -> {
            ListItem<SelfCode> whole = new ListItem<>(tail, head);
            SelfCode[] arr = ListItem.toArray(whole, SelfCode[]::new);
            return SelfCode.block(arr);
        }));
        PARSER.initialize(exprlist);
    }

    private static class IdArg {
        final Token<SelfTokenId> id;
        final Token<SelfTokenId> arg;

        IdArg(Token<SelfTokenId> id, Token<SelfTokenId> arg) {
            this.id = id;
            this.arg = arg;
        }

        static SelfSelector toSelector(ListItem<IdArg> args) {
            int size = ListItem.size(args);
            String[] keywords = new String[size];
            for (int i = size; i > 0;) {
                keywords[--i] = args.item.id.text().toString();
                args = args.prev;
            }
            return SelfSelector.keyword(keywords);
        }
    }

    private static class SelectorArg {
        final String selector;
        final SelfCode arg;

        SelectorArg(String selector, SelfCode arg) {
            this.selector = selector;
            this.arg = arg;
        }

        static SelfCode createKeywordInvocation(ListItem<SelectorArg> selectorAndArgList, final SelfCode self) {
            int size = ListItem.size(selectorAndArgList);
            String[] selectorParts = new String[size];
            SelfCode[] args = new SelfCode[size];
            ListItem<SelectorArg> head = selectorAndArgList;
            for (int i = size; i > 0;) {
                --i;
                selectorParts[i] = head.item.selector;
                args[i] = head.item.arg;
                head = head.prev;
            }
            SelfSelector selector = SelfSelector.keyword(selectorParts);
            return SelfCode.keywordMessage(self, selector, args);
        }
    }


    public static SelfCode parse(Source s) {
        TokenSequence<SelfTokenId> seq = TokenHierarchy.create(s.getCharacters(), SelfTokenId.language()).tokenSequence(SelfTokenId.language());
        class SeqLexer implements PELexer {
            private final Object[] self = new Object[] { this };
            private boolean eof;
            {
                nextTokenMove(null);
            }

            @Override
            public Object[] asArgumentsArray() {
                return self;
            }

            @Override
            public Token<SelfTokenId> peek(ConditionProfile seenEof) {
                if (eof) {
                    return null;
                }
                return seq.token();
            }

            @Override
            public String position() {
                return "at: " + seq.offset() + ": " + seq.subSequence(seq.offset()).toString();
            }

            @Override
            public void resetStackPointer(int pointer) {
                seq.move(pointer);
                seq.moveNext();
            }

            @Override
            public Token<SelfTokenId> nextToken(ConditionProfile seenEof) {
                Token<SelfTokenId> token = peek(seenEof);
                nextTokenMove(seenEof);
                return token;
            }

            private void nextTokenMove(ConditionProfile seenEof) {
                while (seq.moveNext()) {
                    final Token<SelfTokenId> lookahead = seq.token();
                    if (lookahead.id() != SelfTokenId.WHITESPACE) {
                        return;
                    }
                }
                eof = true;
                if (seenEof != null) {
                    seenEof.profile(true);
                }
            }

            @Override
            public int getStackPointer() {
                return seq.offset();
            }

            @Override
            public String tokenNames(TokenId id) {
                return "token " + id;
            }

            @Override
            public String toString() {
                return position();
            }
        }
        final PELexer lexer = new SeqLexer();
        SelfCode code = (SelfCode) PARSER.parse(lexer);
        assert lexer.peek(null) == null : "Fully parsed: " + seq;
        return code;
    }

    private static final class SlotInfo {
        private static SlotInfo argument(CharSequence text) {
            return new SlotInfo(text, false, true, null);
        }

        private final CharSequence id;
        private final boolean mutable;
        private final Object value;
        private final boolean argument;

        public SlotInfo(CharSequence id, boolean mutable, boolean argument, Object value) {
            this.id = id;
            this.mutable = mutable;
            this.argument = argument;
            this.value = value;
        }

        private Object valueToString() {
            if (value instanceof Token) {
                return ((Token)value).text().toString();
            }
            return value.toString();
        }
    }
}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import com.oracle.truffle.api.CallTarget;
import com.oracle.truffle.api.Truffle;
import com.oracle.truffle.api.TruffleLanguage;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.nodes.RootNode;

@TruffleLanguage.Registration(name = "Self", id = "Self", characterMimeTypes = SelfTokenId.MIMETYPE)
public class SelfLanguage extends TruffleLanguage<SelfData> {

    @Override
    protected SelfData createContext(Env env) {
        return new SelfData(env);
    }

    @Override
    protected CallTarget parse(ParsingRequest request) throws Exception {
        SelfCode node = SelfParser.parse(request.getSource());
        SelfSource root = new SelfSource(this, node);
        return Truffle.getRuntime().createCallTarget(root);
    }

    @Override
    protected boolean isObjectOfLanguage(Object object) {
        return object instanceof SelfObject;
    }
}

final class SelfSource extends RootNode {
    private final SelfCode node;

    SelfSource(TruffleLanguage<?> language, SelfCode node) {
        super(language);
        this.node = node;
    }

    @Override
    public Object execute(VirtualFrame frame) {
        final Object[] args = frame.getArguments();
        SelfObject self = (SelfObject) (args.length == 0 ? null : args[0]);
        return node.sendMessage(self);
    }

}

final class SelfData {
    final TruffleLanguage.Env env;

    SelfData(TruffleLanguage.Env env) {
        this.env = env;
    }
}
/*
 * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;

import com.oracle.truffle.api.CallTarget;
import com.oracle.truffle.api.CompilerAsserts;
import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;
import com.oracle.truffle.api.Truffle;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.nodes.DirectCallNode;
import com.oracle.truffle.api.nodes.ExplodeLoop;
import com.oracle.truffle.api.nodes.ExplodeLoop.LoopExplosionKind;
import com.oracle.truffle.api.nodes.Node;
import com.oracle.truffle.api.nodes.RootNode;
import com.oracle.truffle.api.profiles.ConditionProfile;
import static org.apidesign.language.self.Alternative.error;
import org.netbeans.api.lexer.Token;
import org.netbeans.api.lexer.TokenId;

abstract class Element<T> extends Node {

    @CompilationFinal protected long firstA;
    @CompilationFinal protected long firstB;
    @CompilationFinal protected int singleToken = -1;

    protected abstract void createFirstSet(Element<?> setHolder, HashSet<Rule<?>> rulesAdded);

    public abstract void initialize();

    public abstract T consume(PELexer lexer);

    public final boolean canStartWith(Token<? extends TokenId> token) {
        if (token == null) {
            // eof
            return false;
        }
        int id = token.id().ordinal();
        if (singleToken == -1L) {
            CompilerDirectives.transferToInterpreterAndInvalidate();
            if (Long.bitCount(firstA) + Long.bitCount(firstB) == 1) {
                // if the "first" set consists of a single token, it can be checked more efficiently
                if (firstA == 0) {
                    singleToken = Long.numberOfTrailingZeros(firstB) + 64;
                } else {
                    singleToken = Long.numberOfTrailingZeros(firstA);
                }
            } else {
                singleToken = 0;
            }
        }
        if (singleToken != 0) {
            return id == singleToken;
        }

        if (id < 64) {
            assert id > 0;
            return (firstA & (1L << id)) != 0;
        } else {
            assert id < 128;
            return (firstB & (1L << (id - 64))) != 0;
        }
    }
}

class RuleRootNode extends RootNode {

    @Child private Rule<?> rule;

    RuleRootNode(Rule<?> rule) {
        super(null);
        this.rule = rule;
    }

    @Override
    public Object execute(VirtualFrame frame) {
        PELexer lexer = (PELexer) frame.getArguments()[0];
        return rule.element.consume(lexer);
    }

    @Override
    public String getName() {
        return "parser rule " + rule.getName();
    }

    @Override
    public String toString() {
        return getName();
    }
}

final class CallRule<T> extends Element<T> {

    private final Rule<T> rule;
    @Child DirectCallNode call;

    CallRule(Rule<T> rule) {
        this.rule = rule;
    }

    @Override
    protected void createFirstSet(Element<?> setHolder, HashSet<Rule<?>> rulesAdded) {
        rule.element.createFirstSet(setHolder, rulesAdded);
    }

    @Override
    public void initialize() {
        rule.initialize();
    }

    @SuppressWarnings("unchecked")
    @Override
    public T consume(PELexer lexer) {
        if (call == null) {
            CompilerDirectives.transferToInterpreterAndInvalidate();
            call = insert(Truffle.getRuntime().createDirectCallNode(rule.getCallTarget()));
        }
        if (PEParser.PEPARSER_DIRECT_CALL) {
            return rule.element.consume(lexer);
        } else {
            return (T) call.call(lexer.asArgumentsArray()); // do not create a new array every time
        }
    }

    @Override
    public String toString() {
        return "CallRule[" + rule.getName() + "]";
    }
}

final class Rule<T> extends Element<T> {

    private final String name;
    @Child Element<? extends T> element;
    CallTarget target;

    Rule(String name) {
        this.name = name;
    }

    public CallTarget getCallTarget() {
        if (target == null) {
            target = Truffle.getRuntime().createCallTarget(new RuleRootNode(this));
        }
        return target;
    }

    public void define(Element<? extends T> newElement) {
        this.element = newElement;
    }

    @Override
    protected void createFirstSet(Element<?> setHolder, HashSet<Rule<?>> rulesAdded) {
        if (!rulesAdded.contains(this)) {
            rulesAdded.add(this);
            if (firstA != 0 || firstB != 0) {
                setHolder.firstA |= firstA;
                setHolder.firstB |= firstB;
            } else {
                if (element != null) {
                    element.createFirstSet(setHolder, rulesAdded);
                }
            }
        }
    }

    void initializeRule() {
        CompilerAsserts.neverPartOfCompilation();
        createFirstSet(this, new HashSet<>());
    }

    @Override
    public void initialize() {
        // do nothing - already initialized
    }

    public String getName() {
        return name;
    }

    static int level = 0;

    @Override
    public T consume(PELexer lexer) {
        throw new IllegalStateException(getRootNode().getName());
    }
}

abstract class SequenceBase<T> extends Element<T> {

    protected abstract Element<?>[] elements();

    @Override
    protected void createFirstSet(Element<?> setHolder, HashSet<Rule<?>> rulesAdded) {
        int i = 0;
        Element<?>[] elements = elements();
        while (i < elements.length && elements[i] instanceof OptionalElement<?, ?>) {
            // add all optional prefixes
            ((OptionalElement<?, ?>) elements[i]).element.createFirstSet(setHolder, rulesAdded);
            i++;
        }
        assert i < elements.length : "non-optional element needed in sequence";
        // add the first non-optional element
        elements[i].createFirstSet(setHolder, rulesAdded);
    }

    @Override
    public void initialize() {
        for (Element<?> element : elements()) {
            element.initialize();
        }
    }
}

final class Sequence1<T, A> extends SequenceBase<T> {
    @Child private Element<A> a;
    private final Function<? super A, T> action;

    Sequence1(Function<? super A, T> action, Element<A> a) {
        this.action = action;
        this.a = a;
    }

    @Override
    protected Element<?>[] elements() {
        return new Element<?>[]{a};
    }

    @Override
    public T consume(PELexer lexer) {
        final A valueA = a.consume(lexer);
        return action.apply(valueA);
    }
}

final class Sequence2<T, A, B> extends SequenceBase<T> {
    @Child private Element<A> a;
    @Child private Element<B> b;
    private final BiFunction<? super A, ? super B, T> action;

    Sequence2(BiFunction<? super A, ? super B, T> action, Element<A> a, Element<B> b) {
        this.action = action;
        this.a = a;
        this.b = b;
    }

    @Override
    protected Element<?>[] elements() {
        return new Element<?>[]{a, b};
    }

    @Override
    public T consume(PELexer lexer) {
        final A valueA = a.consume(lexer);
        final B valueB = b.consume(lexer);
        return action.apply(valueA, valueB);
    }
}

final class Sequence3<T, A, B, C> extends SequenceBase<T> {
    @Child private Element<A> a;
    @Child private Element<B> b;
    @Child private Element<C> c;
    private final PEParser.Function3<? super A, ? super B, ? super C, T> action;

    Sequence3(PEParser.Function3<? super A, ? super B, ? super C, T> action, Element<A> a, Element<B> b, Element<C> c) {
        this.action = action;
        this.a = a;
        this.b = b;
        this.c = c;
    }

    @Override
    protected Element<?>[] elements() {
        return new Element<?>[]{a, b, c};
    }

    @Override
    public T consume(PELexer lexer) {
        final A valueA = a.consume(lexer);
        final B valueB = b.consume(lexer);
        final C valueC = c.consume(lexer);
        return action.apply(valueA, valueB, valueC);
    }
}

final class Sequence4<T, A, B, C, D> extends SequenceBase<T> {
    @Child private Element<A> a;
    @Child private Element<B> b;
    @Child private Element<C> c;
    @Child private Element<D> d;
    private final PEParser.Function4<? super A, ? super B, ? super C, ? super D, T> action;

    Sequence4(PEParser.Function4<? super A, ? super B, ? super C, ? super D, T> action, Element<A> a, Element<B> b, Element<C> c, Element<D> d) {
        this.action = action;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    @Override
    protected Element<?>[] elements() {
        return new Element<?>[]{a, b, c};
    }

    @Override
    public T consume(PELexer lexer) {
        final A valueA = a.consume(lexer);
        final B valueB = b.consume(lexer);
        final C valueC = c.consume(lexer);
        final D valueD = d.consume(lexer);
        return action.apply(valueA, valueB, valueC, valueD);
    }
}

final class Alternative<T> extends Element<T> {
    @Children private final Element<? extends T>[] options;
    private final ConditionProfile seenEof = ConditionProfile.createBinaryProfile();

    Alternative(Element<? extends T>[] options) {
        this.options = options;
    }

    @Override
    protected void createFirstSet(Element<?> setHolder, HashSet<Rule<?>> rulesAdded) {
        assert options.length > 0;

        for (Element<?> option : options) {
            option.createFirstSet(setHolder, rulesAdded);
        }
    }

    @Override
    public void initialize() {
        for (Element<?> element : options) {
            element.createFirstSet(element, new HashSet<>());
            element.initialize();
        }
    }

    @Override
    @ExplodeLoop(kind = LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN)
    public T consume(PELexer lexer) {
        Token<? extends TokenId> lookahead = lexer.peek(seenEof);
        for (Element<? extends T> element : options) {
            if (element.canStartWith(lookahead)) {
                // matched
                return element.consume(lexer);
            }
        }
        CompilerDirectives.transferToInterpreter();
        throw error("no alternative found at " + lexer.position() + " in " + getRootNode().getName());
    }
    
    static RuntimeException error(String message) {
        CompilerAsserts.neverPartOfCompilation();
        throw new RuntimeException(message);
    }
}

final class Repetition<T, ListT, R> extends Element<R> {
    @Child private Element<T> element;
    private final Supplier<ListT> createList;
    private final BiFunction<ListT, T, ListT> addToList;
    private final Function<ListT, R> createResult;
    private final ConditionProfile seenEof = ConditionProfile.createBinaryProfile();

    Repetition(Element<T> element, Supplier<ListT> createList, BiFunction<ListT, T, ListT> addToList, Function<ListT, R> createResult) {
        this.element = element;
        this.createList = createList;
        this.addToList = addToList;
        this.createResult = createResult;
    }

    @Override
    protected void createFirstSet(Element<?> setHolder, HashSet<Rule<?>> rulesAdded) {
        throw new IllegalStateException("should not reach here");
    }

    @Override
    public void initialize() {
        element.createFirstSet(element, new HashSet<>());
        element.initialize();
    }

    @Override
    public R consume(PELexer lexer) {
        ListT list = createList.get();
        while (true) {
            Token<? extends TokenId> lookahead = lexer.peek(seenEof);
            if (!element.canStartWith(lookahead)) {
                return createResult.apply(list);
            }
            list = addToList.apply(list, element.consume(lexer));
        }
    }
}

final class OptionalElement<T, R> extends Element<R> {
    @Child Element<T> element;
    private final Function<T, R> hasValueAction;
    private final Supplier<R> hasNoValueAction;
    private final ConditionProfile seenEof = ConditionProfile.createBinaryProfile();

    OptionalElement(Element<T> element, Function<T, R> hasValueAction, Supplier<R> hasNoValueAction) {
        this.element = element;
        this.hasValueAction = hasValueAction;
        this.hasNoValueAction = hasNoValueAction;
    }

    @Override
    protected void createFirstSet(Element<?> setHolder, HashSet<Rule<?>> rulesAdded) {
        throw new IllegalStateException("should not reach here");
    }

    @Override
    public void initialize() {
        element.createFirstSet(element, new HashSet<>());
        element.initialize();
    }

    @Override
    public R consume(PELexer lexer) {
        Token<? extends TokenId> lookahead = lexer.peek(seenEof);
        if (element.canStartWith(lookahead)) {
            return hasValueAction.apply(element.consume(lexer));
        }
        return hasNoValueAction.get();
    }
}

final class TokenReference<TID extends TokenId, T> extends Element<T> {
    private final TID token;
    private final PEParser.TokenFunction<TID, T> action;
    private final ConditionProfile seenEof = ConditionProfile.createBinaryProfile();

    TokenReference(TID token, PEParser.TokenFunction<TID, T> action) {
        this.token = token;
        this.action = action;
    }

    @Override
    protected void createFirstSet(Element<?> setHolder, HashSet<Rule<?>> rulesAdded) {
        int id = token.ordinal();
        if (id < 64) {
            assert id > 0;
            setHolder.firstA |= 1L << id;
        } else {
            assert id < 128;
            setHolder.firstB |= 1L << (id - 64);
        }
    }

    @Override
    public void initialize() {
        // nothing to do
    }

    @Override
    public T consume(PELexer lexer) {
        Token<? extends TokenId> tokenId = lexer.peek(seenEof);
        Token<? extends TokenId> actualToken = lexer.nextToken(seenEof);
        if (actualToken == null || actualToken.id() != token) {
            CompilerDirectives.transferToInterpreter();
            error("expecting " + lexer.tokenNames(token) + ", got " + lexer.tokenNames(actualToken) + " at " + lexer.position());
        }
        return action.apply((Token<TID>) tokenId);
    }
}

@SuppressWarnings("unchecked")
public final class PEParser {

    static final boolean PEPARSER_DIRECT_CALL = Boolean.getBoolean("PEParser.directcall");

    private final ArrayList<Rule<?>> rules = new ArrayList<>();
    @CompilationFinal private Rule<?> root;

    private static <T> void replaceRules(Element<? extends T>[] elements) {
        for (int i = 0; i < elements.length; i++) {
            if (elements[i] instanceof Rule) {
                elements[i] = new CallRule<>((Rule<T>) elements[i]);
            }
        }
    }

    private static <T> Element<T> replaceRule(Element<T> element) {
        if (element instanceof Rule<?>) {
            return new CallRule<>((Rule<T>) element);
        } else {
            return element;
        }
    }

    public static <T> Element<T> alt(Element<? extends T>... options) {
        replaceRules(options);
        return new Alternative<>(options);
    }

    public static <A, R> Element<R> seq(Element<A> a, Function<? super A, R> action) {
        return new Sequence1<>(action, replaceRule(a));
    }

    public static <A, B, R> Element<R> seq(Element<A> a, Element<B> b, BiFunction<? super A, ? super B, R> action) {
        return new Sequence2<>(action, replaceRule(a), replaceRule(b));
    }

    public static <A, B, C, R> Element<R> seq(Element<A> a, Element<B> b, Element<C> c, Function3<? super A, ? super B, ? super C, R> action) {
        return new Sequence3<>(action, replaceRule(a), replaceRule(b), replaceRule(c));
    }

    public static <A, B, C, D, R> Element<R> seq(Element<A> a, Element<B> b, Element<C> c, Element<D> d, Function4<? super A, ? super B, ? super C, ? super D, R> action) {
        return new Sequence4<>(action, replaceRule(a), replaceRule(b), replaceRule(c), replaceRule(d));
    }

    public static <T, ListT, R> Element<R> rep(Element<T> element, Supplier<ListT> createList, BiFunction<ListT, T, ListT> addToList, Function<ListT, R> createResult) {
        return new Repetition<>(replaceRule(element), createList, addToList, createResult);
    }

    public static <T> Element<Optional<T>> opt(Element<T> element) {
        return new OptionalElement<>(replaceRule(element), v -> Optional.ofNullable(v), () -> Optional.empty());
    }

    public static <T extends TokenId> Element<Token<T>> ref(T id) {
        return ref(id, (t) -> t);
    }

    public static <T extends TokenId, R> Element<R> ref(T id, TokenFunction<T, R> action) {
        return new TokenReference<>(id, action);
    }

    public <T> Rule<T> rule(String name) {
        Rule<T> rule = new Rule<>(name);
        rules.add(rule);
        return rule;
    }

    public interface Function3<A, B, C, R> {
        R apply(A a, B b, C c);
    }

    public interface Function4<A, B, C, D, R> {
        R apply(A a, B b, C c, D d);
    }

    public interface Function5<A, B, C, D, E, R> {
        R apply(A a, B b, C c, D d, E e);
    }

    public interface TokenFunction<T extends TokenId, R> {
        R apply(Token<T> token);
    }

    PEParser() {
        // private constructor
    }

    final void initialize(Rule<?> newRoot) {
        this.root = newRoot;
        for (Rule<?> rule : rules) {
            rule.initializeRule();
        }
        for (Rule<?> rule : rules) {
            if (rule.element != null) {
                rule.element.initialize();
            }
        }

    }

    Object parse(PELexer lexer) {
        return root.getCallTarget().call(lexer.asArgumentsArray());
    }
}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import com.oracle.truffle.api.CompilerDirectives;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import org.netbeans.api.lexer.Token;
import org.netbeans.spi.lexer.Lexer;
import org.netbeans.spi.lexer.LexerInput;
import org.netbeans.spi.lexer.LexerRestartInfo;
import org.netbeans.spi.lexer.TokenFactory;

final class SelfLexer implements Lexer<SelfTokenId> {

    private static final int EOF = LexerInput.EOF;

    private final LexerInput input;
    private final TokenFactory<SelfTokenId> tokenFactory;

    SelfLexer(LexerRestartInfo<SelfTokenId> info) {
        this.input = info.input();
        this.tokenFactory = info.tokenFactory();
        assert (info.state() == null); // passed argument always null
    }

    @Override
    public Token<SelfTokenId> nextToken() {
        while (true) {
            int ch = input.read();
            switch (ch) {
                case '(':
                    return token(SelfTokenId.LPAREN);

                case ')':
                    return token(SelfTokenId.RPAREN);

                case '.':
                    return token(SelfTokenId.DOT);

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    return finishIntOrFloatLiteral(ch);

                case '!':
                case '@':
                case '#':
                case '$':
                case '%':
                case '^':
                case '&':
                case '*':
                case '-':
                case '+':
                case '=':
                case '~':
                case '/':
                case '?':
                case '<':
                case '>':
                case ',':
                case ';':
                case '|':
                case '‘':
                case '\\':
                    boolean justOne = true;
                    for (;;) {
                        switch (input.read()) {
                            case '!':
                            case '@':
                            case '#':
                            case '$':
                            case '%':
                            case '^':
                            case '&':
                            case '*':
                            case '-':
                            case '+':
                            case '=':
                            case '~':
                            case '/':
                            case '?':
                            case '<':
                            case '>':
                            case ',':
                            case ';':
                            case '|':
                            case '‘':
                            case '\\':
                                justOne = false;
                                continue;
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                                if (ch == '-') {
                                    input.backup(1);
                                    return finishIntOrFloatLiteral(ch);
                                }
                        }
                        input.backup(1);
                        if (justOne) {
                            switch (ch) {
                                case '|':
                                    return token(SelfTokenId.BAR);
                                case '=':
                                    return token(SelfTokenId.EQUAL);
                                case '.':
                                    return token(SelfTokenId.DOT);
                            }
                        }
                        return token(SelfTokenId.OPERATOR);
                    }
                case '_':
                    return consumeIdentifier(ch);
                case '\'':
                    return consumeString(ch);
                case '"':
                    return consumeComment(ch);
                case ':':
                    ch = input.read();
                    if (Character.isLowerCase(ch)) {
                        Token<SelfTokenId> ident = consumeIdentifier(ch);
                        if (ident.id() == SelfTokenId.IDENTIFIER) {
                            return token(SelfTokenId.ARGUMENT);
                        }
                    }
                    return consumeUptoWhitespace(SelfTokenId.ERROR);
                case EOF:
                    return null;
                default:
                    if (Character.isWhitespace(ch)) {
                        ch = input.read();
                        while (ch != EOF && Character.isWhitespace(ch)) {
                            ch = input.read();
                        }
                        input.backup(1);
                        return token(SelfTokenId.WHITESPACE);
                    }

                    if (Character.isLowerCase(ch)) {
                        return consumeIdentifier(ch);
                    }

                    if (Character.isAlphabetic(ch)) {
                        Token<SelfTokenId> token = consumeIdentifier(ch);
                        if (token.id() == SelfTokenId.KEYWORD) {
                            return token;
                        }
                    }
                    return consumeUptoWhitespace(SelfTokenId.ERROR);
            }
        }
    }

    private Token<SelfTokenId> consumeUptoWhitespace(SelfTokenId id) {
        for (;;) {
            int ch = input.read();
            if (ch == EOF) {
                break;
            }
            if (Character.isWhitespace(ch)) {
                break;
            }
        }
        input.backup(1);
        return token(id);
    }

    private Token<SelfTokenId> consumeString(int ch) {
        boolean backslash = false;
        for (;;) {
            ch = input.read();
            switch (ch) {
                case '\\':
                    backslash = !backslash;
                    break;
                case '\'':
                    if (!backslash) {
                        return token(SelfTokenId.STRING);
                    }
                    break;
                case '\n':
                case EOF:
                    return token(SelfTokenId.ERROR);
            }
        }
    }

    private Token<SelfTokenId> consumeComment(int ch) {
        for (;;) {
            ch = input.read();
            switch (ch) {
                case '"':
                    return token(SelfTokenId.COMMENT);
                case EOF:
                    return token(SelfTokenId.ERROR);
            }
        }
    }

    @Override
    public Object state() {
        return null;
    }

    @Override
    public void release() {
    }

    private Token<SelfTokenId> finishIntOrFloatLiteral(int ch) {
        boolean firstLetter = true;
        boolean baseRead = false;
        boolean floatLiteral = false;
        boolean inExponent = false;
        while (true) {
            switch (ch) {
                case '.':
                    if (floatLiteral) {
                        return token(SelfTokenId.NUMBER);
                    } else {
                        floatLiteral = true;
                    }
                    break;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    break;
                case 'r':
                case 'R': // base separator
                    if (baseRead) {
                        return token(SelfTokenId.NUMBER);
                    }
                    baseRead = true;
                    break;
                case 'e':
                case 'E': // exponent part
                    if (baseRead && 'a' <= ch && ch <= 'z') {
                        break;
                    }
                    if (inExponent) {
                        return token(SelfTokenId.NUMBER);
                    } else {
                        floatLiteral = true;
                        inExponent = true;
                    }
                    break;
                case '-':
                    if (firstLetter) {
                        break;
                    }
                case '+':
                    if (inExponent) {
                        break;
                    }
                // fallthrough
                default:
                    if (baseRead && 'a' <= ch && ch <= 'z') {
                        break;
                    }
                    input.backup(1);
                    return token(SelfTokenId.NUMBER);
            }
            firstLetter = false;
            ch = input.read();
        }
    }

    private Token<SelfTokenId> token(SelfTokenId id) {
        return (id.fixedText() != null)
            ? tokenFactory.getFlyweightToken(id, id.fixedText())
            : tokenFactory.createToken(id);
    }

    private Token<SelfTokenId> consumeIdentifier(int first) {
        for (;;) {
            int ch = input.read();
            if (Character.isLetterOrDigit(ch)) {
                continue;
            }
            if ('_' == ch) {
                continue;
            }
            SelfTokenId id;
            if (':' == ch) {
                id = Character.isLowerCase(first) ? SelfTokenId.KEYWORD_LOWERCASE : SelfTokenId.KEYWORD;
            } else {
                input.backup(1); // backup the extra char (or EOF)
                switch (input.readText().toString()) {
                    case "true":
                        id = SelfTokenId.BOOLEAN;
                        break;
                    case "false":
                        id = SelfTokenId.BOOLEAN;
                        break;
                    case "resend":
                        id = SelfTokenId.RESEND;
                        break;
                    default:
                        id = SelfTokenId.IDENTIFIER;
                }
            }
            return token(id);
        }
    }

    static class BasicNode {

        private final String name;
        private final BasicNode[] children;
        private final ListItem<SelfObject> objects;

        BasicNode(String name, BasicNode... children) {
            this.name = name;
            this.children = children;
            this.objects = null;
        }

        BasicNode(String name, List<BasicNode> children) {
            this.name = name;
            this.children = children.toArray(new BasicNode[children.size()]);
            this.objects = null;
        }

        BasicNode(String name, ListItem<SelfObject> createdObjects) {
            this.name = name;
            this.children = new BasicNode[0];
            this.objects = createdObjects;
        }

        public void print(int level) {
            for (int i = 0; i < level; i++) {
                System.out.print("  ");
            }
            System.out.println(name);
            for (BasicNode child : children) {
                child.print(level + 1);
            }
        }

        void print(Consumer<Object> registrar) {
            for (BasicNode child : children) {
                child.print(registrar);
            }
            ListItem<SelfObject> obj = objects;
            while (obj != null) {
                registrar.accept(obj.item);
                obj = obj.prev;
            }
        }
    }

    public static BasicNode[] concat(BasicNode first, ListItem<BasicNode> rest) {
        final int size = ListItem.size(rest);
        BasicNode[] result = new BasicNode[size + 1];
        result[0] = first;
        for (int i = size; i >= 1; i--) {
            result[i + 1] = rest.item;
            rest = rest.prev;
        }
        return result;
    }

    public static final class ListItem<E> {

        final ListItem<E> prev;
        final E item;

        public ListItem(ListItem<E> prev, E item) {
            this.prev = prev;
            this.item = item;
        }

        public static <T> ListItem<T> empty() {
            return null;
        }

        public static <T> ListItem<T> empty(Object ignore) {
            return null;
        }

        public static <T> ListItem<T> self(ListItem<T> self) {
            return self;
        }

        public static <A, B> A first(A a, B b) {
            return a;
        }

        public static <A, B> B second(A a, B b) {
            return b;
        }

        public static int size(ListItem<?> item) {
            int cnt = 0;
            while (item != null) {
                cnt++;
                item = item.prev;
            }
            return cnt;
        }

        public static <T> void firstToLast(ListItem<T> last, Consumer<T> call) {
            int len = size(last);
            Object[] arr = new Object[len];
            for (int i = len; i > 0;) {
                arr[--i] = last.item;
                last = last.prev;
            }
            for (int i = 0; i < len; i++) {
                call.accept((T) arr[i]);
            }
        }


        @CompilerDirectives.TruffleBoundary
        public static <T> ListItem<T> firstAndNewer(T item, ListItem<T> list) {
            if (list == null) {
                return new ListItem<>(null, item);
            } else {
                return new ListItem<>(firstAndNewer(item, list.prev), list.item);
            }
        }

        public static <T> T[] toArray(ListItem<? extends T> node, Function<Integer, T[]> factory) {
            T[] arr = factory.apply(size(node));
            for (int i = arr.length; node != null;) {
                arr[--i] = node.item;
                node = node.prev;
            }
            return arr;
        }
    }
}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.interop.ForeignAccess;
import com.oracle.truffle.api.interop.MessageResolution;
import com.oracle.truffle.api.interop.Resolve;
import com.oracle.truffle.api.interop.TruffleObject;
import com.oracle.truffle.api.nodes.Node;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;

@MessageResolution(receiverType = SelfObject.class)
class SelfObject implements Cloneable, TruffleObject {
    private final Map<String, Object> slots;
    private final SelfCode code;
    private final SelfObject parent;

    private SelfObject(Map<String, Object> slots, SelfCode code, SelfObject parent) {
        this.slots = slots;
        this.code = code;
        this.parent = parent;
    }

    Object get(String name) {
        Object v = slots == null ? null : slots.get(name);
        if (v == null && parent != null) {
            v = parent.get(name);
        }
        return v;
    }

    private static final SelfObject TRUE = SelfObject.newBuilder().
        wrapper(Boolean.TRUE).
        slot("not", SelfObject.newBuilder().code((self, __) -> valueOf(false)).build()).
        build();

    private static final SelfObject FALSE = SelfObject.newBuilder().
        wrapper(Boolean.FALSE).
        slot("not", SelfObject.newBuilder().code((self, __) -> valueOf(true)).build()).
        build();

    static SelfObject valueOf(boolean value) {
        return value ? TRUE : FALSE;
    }

    private static final SelfObject NUMBERS = SelfObject.newBuilder().
        slot("+", SelfObject.newBuilder().code((self, arg) -> {
            Optional<Object> valueArg = findWrappedValue(arg[0]);
            Optional<Object> valueNum = findWrappedValue(self);
            if (valueArg.isPresent() && valueNum.isPresent()) {
                if (valueArg.get() instanceof Number && valueNum.get() instanceof Number) {
                    int res = ((Number)valueNum.get()).intValue() + ((Number)valueArg.get()).intValue();
                    return SelfObject.valueOf(res);
                }
            }
            return SelfObject.valueOf(self.toString() + Objects.toString(arg[0]));
        }).build()).
        build();
    static SelfObject valueOf(int number) {
        return new Wrapper<>(NUMBERS, null, number);
    }

    private static final SelfObject TEXTS = SelfObject.newBuilder().build();
    static SelfObject valueOf(String text) {
        return new Wrapper<>(TEXTS, null, text);
    }

    static Builder newBuilder() {
        return new Builder();
    }

    @CompilerDirectives.TruffleBoundary(allowInlining = true)
    static Builder newBuilder(SelfObject toCopy) {
        Builder b = new Builder();
        b.code(toCopy.code);
        if (toCopy.slots != null) {
            b.slots = new LinkedHashMap<>(toCopy.slots);
        }
        if (toCopy instanceof Wrapper) {
            b.wrapper(((Wrapper) toCopy).value);
        }
        return b;
    }

    static boolean isInstance(TruffleObject obj) {
        return obj instanceof SelfObject;
    }

    @Override
    public ForeignAccess getForeignAccess() {
        return SelfObjectForeign.ACCESS;
    }

    SelfObject evalSelf(SelfObject self, SelfObject[] values) {
        if (code == null) {
            return this;
        } else {
            SelfObject methodActivation = cloneWithArgs(self, values);
            return code.sendMessage(methodActivation, values);
        }
    }

    private SelfObject cloneWithArgs(SelfObject parent, SelfObject[] args) {
        assert code != null;
        Map<String, Object> slotsClone;
        if (slots == null) {
            slotsClone = null;
        } else {
            slotsClone = new LinkedHashMap<>();
            int index = 0;
            for (Map.Entry<String, Object> e : slots.entrySet()) {
                if (e.getKey().startsWith(":")) {
                    slotsClone.put(e.getKey().substring(1), args[index++]);
                } else {
                    slotsClone.put(e.getKey(), e.getValue());
                }
            }
            assert index == args.length : "Slots " + slotsClone + " args: " + Arrays.toString(args);
        }
        return new SelfObject(slotsClone, code, parent);
    }

    @Resolve(message = "UNBOX")
    static abstract class Unbox extends Node {
        Object access(SelfObject obj) {
            return findWrappedValue(obj).get();
        }
    }

    static final class Builder {
        private Map<String, Object> slots;
        private SelfCode code;
        private Object wrapper;

        Builder code(SelfCode expr) {
            code = expr;
            return this;
        }

        Builder code(BiFunction<SelfObject, SelfObject[], SelfObject> fn) {
            code = SelfCode.compute(fn);
            return this;
        }

        Builder argument(String name) {
            slots().put(name, "");
            return this;
        }

        Builder slot(String name, Object value) {
            slots().put(name, value);
            return this;
        }

        SelfObject build() {
            if (wrapper != null) {
                return new Wrapper(null, slots, wrapper);
            }
            return new SelfObject(slots, code, null);
        }

        private Map<String,Object> slots() {
            if (slots == null) {
                slots = new LinkedHashMap<>();
            }
            return slots;
        }

        private Builder wrapper(Object obj) {
            this.wrapper = obj;
            return this;
        }
    }

    private static final class Wrapper<T> extends SelfObject {
        private final T value;

        Wrapper(SelfObject parent, Map<String, Object> slots, T value) {
            super(slots, null, parent);
            this.value = value;
        }

        @Override
        public String toString() {
            return value.toString();
        }
    }

    private static Optional<Object> findWrappedValue(SelfObject obj) {
        while (obj != null) {
            if (obj instanceof Wrapper) {
                return Optional.of(((Wrapper) obj).value);
            }
            obj = obj.parent;
        }
        return null;
    }
}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.interop.UnknownIdentifierException;
import com.oracle.truffle.api.nodes.ExplodeLoop;
import com.oracle.truffle.api.nodes.Node;
import java.util.function.BiFunction;

abstract class SelfCode extends Node {

    abstract SelfObject sendMessage(SelfObject self, SelfObject... args);

    @CompilerDirectives.TruffleBoundary(allowInlining = true)
    static SelfCode constant(SelfObject obj) {
        return new Constant(obj);
    }

    @CompilerDirectives.TruffleBoundary(allowInlining = true)
    static SelfCode self() {
        return new Self();
    }

    @CompilerDirectives.TruffleBoundary(allowInlining = true)
    static SelfCode block(SelfCode... children) {
        return new Block(children);
    }

    @CompilerDirectives.TruffleBoundary(allowInlining = true)
    static SelfCode unaryMessage(SelfCode receiver, SelfSelector message) {
        return new Message(receiver, message);
    }

    @CompilerDirectives.TruffleBoundary(allowInlining = true)
    static SelfCode binaryMessage(SelfCode receiver, SelfSelector message, SelfCode arg) {
        return new Message(receiver, message, arg);
    }

    @CompilerDirectives.TruffleBoundary(allowInlining = true)
    static SelfCode keywordMessage(SelfCode receiver, SelfSelector selector, SelfCode... args) {
        return new Message(receiver, selector, args);
    }

    @CompilerDirectives.TruffleBoundary(allowInlining = true)
    static SelfCode compute(BiFunction<SelfObject, SelfObject[], SelfObject> fn) {
        return new Compute(fn);
    }

    private static class Constant extends SelfCode {
        private final SelfObject obj;

        Constant(SelfObject obj) {
            this.obj = obj;
        }

        @Override
        SelfObject sendMessage(SelfObject self, SelfObject... args) {
            return obj.evalSelf(self, args);
        }

        @Override
        public String toString() {
            return "[Constant=" + obj + "]";
        }
    }

    private static class Self extends SelfCode {
        @Override
        SelfObject sendMessage(SelfObject self, SelfObject... args) {
            return self;
        }
    }

    private static class Message extends SelfCode {
        @Child
        private SelfCode receiver;
        @Children
        private SelfCode[] args;
        private final SelfSelector message;

        Message(SelfCode receiver, SelfSelector message, SelfCode... args) {
            this.receiver = receiver;
            this.message = message;
            this.args = args;
        }

        @ExplodeLoop
        @Override
        SelfObject sendMessage(SelfObject self, SelfObject... myArgs) {
            SelfObject obj = receiver.sendMessage(self);
            SelfObject[] values = new SelfObject[args.length];
            for (int i = 0; i < args.length; i++) {
                values[i] = args[i].sendMessage(self);
            }
            final SelfObject msg = (SelfObject) obj.get(message.toString());
            if (msg == null) {
                throw UnknownIdentifierException.raise(message.toString());
            }
            return msg.evalSelf(obj, values);
        }
    }

    private static class Block extends SelfCode {
        @Children
        private SelfCode[] children;

        Block(SelfCode[] children) {
            this.children = children;
        }

        @ExplodeLoop
        @Override
        SelfObject sendMessage(SelfObject self, SelfObject... args) {
            SelfObject res = self;
            for (int i = 0; i < children.length; i++) {
                res = children[i].sendMessage(self);
            }
            return res;
        }
    }

    private static class Compute extends SelfCode {
        private final BiFunction<SelfObject, SelfObject[], SelfObject> fn;

        Compute(BiFunction<SelfObject, SelfObject[], SelfObject> fn) {
            this.fn = fn;
        }

        @Override
        SelfObject sendMessage(SelfObject self, SelfObject... args) {
            return fn.apply(self, args);
        }
    }
}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import java.util.Collection;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import org.netbeans.api.lexer.Language;
import org.netbeans.api.lexer.TokenId;
import org.netbeans.spi.lexer.LanguageHierarchy;
import org.netbeans.spi.lexer.Lexer;
import org.netbeans.spi.lexer.LexerRestartInfo;

enum SelfTokenId implements TokenId {

    WHITESPACE(null, "whitespace"),
    IDENTIFIER(null, "identifier"),
    RESEND(null, "identifier"),
    KEYWORD_LOWERCASE(null, "identifier"),
    KEYWORD(null, "identifier"),
    ARGUMENT(null, "identifier"),
    OPERATOR(null, null),
    BOOLEAN(null, "number"),
    NUMBER(null, "number"),
    STRING(null, "string"),

    COMMENT(null, "comment"),
    LPAREN("(", "separator"),
    RPAREN(")", "separator"),
    BAR("|", "separator"),
    DOT(".", "separator"),
    EQUAL("=", "separator"),
    ARROW("<-", "separator"),
    ERROR(null, "error");

    public static final String MIMETYPE = "text/x-self";

    private final String fixedText;

    private final String primaryCategory;

    private SelfTokenId(String fixedText, String primaryCategory) {
        this.fixedText = fixedText;
        this.primaryCategory = primaryCategory;
    }

    public String fixedText() {
        return fixedText;
    }

    @Override
    public String primaryCategory() {
        return primaryCategory;
    }

    private static final Language<SelfTokenId> language = new LanguageHierarchy<SelfTokenId>() {
        @Override
        protected Collection<SelfTokenId> createTokenIds() {
            return EnumSet.allOf(SelfTokenId.class);
        }

        @Override
        protected Map<String,Collection<SelfTokenId>> createTokenCategories() {
            Map<String,Collection<SelfTokenId>> cats = new HashMap<>();
            return cats;
        }

        @Override
        protected Lexer<SelfTokenId> createLexer(LexerRestartInfo<SelfTokenId> info) {
            return new SelfLexer(info);
        }

        @Override
        protected String mimeType() {
            return MIMETYPE;
        }

    }.language();

    public static final Language<SelfTokenId> language() {
        return language;
    }

}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import com.oracle.truffle.api.CompilerDirectives;

final class SelfSelector {
    private final String keyword;

    private SelfSelector(String k) {
        this.keyword = k;
    }

    @CompilerDirectives.TruffleBoundary
    static SelfSelector keyword(String... lowerCase) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < lowerCase.length; i++) {
            sb.append(lowerCase[i]);
        }
        return new SelfSelector(sb.toString());
    }

    @Override
    public String toString() {
        return keyword;
    }
}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import com.oracle.truffle.api.profiles.ConditionProfile;
import org.netbeans.api.lexer.Token;
import org.netbeans.api.lexer.TokenId;

interface PELexer<T> {

    public Object[] asArgumentsArray();

    public Token<? extends TokenId> peek(ConditionProfile seenEof);
    
    public String position();

    public void resetStackPointer(int pointer);

    public Token<? extends TokenId> nextToken(ConditionProfile seenEof);

    public int getStackPointer();
    
    public String tokenNames(TokenId token);

    public default String tokenNames(Token<? extends TokenId> token) {
        return tokenNames(token.id());
    }
}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import java.io.IOException;
import org.graalvm.polyglot.Context;
import org.graalvm.polyglot.PolyglotException;
import org.graalvm.polyglot.Source;
import org.graalvm.polyglot.Value;
import org.junit.Assert;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.fail;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;

public class SelfLanguageTest {
    @Before
    public void registerInGraalVMLanguagePath() {
        final String path = System.getProperty("java.class.path");
        System.setProperty("truffle.class.path.append", path);
    }

    @Test
    public void evalTrue() {
        Object yes = Context.create().eval("Self", "true").asBoolean();
        Assert.assertEquals(Boolean.TRUE, yes);
    }

    @Test
    public void evalFalse() {
        Object no = Context.create().eval("Self", "false").asBoolean();
        Assert.assertEquals(Boolean.FALSE, no);
    }

    @Test
    public void evalNotTrue() {
        Object no = Context.create().eval("Self", "true not").asBoolean();
        Assert.assertEquals(Boolean.FALSE, no);
    }

    @Test
    public void evalNotNotTrue() {
        Object yes = Context.create().eval("Self", "true not not").asBoolean();
        Assert.assertEquals(Boolean.TRUE, yes);
    }

    @Test
    public void evalPlus() {
        int three = Context.create().eval("Self", "(1 + 2)").asInt();
        Assert.assertEquals(3, three);
    }

    @Test
    public void invokeKeyMessageOnEmptyObject() {
        final Context ctx = Context.create();
        try {
            Value res = ctx.eval("Self", "() plus: 2");
            fail("Unexpected result: " + res);
        } catch (PolyglotException ex) {
            assertNotEquals(ex.getMessage(), -1, ex.getMessage().indexOf("Unknown identifier: plus:"));
        }
    }

    @Test
    public void evalNplusOneArgument() {
        final Context ctx = Context.create();
        Value res = ctx.eval("Self", "( | plus: = ( | :n | 1 + n ) | ) plus: 2");
        Assert.assertEquals(3, res.asInt());
    }

    @Test
    public void evalNplusOneDirect() {
        final Context ctx = Context.create();
        Value res = ctx.eval("Self", "( | plus: n = ( 1 + n ) | ) plus: 2");
        Assert.assertEquals(3, res.asInt());
    }

    @Test
    public void evalMultiKeywordMessage() {
        final Context ctx = Context.create();
        Value res = ctx.eval("Self", "( | plus: n And: m = ( m + n ) | ) plus: 2 And: 3");
        Assert.assertEquals(5, res.asInt());
    }

    @Test
    public void evalMultiKeywordMessageWithInObjectArgs() {
        final Context ctx = Context.create();
        Value res = ctx.eval("Self", "( | plus:And:= ( | :n. :m | m + n ) | ) plus: 2 And: 3");
        Assert.assertEquals(5, res.asInt());
    }

    @Test
    public void evalMultiKeywordMessage3() {
        final Context ctx = Context.create();
        Value res = ctx.eval("Self", "( | plus: n And: m By: o = ( (m + n) + o ) | ) plus: 2 And: 2 By: 1");
        Assert.assertEquals(5, res.asInt());
    }

    @Test
    public void evalMultiKeywordMessageWithInObjectArgs3() {
        final Context ctx = Context.create();
        Value res = ctx.eval("Self", "( | plus:And:By: = ( | :n. :m. :o | (m + n) + o ) | ) plus: 2 And: 1 By: 2");
        Assert.assertEquals(5, res.asInt());
    }

    @Test
    public void evalMultiKeywordMessage4() {
        final Context ctx = Context.create();
        Value res = ctx.eval("Self", "( | plus: n And: m By: o Yet: p = ( m + n + o + p ) | ) plus: 1 And: 2 By: 1 Yet: 1");
        Assert.assertEquals(5, res.asInt());
    }

    @Test(expected = PolyglotException.class)
    public void rowOfHeterogenousOperandsIsntAllowed() {
        final Context ctx = Context.create();
        Value res = ctx.eval("Self", "( | plus: n And: m By: o = ( m + n * o) | )");
        fail("Parse shouldn't succeed: " + res);
    }

    @Test
    public void evalMultiKeywordMessageWithInObjectArgs4() {
        final Context ctx = Context.create();
        Value res = ctx.eval("Self", "( | plus:And:By:Yet: = ( | :n. :m. :o. :p | (m + n) + (o + p) ) | ) plus: 2 And: 1 By: 1 Yet: 1");
        Assert.assertEquals(5, res.asInt());
    }

    @Test
    public void evalNplusOne() {
        final Context ctx = Context.create();
        Value inc = ctx.eval("Self", "( | plus: n = ( n + 1 ) | )");
        /* TBD:
        Value res = inc.invokeMember("plus:", 2);
        fail("" + res.toString());
        Assert.assertEquals(3, res.asInt());
        */
    }

    @Test
    public void benchmark() throws Exception {
        String benchmarkName = System.getProperty("SelfGraal.Benchmark");
        Assume.assumeNotNull("Not running the benchmark without a name", benchmarkName);
        StringBuilder sb = new StringBuilder();
        sb.append("( |");
        for (int i = 0; i < 100000; i++) {
            sb.append("plus").append(i).append(": n = ( n + 1 ).\n");
        }
        sb.append(" x = 1 |)");
        Context ctx = Context.create();

        System.out.println("Warming up...");
        benchmarkNTimes("WarmUp", 20, sb, ctx, new long[1]);

        System.out.println("Benchmarking...");
        long[] sum = { 0 };
        int count = 10;
        benchmarkNTimes(benchmarkName, count, sb, ctx, sum);
        System.out.println(benchmarkName + " took " + (sum[0] / count) + " ms on average");
    }

    private void benchmarkNTimes(String name, int count, StringBuilder sb, Context ctx, long[] sum) throws IOException {
        for (int i = 1; i <= count; i++) {
            System.gc();
            System.runFinalization();
            System.gc();
            Source src = Source.newBuilder("Self", sb.toString(), "large" + i + ".sf").build();
            long before = System.currentTimeMillis();
            ctx.eval(src);
            long after = System.currentTimeMillis();
            final long took = after - before;
            System.out.println(name + " #" + i + " took " + took + " ms");
            sum[0] += took;
            sb.append("\n");
        }
    }
}
/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.apidesign.language.self;

import com.oracle.truffle.api.source.Source;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import org.junit.Test;
import org.netbeans.api.lexer.Token;
import org.netbeans.api.lexer.TokenHierarchy;
import org.netbeans.api.lexer.TokenSequence;

public class SelfParserTest {

    public SelfParserTest() {
    }

    @Test
    public void testLexingTheInput() {
        TokenSequence<SelfTokenId> seq = TokenHierarchy.create("1 + 2.3", SelfTokenId.language()).tokenSequence(SelfTokenId.language());
        assertNull("before 1st token", seq.token());
        assertNextToken("1", seq);
        assertNextToken(" ", seq);
        assertNextToken("+", seq);
        assertNextToken(" ", seq);
        assertNextToken("2.3", seq);
        assertFalse("At the end of input", seq.moveNext());
    }

    @Test
    public void identifiers() {
        String text = "    i _IntAdd cloud9 resend m a_point \n\t\r NotAnIdent true false";

        TokenSequence<SelfTokenId> seq = TokenHierarchy.create(text, SelfTokenId.language()).tokenSequence(SelfTokenId.language());
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.IDENTIFIER, seq).text("i");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.IDENTIFIER, seq).text("_IntAdd");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.IDENTIFIER, seq).text("cloud9");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.RESEND, seq);
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.IDENTIFIER, seq).text("m");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.IDENTIFIER, seq).text("a_point");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.ERROR, seq).text("NotAnIdent");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.BOOLEAN, seq).text("true");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.BOOLEAN, seq).text("false");
        assertFalse("At the end of input", seq.moveNext());
    }

    @Test
    public void keywords() {
        String text = "\tat: NoKeyword Put:\n_IntAdd:";

        TokenSequence<SelfTokenId> seq = TokenHierarchy.create(text, SelfTokenId.language()).tokenSequence(SelfTokenId.language());
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.KEYWORD_LOWERCASE, seq).text("at:");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.ERROR, seq).text("NoKeyword");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.KEYWORD, seq).text("Put:");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.KEYWORD, seq).text("_IntAdd:");
        assertFalse("At the end of input", seq.moveNext());
    }

    @Test
    public void arguments() {
        String text = "\t:arg1 :NoArg :x";

        TokenSequence<SelfTokenId> seq = TokenHierarchy.create(text, SelfTokenId.language()).tokenSequence(SelfTokenId.language());
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.ARGUMENT, seq).text(":arg1");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.ERROR, seq).text(":NoArg");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.ARGUMENT, seq).text(":x");
        assertFalse("At the end of input", seq.moveNext());
    }

    @Test
    public void operators() {
        String text = "   && ++ * +=- |";

        TokenSequence<SelfTokenId> seq = TokenHierarchy.create(text, SelfTokenId.language()).tokenSequence(SelfTokenId.language());
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.OPERATOR, seq).text("&&");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.OPERATOR, seq).text("++");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.OPERATOR, seq).text("*");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.OPERATOR, seq).text("+=-");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.BAR, seq);
        assertFalse("At the end of input", seq.moveNext());
    }

    @Test
    public void numbers() {
        String text = "\r123 . 3.14 1272.34e+15 1e10 1272.34e-15 16r27fe -5";

        TokenSequence<SelfTokenId> seq = TokenHierarchy.create(text, SelfTokenId.language()).tokenSequence(SelfTokenId.language());
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.NUMBER, seq).text("123");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.DOT, seq).text(".");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.NUMBER, seq).text("3.14");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.NUMBER, seq).text("1272.34e+15");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.NUMBER, seq).text("1e10");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.NUMBER, seq).text("1272.34e-15");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.NUMBER, seq).text("16r27fe");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.NUMBER, seq).text("-5");
        assertFalse("At the end of input", seq.moveNext());
    }

    @Test
    public void strings() {
        String text = "   'Hi' '\\t\\f\\'\\x20\\d32\\o40\\\"\\\\ \\n\n 'x'";

        TokenSequence<SelfTokenId> seq = TokenHierarchy.create(text, SelfTokenId.language()).tokenSequence(SelfTokenId.language());
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.STRING, seq).text("'Hi'");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.ERROR, seq);
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.STRING, seq).text("'x'");
        assertFalse("At the end of input", seq.moveNext());
    }
    @Test
    public void comments() {
        String text = "   \"comment\"  \n \"multiline\ncomment\" ";

        TokenSequence<SelfTokenId> seq = TokenHierarchy.create(text, SelfTokenId.language()).tokenSequence(SelfTokenId.language());
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.COMMENT, seq).text("\"comment\"");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertNextToken(SelfTokenId.COMMENT, seq).text("\"multiline\ncomment\"");
        assertNextToken(SelfTokenId.WHITESPACE, seq);
        assertFalse("At the end of input", seq.moveNext());
    }

    @Test
    public void parseCodeObject() {
        Source s = Source.newBuilder("Self", "( 1 + 2 )", "empty.sf").build();
        Object obj = SelfParser.parse(s).sendMessage(null);
        assertNotNull("Object created", obj);
    }
    @Test
    public void parseEmptyObject() {
        Source s = Source.newBuilder("Self", "()", "empty.sf").build();
        Object obj = SelfParser.parse(s).sendMessage(null);
        assertNotNull("Object created", obj);
    }

    @Test
    public void parseEmptyObjectWithSlots() {
        Source s = Source.newBuilder("Self", "( | | )", "empty.sf").build();
        Object obj = SelfParser.parse(s).sendMessage(null);
        assertNotNull("Object created", obj);
    }

    @Test
    public void parseEmptyObjectWithOneSlot() {
        Source s = Source.newBuilder("Self", "( | x = 's' | )", "empty.sf").build();
        Object obj = SelfParser.parse(s).sendMessage(null);
        assertProperty(obj, "x", "'s'");
    }

    private void assertProperty(Object item, String propertyName, Object exp) {
        assertNotNull("Object created", item);
        assertTrue("Instance of right class: " + item, item instanceof SelfObject);
        SelfObject map = (SelfObject) item;
        final Object value = map.get(propertyName);
        assertNotNull("Value of " + propertyName + " is set", value);
        if (exp != null) {
            assertEquals("Value of " + propertyName + " is correct", exp, value.toString());
        }
    }

    @Test
    public void parseIdFn() {
        Source s = Source.newBuilder("Self", "( | id: n = ( ^n ) | )", "empty.sf").build();
        Object obj = SelfParser.parse(s).sendMessage(null);
        assertProperty(obj, "id:", null);
    }

    @Test
    public void parsePlusFn() {
        Source s = Source.newBuilder("Self", "( | plus: n = ( n + 1 ) | )", "plus.sf").build();
        Object obj = SelfParser.parse(s).sendMessage(null);
        assertProperty(obj, "plus:", null);
    }

    @Test
    public void parseConstantFn() {
        Source s = Source.newBuilder("Self", "( | id: n = 'e' | )", "empty.sf").build();
        Object obj = SelfParser.parse(s).sendMessage(null);
        SelfParser.parse(s);
        assertProperty(obj, "id:", "'e'");
    }

    @Test
    public void parseEmptyObjectWithTwoSlots() {
        Source s = Source.newBuilder("Self", "( | x = 's' . y = 3 | )", "empty.sf").build();
        Object obj = SelfParser.parse(s).sendMessage(null);
        assertProperty(obj, "x", "'s'");
        assertProperty(obj, "y", "3");
    }

    private TokenHandle assertNextToken(String text, TokenSequence<SelfTokenId> seq) {
        assertTrue("There is more tokens", seq.moveNext());
        Token<SelfTokenId> token = seq.token();
        assertEquals(text, token.text());
        return new TokenHandle(token);
    }

    private TokenHandle assertNextToken(SelfTokenId id, TokenSequence<SelfTokenId> seq) {
        assertTrue("There is more tokens", seq.moveNext());
        Token<SelfTokenId> token = seq.token();
        assertEquals(id, token.id());
        return new TokenHandle(token);
    }

    private static final class TokenHandle {
        private final Token<SelfTokenId> token;

        TokenHandle(Token<SelfTokenId> token) {
            this.token = token;
        }

        TokenHandle id(SelfTokenId id) {
            assertEquals(token.id(), id);
            return this;
        }

        TokenHandle text(String text) {
            assertEquals(text, token.text());
            return this;
        }
    }
}
public class SimpleTest2 {
  public static void main(String[] args) {
    int x = Integer.parseInt(args[1]);
  }
}

// # Sun-$Revision: 30.1 $
//
// Program used to test the Pep java system.
// May also be useful to test other java systems.
//
//                          Ole Agesen, June, 1996.


class syncTest {
  int x = 5;

  synchronized int syncMethod(int y) {
    x = x + y;
    return x;
  }

  synchronized int syncMethod2(int y) throws java.lang.ArithmeticException {
    x = x + y;
    if (x == 99)
      throw(new java.lang.ArithmeticException("fisk"));
    return x;
  }

  public static void main(String[] args) {
    syncTest sy = new syncTest();
    int xx = sy.syncMethod(4);
    xx = sy.syncMethod2(4);
  }
}

class StringAndInt implements Cloneable {
  String s;
  int    i;
  public java.lang.Object clone() { 
    try {
      return super.clone(); 
    } catch (java.lang.CloneNotSupportedException exc) {
      return null;
    }
  }
}

class superClass implements Cloneable {
  public int val = 1;
  public int getVal() { return val; }
  public String className() { return "superClass"; }

  public int bothVarAndMethod = 7;
  public int bothVarAndMethod()      { return 8; }
  public void bothVarAndMethod(int x) { bothVarAndMethod = x; }
}

class subClass extends superClass {
  public int val = 2;     // This field hides superclass' val field.
  public int subval = 4;
  public int getVal() { return val; }
  public String className() { return "subClass"; }
}

interface SideIntf {}
interface C2intf {}
interface C3intf extends C2intf, SideIntf {}

class C1 {
  int x1;
}

class C2 extends C1 implements C2intf {
  int x2;
}

class C3 extends C2 implements C3intf {
  int x3;
}


class PepTest {
  public int fisk;
  public boolean gotError = false;

  void helloWorld() {
    System.out.println("Hello, coffee world!");
  }

  String testDiv() {
    System.out.print("testDiv:    ");
    int a, b;
    long c, d;
    double e, f;
    a = b = 7;          if ( 1 != a / b) return "failed 1";
    a = -a;             if (-1 != a / b) return "failed 2";
    a = b = 600000000;  if ( 1 != a / b) return "failed 1.1";
    a = -a;             if (-1 != a / b) return "failed 2.1";
    c = d = 8L;         if ( 1 != c / d) return "failed 3";
    c = -c;             if (-1 != c / d) return "failed 4";
    c = d = 600000000L; if ( 1 != c / d) return "failed 3.1";
    c = -c;             if (-1 != c / d) return "failed 4.1";
    b = 0;
    try {
      a = a / b;
      return "failed 5";
    } catch (java.lang.Exception x) {
      // good.
    }
    d = 0;
    try {
      c = c / d;
      return "failed 6";
    } catch (java.lang.Exception x) {
      // good.
    }
    try {
      c = c % d;
      return "failed 6.1";
    } catch (java.lang.Exception x) {
      // good.
    }
    e = f = 7.0;
    if (1.0 != e / f) return "failed 7";
    e = -e;
    if (-1.0 != e / f) return "failed 8";
    f = 0.0;
    try {
      e = e / f;
    } catch (java.lang.Exception x) {
      return "failed 9";
    }
    try {
      e = e % f;    /* -infinity modulo 0.0 */ 
      e = 5.6 % f;  /* 5.6 module 0.0       */
    } catch (java.lang.Exception x) {
      return "failed 9";
    }
    return null;
  }

  String testIf() {
    System.out.print("testIf:     ");
    int a = 3, b, c;
    b = a;
    if(b * b == 9) 
      b = 1;
    else
      return "branched the wrong way";
    if (b != 1)
      return "didn't execute any of the branches";
    a = 0;
    b = 0;
    c = 0;
    if (a == 0)
      if (b == 0)
        c = 1;
      else
        c = 2;
    else
      if (b == 0)
        c = 3;
      else
        c = 4;
    if (c != 1)
      return "nested if failed in true/true case";
    a = 0;
    b = 1;
    c = 0;
        if (a == 0)
      if (b == 0)
        c = 1;
      else
        c = 2;
    else
      if (b == 0)
        c = 3;
      else
        c = 4;
    if (c != 2)
      return "nested if failed in true/false case";
    a = 1;
    b = 0;
    c = 0;
        if (a == 0)
      if (b == 0)
        c = 1;
      else
        c = 2;
    else
      if (b == 0)
        c = 3;
      else
        c = 4;
    if (c != 3)
      return "nested if failed in false/true case";
    a = 1;
    b = 1;
    c = 0;
        if (a == 0)
      if (b == 0)
        c = 1;
      else
        c = 2;
    else
      if (b == 0)
        c = 3;
      else
        c = 4;
    if (c != 4)
      return "nested if failed in false/false case";
    return null;
  }

  int shiftAnd(int v, int s) { return (v >>> s) & 0xFF; }

  String testBitOps() {
    /* Simple test of a few bit operations. By no means complete. */
    System.out.print("testBitOps: ");
    int v = 0xcafebabe;
    if (shiftAnd(v, 24) != 0xca) return "bad shift-and 1";
    if (shiftAnd(v, 16) != 0xfe) return "bad shift-and 2";
    if (shiftAnd(v,  8) != 0xba) return "bad shift-and 3";
    if (shiftAnd(v,  0) != 0xbe) return "bad shift-and 4";
    return null;
  }

  String testFor() {
    int s = 0;
    System.out.print("testFor:    ");
    for (int a = 0; a < 100; a++)
      for (int b = a; b >=0; b = b - 2)
        s = a + s + b;
    if (s != 252450)
      return "wrong check sum";
    return null;
  }

  String testTableSwitch() {
    System.out.print("testTableSwitch:  ");
    int s = 2, r;
    s = s * 3;
    switch(s) {
      case 0: 
      case 4: r = 0; break;
      case 1:
      case 2: r = 1; break;
      case 3:
      case 5:
      case 6: r = 3; break;
     default: r = -1;
    }
    if ( r != 3)
      return "took wrong case branch";
    s = s + 100;
    switch(s) {
      case 0: 
      case 4: r = 0; break;
      case 1:
      case 2: r = 1; break;
      case 3:
      case 5:
      case 6: r = 3; break;
     default: r = -1;
    }
    if ( r != -1)
      return "failed to take default branch";
    return null;
  }

  String testLookupSwitch() {
    System.out.print("testLookupSwitch: ");
    int s = 2, r;
    s = s * 3000;
    switch(s) {
      case 0: 
      case 4000: r = 0; break;
      case 1000:
      case 2000: r = 1; break;
      case 3000:
      case 5000:
      case 6000: r = 3; break;
     default: r = -1;
    }
    if ( r != 3)
      return "took wrong case branch";
    s = s + 999999999;
    switch(s) {
      case 0: 
      case 4000: r = 0; break;
      case 1000:
      case 2000: r = 1; break;
      case 3000:
      case 5000:
      case 6000: r = 3; break;
     default: r = -1;
    }
    if ( r != -1)
      return "failed to take default branch";
    return null;
  }

  String testHiddenField() {
    System.out.print("testHiddenField:  ");
    subClass f2 = new subClass();
    superClass f1 = f2;
    if (f1.val != 1) 
      return "direct access to field defined by superclass failed";
    if (f2.val != 2) 
      return "direct access to field defined by subclass failed";
    if (f1.getVal() != 2) 
      return "access through method to field defined by superclass failed";
    if (f2.getVal() != 2) 
      return "access through method to field defined by subclass failed";
    return null;
  }

  void printTime() {
    java.util.Date now = new java.util.Date();
    System.out.print("Time now is ");
    System.out.print(now.toString());
    System.out.print(",   ms: ");
    System.out.println(System.currentTimeMillis());
  }

  void printProperty(String prop) {
    System.out.println("  " + prop + " = " + System.getProperty(prop));
  }

  void printProperties() {
    System.out.println("Properties:");
    printProperty("java.version");
    printProperty("java.vendor");
    printProperty("java.vendor.url");
    printProperty("java.home");
    printProperty("java.class.version");
    printProperty("java.class.path");
    printProperty("os.name");
    printProperty("os.version");
    printProperty("os.arch");
    printProperty("file.separator");
    printProperty("path.separator");
    printProperty("line.separator");
    printProperty("user.name");
    printProperty("user.home");
    printProperty("user.dir");
  }

  String checkInst(superClass x, boolean r1, boolean r2, boolean r3, int c) {
    return checkInst2(x, r1, x instanceof superClass, "superClass") +
           checkInst2(x, r2, x instanceof subClass,   "subClass") + 
           checkInst2(x, r3, x instanceof Cloneable,  "Cloneable");
  }

  String checkInst2(superClass x, boolean expected, boolean got, String cn) {
    if (expected == got) return "";
    return "Failed: 'a " + x.getClass().getName() + "' instanceof " +
           cn + " (returned: " + got + ", should be: " + expected + ")\n";
  }

  String checkInstanceOf() {
    System.out.print("checkInstanceOf: ");

 /* subClass a[] = new subClass[2];
    ((superClass[])a)[1] = new superClass(); */

    if (!((new superClass[2]) instanceof superClass[]))
      return "failed: new superClass[2]) instanceof superClass[]";

    if (!((new subClass[2]) instanceof superClass[]))
      return "failed: new subClass[2]) instanceof superClass[]";

    if ((new superClass[2]) instanceof subClass[])
      return "failed: new superClass[2]) instanceof subClass[]";

    if ((new Object[2]) instanceof subClass[])
      return "failed: new Object[2]) instanceof subClass[]";

    if (!((new subClass[2]) instanceof Cloneable[]))
      return "failed: new subClass[2]) instanceof Cloneable[]";

    return checkInst(null,             false, false, false, 1) + 
           checkInst(new superClass(), true,  false, true,  2)  + 
           checkInst(new subClass(),   true,  true,  true,  3);
  }

  String checkInterfaceInstanceOf() {
    System.out.print("checkInterfaceInstanceOf: ");
    java.lang.Object c1 = new C1();
    java.lang.Object c2 = new C2();
    java.lang.Object c3 = new C3();
    if (!(c1 instanceof C1)) return "checkInterfaceInstanceOf: error-1";
    if ( (c1 instanceof C2)) return "checkInterfaceInstanceOf: error-2";
    if ( (c1 instanceof C3)) return "checkInterfaceInstanceOf: error-3";
    if (!(c2 instanceof C1)) return "checkInterfaceInstanceOf: error-4";
    if (!(c2 instanceof C2)) return "checkInterfaceInstanceOf: error-5";
    if ( (c2 instanceof C3)) return "checkInterfaceInstanceOf: error-6";
    if (!(c3 instanceof C1)) return "checkInterfaceInstanceOf: error-7";
    if (!(c3 instanceof C2)) return "checkInterfaceInstanceOf: error-8";
    if (!(c3 instanceof C3)) return "checkInterfaceInstanceOf: error-9";
    
    if ( (c1 instanceof C2intf))   return "checkInterfaceInstanceOf: error-10";
    if ( (c1 instanceof C3intf))   return "checkInterfaceInstanceOf: error-11";
    if ( (c1 instanceof SideIntf)) return "checkInterfaceInstanceOf: error-12";
    if (!(c2 instanceof C2intf))   return "checkInterfaceInstanceOf: error-13";
    if ( (c2 instanceof C3intf))   return "checkInterfaceInstanceOf: error-14";
    if ( (c2 instanceof SideIntf)) return "checkInterfaceInstanceOf: error-15";
    if (!(c3 instanceof C2intf))   return "checkInterfaceInstanceOf: error-16";
    if (!(c3 instanceof C3intf))   return "checkInterfaceInstanceOf: error-17";
    if (!(c3 instanceof SideIntf)) return "checkInterfaceInstanceOf: error-18";
    return null;
  }

  String testExc1() {
    System.out.print("testExc1(simple throw/catch):  ");
    int x = 0;
    try {
      if (x == 0) x = 1; else x = -1;
      if (x != 47) throw(new java.lang.ArithmeticException("fisk"));
      x = -1;
    } catch (java.lang.ArithmeticException exc) {
      if (x == 1) x = 2; else x = -1;
    }
    if (x == 2) 
      return null;
    else 
      return "failed";
  }

  String testExc2() {
    System.out.print("testExc2(skip catch clauses):  ");
    int x = 0;
    try {
      if (x == 0) x = 1; else x = -1;
      if (x != 47) throw(new java.lang.RuntimeException("fisk"));
      x = -1;
    } catch (java.lang.ArithmeticException exc) {
      x = -1;
    } catch (java.lang.AbstractMethodError exc) {
      x = -1;
    } catch (java.lang.RuntimeException exc) {
      if (x == 1) x = 2; else x = -1;
    }
    if (x == 2) 
      return null;
    else 
      return "failed";
  }

  String testExc3() {
    System.out.print("testExc3(catch in inner):      ");
    int x = 0;
    try {
      if (x == 0) x = 1; else x = -1;
      try {
        if (x != 1) x = -1; else x = 2;
        if (x != 47) 
          throw(new java.lang.ArithmeticException("fisk")); 
        else {
          return "failed-1";
        }
      } catch (java.lang.ArithmeticException exc) {
        if (x != 2) x = -1; else x = 3;
      }
    } catch (java.lang.ArithmeticException exc) {
      x = -1;
    }
    if (x == 3)
      return null;
    else
      return "failed-2";
  }

  String testExc4() {
    System.out.print("testExc4(catch in outer):      ");
    int x = 0;
    try {
      if (x == 0) x = 1; else x = -1;
      try {
        if (x != 1) x = -1; else x = 2;
        if (x != 47) throw(new java.lang.RuntimeException("fisk"));
      } catch (java.lang.ArithmeticException exc) {
        x = -1;
      }
    } catch (java.lang.RuntimeException exc) {
      if (x != 2) x = -1; else x = 3;
    }
    if (x == 3)
      return null;
    else
      return "failed";
  }

  String testExc5() {
    System.out.print("testExc5(rethrow):             ");
    int x = 0;
    try {
      if (x == 0) x = 1; else x = -1;
      try {
        if (x != 1) x = -1; else x = 2;
        if (x != 47) throw(new java.lang.ArithmeticException("fisk"));
      } catch (java.lang.ArithmeticException exc) {
        if (x != 2) x = -1; else x = 3;
        throw exc;
      }
    } catch (java.lang.ArithmeticException exc) {
      if (x != 3) x = -1; else x = 4;
    }
    if (x == 4)
      return null;
    else
      return "failed";
  }

  String testExc6() {
    System.out.print("testExc6(throw accross call):  ");
    int x = 0;
    try {
      x = 1;
      throwArithmeticException(1);
      x = 2;
    } catch (java.lang.ArithmeticException exc) {
      if (x != 1) x = -1; else x = 4;
    }
    if (x == 4)
      return null;
    else
      return "failed";
  }

  String testExc7() {
    System.out.print("testExc7(throw accr. 2 calls): ");
    int x = 0;
    try {
      x = 1;
      x = dontDouble(x);
      x = 2;
    } catch (java.lang.ArithmeticException exc) {
      if (x != 1) x = -1; else x = 4;
    }
    if (x == 4)
      return null;
    else
      return "failed";
  }

  String stringHash(String str, int expected) {
    if (str.hashCode() != expected) 
      return "unexpected string hash value for '" + str + "': " + 
             str.hashCode() + " (expected: " + expected + ")";
    return null;
  }
  

  String testStringHash() {
    System.out.print("testStringHash:  ");
    String res;
    if (null != (res = stringHash("monkey", -817689237)))  return res;
    if (null != (res = stringHash("donkey", -1441784850))) return res;
    if (null != (res = stringHash("Lavazza",  84343969)))  return res;
    if (null != (res = 
          stringHash("and a longer string with many words 123454876*=+-_%$$@",
                     47854477))) return res;
    return null;
  }


  String testObjectHash() {
    System.out.print("testObjectHash:  ");
    java.util.Hashtable ht = new java.util.Hashtable();
    Integer ii;
    for (int i = 0; i < 1000; i++) {
        ii = new Integer(new syncTest().hashCode());
        ht.put(ii, ii);
    }
    if (ht.size() < 700) {
        return "Hash codes not very unique; out of 1000 got only " +
               ht.size() + " unique";
    }
    return null;
  }

  String loopExitContinueInExceptionHandler() {
    System.out.print("loopExitContinueInExceptionHandler: ");
    int i = 0;
    while(i < 10000) {
      i++;
      try {
        if (i % 100 == 0) 
          throw(new java.lang.ArithmeticException("fisk"));
        if (i == 9990) 
          break;
        if (i % 2 == 0)
          continue;
      } catch (java.lang.ArithmeticException e) {
        if (i %2 != 0) 
          return "Should not throw odd exceptions!";
      }
    }
    if (i != 9990)
      return "Seems that break didn't work";
    return null;
  }

  String testClone() {
    System.out.print("testClone:       ");
    int[] w, v = new int[100];   /* Check that we can clone arrays. */
    for (int i = 0; i < v.length; i++) v[i] = i * i;
    w = (int[])v.clone();
    if (v.length != w.length) return "Clone of int array failed (length)";
    for (int i = 0; i < w.length; i++) 
        if (w[i] != i * i) return "Clone of int array failed-" + i;
    java.util.Hashtable ht = new java.util.Hashtable(31);
    if (ht.clone() == ht) return "Clone failed on hash tables";

    boolean caught = false;
    try {
      ht = null;
      ht.clone();
    } catch (java.lang.NullPointerException gotIt) {
      caught = true;
    }
    if (!caught) return "failed to catch exception from null.clone()";

    StringAndInt s1 = new StringAndInt();
    s1.s = "goat";
    s1.i = 5;
    StringAndInt s2 = (StringAndInt)s1.clone();
    if (s1 == s2)             return "clone returned same object";
    if (!s2.s.equals("goat")) return "clone didn't get the goat there";
    if (s2.i != 5)            return "clone didn't get the 5 there";
    if (!s1.s.equals("goat")) return "clone messed up receiver: goat";
    if (s1.i != 5)            return "clone messed up receiver: 5";
    return null;
  }

  String checkClassNameOf(String exp, Object obj, String expected) {
    if (expected.equals(obj.getClass().getName())) return null;
    return "Error: className(" + exp + ") = " + obj.getClass().getName() + 
           ", should be = " + expected;
  }

  void printInterfaces(java.lang.Class cl) {
    System.out.print(cl.getName() + ":  ");
    java.lang.Class intf[] = cl.getInterfaces();
    for (int i = 0; i < intf.length; i++) {
      System.out.print(intf[i].getName() + " ");
      if (!intf[i].isInterface())
        System.out.println("Error: should have been an interface!");
    }
    if (0 == intf.length) 
      System.out.print("no interfaces");
    System.out.println();
  }

  String testClass() {
    String r;
    r = checkClassNameOf("double[][]", new double[2][3], "[[D");
    if (r != null) return r;
    r = checkClassNameOf("7", new Integer(7), "java.lang.Integer");
    if (r != null) return r;
    r = checkClassNameOf("horse", this, "PepTest");
    if (r != null) return r;
    r = checkClassNameOf("new PepTest[2]", new PepTest[2], "[LPepTest;");
    if (r != null) return r;
    r = checkClassNameOf("new PepTest[2][2]", new PepTest[2][2], "[[LPepTest;");
    if (r != null) return r;
    r = checkClassNameOf("java.util.Hashtable", new java.util.Hashtable(),
                         "java.util.Hashtable");
    if (r != null) return r;

    PepTest fisk[] = new PepTest[2];
    if (fisk.getClass().getInterfaces().length != 0)
       return "Error: array class should not have interfaces";
    printInterfaces(fisk.getClass());
    int caught = 0;
    try {
      printInterfaces(null);
    } catch (NullPointerException fff) {
      caught = 1;
    }
    if (caught != 1)
      return "Error: null pointer exception not caught";
    Class cl = (new java.util.Hashtable()).getClass();
    while (cl != null) {
      printInterfaces(cl);
      cl = cl.getSuperclass();
    }
    return null;
  }

  String testWaitNull() {
    System.out.print("testWaitNull: ");
    try {
      ((java.lang.Object)null).wait(43);
    } catch (java.lang.Exception e) {
      if(e.getClass().getName().equals("java.lang.NullPointerException")) 
        return null;
      return "error: " + e;
    }
    return "error: missing exception";
  }

  String testVarAndMethodNameClash() {
    System.out.print("testVarAndMethodNameClash: ");
    superClass s = new superClass();
    int x;

    x = s.bothVarAndMethod;
    if (x != 7) 
      return "1: Var has wrong value: " + x;

    x = s.bothVarAndMethod();
    if (x != 8)
      return "1: Method returned wrong value: " + x;

    s.bothVarAndMethod = 9;
    x = s.bothVarAndMethod;
    if (x != 9) 
      return "2: Var has wrong value: " + x;

    x = s.bothVarAndMethod();
    if (x != 8)
      return "2: Method returned wrong value: " + x;

    s.bothVarAndMethod(5);
    x = s.bothVarAndMethod;
    if (x != 5)
      return "3: Var has wrong value: " + x;

    x = s.bothVarAndMethod();
    if (x != 8)
      return "3: Method returned wrong value: " + x;

    return null;
  }

  void timeExceptions() {
    System.out.print("Timing exception handling: ");
    long t1 = System.currentTimeMillis();
    for (int i = 0; i < 10000; i++) {
      try {
        int x = 4;
        x = x + x;
      } catch (java.lang.ClassCastException e) {
        System.out.println("Huh? Exception should not have occurred");
      }
    }
    long t2 = System.currentTimeMillis();
    System.out.println((t2 - t1) + " ms");
  }

  void checkAllNull(java.lang.Object a[]) {
    for (int i = 0; i < a.length; i++) {
      if (a[i] != null) System.out.println("error: should have been null");
    }
  }

  String testObjectArray() {
    System.out.print("testObjectArray: ");
    subClass   a[] = new   subClass[10];
    superClass b[] = new superClass[10];

    if (!(a instanceof subClass[]))         return "array instanceof-1 failed";
    if (!(a instanceof superClass[]))       return "array instanceof-2 failed";
    if (!(a instanceof java.lang.Object[])) return "array instanceof-3 failed";

    if ( (b instanceof subClass[]))         return "array instanceof-4 failed";
    if (!(b instanceof superClass[]))       return "array instanceof-5 failed";
    if (!(b instanceof java.lang.Object[])) return "array instanceof-6 failed";

    for (int i = 0; i < 10; i++) {
      a[i] = new   subClass();
      b[i] = new superClass();
    }
    b[4] = a[1];
    b[5] = null;
    a[2] = (subClass)b[4];
    a[2] = (subClass)b[5];
    try {
      a[2] = (subClass)b[7];
    } catch (java.lang.ClassCastException e) {
      if (!e.getMessage().equals("superClass"))
        return "unexpected exception: " + e;
    }
    java.lang.System.arraycopy(a,0,b,0,10);
    for (int i = 0; i < 10; i++)
      a[i] = null;
    java.lang.System.arraycopy(a,0,b,0,10);
    checkAllNull(b);
    java.lang.System.arraycopy(b,0,a,0,10);
    checkAllNull(a);
    checkAllNull(b);

    a[4] = new subClass();
    java.lang.System.arraycopy(b,0,a,0,10);
    checkAllNull(a);
    checkAllNull(b);

    boolean caught;

    caught = false;
    try {
      java.lang.System.arraycopy(null,0,a,0,10);
    } catch(java.lang.NullPointerException e) {
      caught = true;
    }
    if (!caught) return "error: should have caught exception-1";

    caught = false;
    try {
      java.lang.System.arraycopy(b,0,null,0,10);
    } catch(java.lang.NullPointerException e) {
      caught = true;
    }
    if (!caught) return "error: should have caught exception-2";

    caught = false;
    try {
      java.lang.System.arraycopy(b,0,a,0,11);
    } catch(java.lang.ArrayIndexOutOfBoundsException e) {
      caught = true;
    }
    if (!caught) return "error: should have caught exception-3";

    caught = false;
    try {
      java.lang.System.arraycopy(b,1,a,0,10);
    } catch(java.lang.ArrayIndexOutOfBoundsException e) {
      caught = true;
    }
    if (!caught) return "error: should have caught exception-4";

    caught = false;
    try {
      java.lang.System.arraycopy(b,-1,null,100,100);
    } catch(java.lang.NullPointerException e) {
      caught = true;
    }
    if (!caught) return "error: should have caught exception-5";

    b[5] = new superClass();
    caught = false;
    try {
      java.lang.System.arraycopy(b,0,a,0,10);
    } catch(java.lang.ArrayStoreException e) {
      caught = true;
    }
    if (!caught) return "error: should have caught exception-6";

    return null;
  }

  int dontDouble(int a) {
    throwArithmeticException(a);
    return 2 * a;
  }

  void throwArithmeticException(int a) {
    if (a == 1)
      throw(new java.lang.ArithmeticException("fisk"));
    if (a == 1)
      System.out.println("should not print this");
    else
      System.out.println("should print this");
  }

  int testDup() {
    int a, b;
    a = b = 7;
    return a;
  }

  int testForLoop(int x, int y) {
     int a = 0;
     for (int i=x; i < y; i++)
       a += i*i;
     return a;
  }


  static subClass staticSubArray[][] = {{null,null}, {null,null}};
  static int      staticIntArray[][] = {{1,2,3}, {4,5,6}};

  String testArray() {
    System.out.print("testArray:  ");
    int x[];
    x = new int[6];
    x[4] = 3;
    x[3] = x[4];
    if (x[3] != 3) return "got bad array value-";

    double y[][];
    y = new double[5][6];
    y[1][2] = 3.0;
    if (y[1][2] != 3.0) return "got bad array value-2";

    java.util.Stack fisk[][][] = new java.util.Stack[4][][];
    if (fisk[2] != null)
      return "bad array initialization";
    return null;
  }

  boolean isPrime(int i) {
    if (i == 2) 
      return true;
    if (i % 2 == 0) 
      return false;
    int j = 3;
    while (j * j <= i) {
      if (i % j == 0)
        return false;
      j = j + 2;
    }
    return true;
  }

  void printPrimes() {
    System.out.print("Primes less than 50: ");
    for (int i = 2; i < 50; i++) {
      if (isPrime(i)) {
        System.out.print(i);
        System.out.print(" ");
      }
    }
    System.out.println("");
  }

  public void Verify(String str) {
    if (null == str || str.equals(""))
      System.out.println("OK");
    else {
      gotError = true;
      System.out.println();
      System.out.println("******************************************");
      System.out.println("******************************************");
      System.out.println(str);
      System.out.println("******************************************");
      System.out.println("******************************************");
    }
  }

  boolean checkRemL(long a, long b, long res) {
    boolean ok = (res == a % b);
    if (!ok) {
      System.out.print("Failed: " + a + " % " + b + " = " + (a % b));
      System.out.println("   (should be: " + res);
    }
    return ok;
  }

  boolean checkRemD(double a, double b, double res) {
    boolean ok = (res == a % b);
    if (!ok) {
      System.out.print("Failed: " + a + " % " + b + " = " + (a % b));
      System.out.println("   (should be: " + res);
    }
    return ok;
  }


  void printRemD(double a, double b) {
    System.out.print(a + " % " + b + " = " + (a % b));
  }

  String checkRemainders() {
    System.out.print("checkRemainders: ");
    boolean ok = true;
    System.out.print(" long ");
    if (!checkRemL( 10L,  7L, 3L))  ok = false;
    if (!checkRemL( 10L, -7L, 3L))  ok = false;
    if (!checkRemL(-10L,  7L, -3L)) ok = false;
    if (!checkRemL(-10L, -7L, -3L)) ok = false;

    if (!checkRemD( 10.5,  7.0, 3.5))  ok = false;
    if (!checkRemD( 10.5, -7.0, 3.5))  ok = false;
    if (!checkRemD(-10.5,  7.0, -3.5)) ok = false;
    if (!checkRemD(-10.5, -7.0, -3.5)) ok = false;
    if (!ok) return "remainders failed";
    System.out.print("double ");
    return null; 
  }

  boolean checkClose(String exprStr, double v, double r) {
    double m, av = v, ar = r;
    if (av < 0.0) av = -av;
    if (ar < 0.0) ar = -ar;
    if (av > ar) 
      m = av; 
    else 
      m = ar;
    if (m == 0.0) m = 1.0;
    if ((v - r) / m > 0.0001) {
      System.out.println(exprStr + " evaluated to: " + v + ", expected: " + r);
      return false;
    }
    return true;
  }
    
  String checkMathFcts() {
    System.out.print("checkMathFcts: ");
    boolean ok = true; 
    if (!checkClose("log(0.7)",  Math.log(0.7),  -0.356675)) ok = false;
    if (!checkClose("sin(0.7)",  Math.sin(0.7),   0.644218)) ok = false;
    if (!checkClose("cos(0.7)",  Math.cos(0.7),   0.764842)) ok = false;
    if (!checkClose("tan(0.7)",  Math.tan(0.7),   0.842288)) ok = false;
    if (!checkClose("asin(0.7)", Math.asin(0.7),  0.775397)) ok = false;
    if (!checkClose("acos(0.7)", Math.acos(0.7),  0.795399)) ok = false;
    if (!checkClose("atan(0.7)", Math.atan(0.7),  0.610726)) ok = false;
    if (!ok) return "Some math function failed";
    return null;
  }

  void doIntWhileLoop() {
    int a = 0;
    while (a != 100000) {
      a++;
    }
  }

  void doLongWhileLoop() {
    long a = 0;
    while (a != 100000) {
      a++;
    }
  }

  void timeWhileLoops() {
    long t1, t2;
    System.out.print("Time for 100,000 iterations of " +
                     "while loop: int: ");
    t1 = System.currentTimeMillis();
    doIntWhileLoop();
    t2 = System.currentTimeMillis();
    System.out.print((t2 - t1) + " ms, long: ");

    t1 = System.currentTimeMillis();
    doLongWhileLoop();
    t2 = System.currentTimeMillis();
    System.out.println((t2 - t1) + " ms");
  }

  String fiskString() {
    return "fisk";
  }

  int deepRecursion(int n, int sum) {
    int s;
    if (n == 0) return sum;
    return deepRecursion(n - 1, n + sum);  /* Hopefully javac won't elim.
                                              tail recursion. */
  }
   
  String testDeepStack() {
    System.out.print("testDeepStack: ");
    if (deepRecursion(5555, 0) != (5555 * 5555 + 5555) / 2) return "failed";
    return null;
  }

  String testMisk() {
    System.out.print("testMisk: ");
    String right = "-9223372036854775808";
    if (!right.equals("" + ((long)1 << 63)))
      return "(long)1 << 63 failed, returned: " + ((long)1 << 63) +
             ", should be: " + right;
    if (-1L != (-1L & -1L))
      return "Logical and failed for longs";
    if (getClass().getName() == (new PepTest()).getClass().getName())
      return "Error(1): strings should not be identical!";
    String str1, str2;
    str1 = "fisk";
    str2 = "fisk";
    if (str1 != str2)
      return "Error(2): strings should be identical!";
    if (fiskString() != fiskString())
      return "Error(3): strings should be identical!";
    try {
      str1 = "java.lang.Thread";
      if (!str1.equals(java.lang.Class.forName(str1).getName())) 
        return "Error(4): strings should be equal!";
      if (str1 == java.lang.Class.forName(str1).getName()) 
        return "Error(5): strings should not be identical!";
    } catch(java.lang.Exception gotIt) {}
    return null;
  }

  String testGC() {
    System.out.print("testGC: ");
    byte[][] bytesArrays = new byte[1000][];
    bytesArrays[0] = new byte[1000];  /* See if GC eats this array! */
    Runtime.getRuntime().gc();
    if (!bytesArrays[0].getClass().getName().equals("[B"))
      return "GC swallowed a live object!";    /* Will fail here then. */
    String cn = getClass().getName(); /* Force construction of class object. */
    Runtime.getRuntime().gc();
    /* See if the GC spoled the class object. */
    if (!cn.equals(getClass().getName())) return "got different class name";
    java.lang.System.getProperty("file.encoding");  /* Fails if GC swallowed
                                                       props; it did happen! */
    return null;
  }

  void timeIO() {
    try {
      System.out.print("Timing IO. ");
      long t1, t2;
      byte b[] = {0};
      System.out.print("write(1 byte): ");
      t1 = System.currentTimeMillis();
      java.io.FileOutputStream out = new java.io.FileOutputStream("/dev/null");
      for (int i = 0; i < 10000; i++)
        out.write(b);
      out.close();
      t2 = System.currentTimeMillis();
      System.out.print("" + (t2 - t1) + " ms");

      System.out.print(", read(1 byte): ");
      t1 = System.currentTimeMillis();
      java.io.FileInputStream in = new java.io.FileInputStream("/etc/termcap");
      for (int i = 0; i < 10000; i++)
        in.read(b);
      in.close();
      t2 = System.currentTimeMillis();
      System.out.print("" + (t2 - t1) + " ms");
      System.out.println();
    } catch (java.io.IOException e) {}
  }

  void timeDateToString() {
    System.out.print("Timing java.util.Date::toString: ");
    long t1 = System.currentTimeMillis();
    java.util.Date now = new java.util.Date();
    for (int i = 0; i < 50; i++) {
      String s = now.toString();
    }
    long t2 = System.currentTimeMillis();
    System.out.println("" + (t2 - t1) + " ms");
  }

  public void instanceMain(String[] args) {
    // System.out.println(Math.random());  Fails -- our floats are too small.
    java.util.Random rnd = new java.util.Random();
    System.out.println(rnd.nextFloat());
    System.out.println(rnd.nextFloat());
    System.out.println(rnd.nextFloat());
    // Runtime.getRuntime().traceMethodCalls(true);
    helloWorld();
    printTime();
    printProperties();
    Verify(testIf());
    Verify(testArray());
    Verify(testBitOps());
    Verify(testFor());
    Verify(testDiv());   // breaks jit; comment out for jit's sake!
    Verify(testTableSwitch());
    Verify(testLookupSwitch());
    Verify(testHiddenField());
    Verify(checkRemainders());
    Verify(checkMathFcts());
    printPrimes();
    timeWhileLoops();
    Verify(testExc1());
    Verify(testExc2());
    Verify(testExc3());
    Verify(testExc4());
    Verify(testExc5());
    Verify(testExc6());
    Verify(testExc7());
    Verify(loopExitContinueInExceptionHandler());
    Verify(testStringHash());
    Verify(testObjectHash());
    Verify(testClone());
    Verify(testObjectArray());
    testClass();
    Verify(checkInstanceOf());
    Verify(checkInterfaceInstanceOf());
    Verify(testWaitNull());
    Verify(testVarAndMethodNameClash());
    Verify(testDeepStack());
    Verify(testMisk());
    Verify(testGC());
    timeExceptions();
    timeIO();
    timeDateToString();
    if (gotError)
      System.out.println("****** PepTest found an error ******");
    else
      System.out.println("****** PepTest completed successfully ******");
  }

  public static void main(String[] args) {
    PepTest horse = new PepTest();
    horse.instanceMain(args);
    if (horse.gotError) System.exit(1);
  }
}
class SimpleTest1 {
  public static void main(String[] args) {
    System.out.println("Hello");
  }
}

import java.awt.*;
import java.applet.Applet;
import java.io.*;
import java.net.*;
import java.util.*;
//-------------------------------------------------------------------------
// Kansas Java interface -- bringing Kansas to the Web
//
//   LensRadarViewer.java - the fish eye radar view Browser Core
//
// $Revision: 30.1 $
//      Andy Collins, Sun Microsystems Laboratories, Summer 1996
//-------------------------------------------------------------------------


class LensRadarObject extends SelfRadarObject
{
   public LensRadarObject (SelfObjectState objectState)
   {
      super (objectState);
   }

   public void paint (Graphics g, Point logicalCenter, Point screenCenter, int innerRadius)
   {
      int Xs[] = new int[13];
      int Ys[] = new int[13];
      boolean lastWasIn = false;
      boolean thisIsIn;
      int radius;

      Point input[] = new Point[5];
      input[0] = new Point (rect.x, rect.y);
      input[1] = new Point (rect.x + rect.width, rect.y);
      input[2] = new Point (rect.x + rect.width, rect.y + rect.height);
      input[3] = new Point (rect.x, rect.y + rect.height);
      input[4] = new Point (rect.x, rect.y);

      int outputIndex = 0;
      for (int inputIndex = 0; inputIndex < 5; ++inputIndex)
         {
         radius = (int) Math.sqrt ((input[inputIndex].x - logicalCenter.x) * (input[inputIndex].x - logicalCenter.x) + 
                                   (input[inputIndex].y - logicalCenter.y) * (input[inputIndex].y - logicalCenter.y));
         thisIsIn = (radius < innerRadius);
         if (inputIndex > 0)
            {
            int x1 = input[inputIndex-1].x - logicalCenter.x;
            int y1 = input[inputIndex-1].y - logicalCenter.y;
            int x2 = input[inputIndex].x   - logicalCenter.x;
            int y2 = input[inputIndex].y   - logicalCenter.y;

            long A = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            long B = 2 * x1 * (x2 - x1) + 2 * y1 * (y2 - y1);
            long C = x1 * x1 + y1 * y1 - innerRadius * innerRadius;

            double discrim = (double) (B * B) - 4.0 * A * C;

//            System.out.println ("A = " + A + "; B = " + B + "; C = " + C + "; discrim = " + discrim);

            if (discrim >= 0)
               {
               double s1 = (-B + Math.sqrt (discrim)) / (2.0 * A);
               double s2 = (-B - Math.sqrt (discrim)) / (2.0 * A);

               if (s1 > s2)
                  {
                  double tmp = s1;
                  s1 = s2;
                  s2 = tmp;
                  }

//               System.out.println ("Positive discrim, roots are: " + s1 + ", " + s2);

               if ((s1 > 0.0) && (s1 < 1.0))
                  {
                  Xs[outputIndex] = x1 + (int) (s1 * (x2 - x1)) + screenCenter.x;
                  Ys[outputIndex] = y1 + (int) (s1 * (y2 - y1)) + screenCenter.y;
                  ++outputIndex;
                  }

               if ((s2 > 0.0) && (s2 < 1.0))
                  {
                  Xs[outputIndex] = x1 + (int) (s2 * (x2 - x1)) + screenCenter.x;
                  Ys[outputIndex] = y1 + (int) (s2 * (y2 - y1)) + screenCenter.y;
                  ++outputIndex;
                  }

               }
            }

         // Emit this point (after possible conversion)
         if (thisIsIn)
            {
            Xs[outputIndex] = input[inputIndex].x - logicalCenter.x + screenCenter.x;
            Ys[outputIndex] = input[inputIndex].y - logicalCenter.y + screenCenter.y;
            ++outputIndex;
            }
         else
            {
            double power = 0.7;
            double recip = 1.0 / power;
            int newRadius = (int) (innerRadius - recip + recip * Math.pow (radius - innerRadius + 1, power));
            double shrinkFactor = ((double) newRadius) / radius;

            Xs[outputIndex] = (int) ((input[inputIndex].x - logicalCenter.x) * shrinkFactor) + screenCenter.x;
            Ys[outputIndex] = (int) ((input[inputIndex].y - logicalCenter.y) * shrinkFactor) + screenCenter.y;
            ++outputIndex;
            }

         lastWasIn = thisIsIn;
         }

      g.setColor (color);
      g.fillPolygon (Xs, Ys, outputIndex);
/*
      for (int inputIndex=0; inputIndex < 4; ++inputIndex)
         {
         Xs[inputIndex] = input[inputIndex].x - logicalCenter.x + screenCenter.x;
         Ys[inputIndex] = input[inputIndex].y - logicalCenter.y + screenCenter.y;
         }

      Xs[4] = Xs[0];
      Ys[4] = Ys[0];

      g.setColor (Color.black);
      g.drawPolygon (Xs, Ys, 5);
*/
   }
}

class LensRadarViewerBrowserCore extends BrowserCore
{
   String hostname = "localhost";
   int port = 1420;

   Thread runThread = null;

   Socket downlinkSocket = null;
   public StreamTokenizer downlinkStream;

   Hashtable objects;

   LensRadarViewerBrowserCore (BrowserPanel browser, BailInOut bailoutPt,
                               String hostname, int port, double innerRadiusFactor)
   {
      super (browser, bailoutPt);
      this.innerRadiusFactor = innerRadiusFactor;
      this.hostname = hostname;
      this.port = port;
   }

   double innerRadiusFactor = 0.6;

   public void bailin ()
   {
      System.out.println ("RadarViewerBrowserCore.bailin (): " + Thread.currentThread ().hashCode ());
      objects = new Hashtable ();

      try 
         {
         // open the downlink socket (and follow the Self server . protocol)
         downlinkSocket = new Socket (hostname, port);
         DataOutputStream downlinkBackStream = 
                        new DataOutputStream (downlinkSocket.getOutputStream ());
         downlinkBackStream.writeBytes ("<radarview>\r\n");
         downlinkBackStream.flush ();
         downlinkStream = new StreamTokenizer (downlinkSocket.getInputStream ());
         downlinkStream.ordinaryChar (39);
         downlinkStream.wordChars (60, 62);
         downlinkStream.eolIsSignificant (false);
         downlinkStream.parseNumbers ();

         if (runThread != null)
            runThread.stop ();
         runThread = new LensRadarViewMonitor (this, ownerBrowser, bailoutPoint);
         runThread.start ();
         }
      catch (IOException e)
         {
         System.out.println ("Radarview initialization failure, closing down");
         bailoutPoint.bailout ();
         }      
   }

   public synchronized void bailout ()
   {
      System.out.println ("RadarViewerBrowserCore.bailout (): " + Thread.currentThread ().hashCode ());
      
      if (runThread == Thread.currentThread ())
         System.out.println ("  runThread is currentThread");

      try 
         {
         if (downlinkSocket != null)
            downlinkSocket.close ();
         }
      catch (IOException e)
         {
         }

      if (runThread != null)
         {
         System.out.println ("  Killing thread - " + runThread.hashCode ());
         runThread.stop ();
         runThread = null;
         }
      else
         System.out.println ("  Thread is already dead");

      System.out.println ("  returning");
   }

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   public void paint (Graphics g, Rectangle region)
   {
      if (objects == null)
         return;

      int xr = ownerBrowser.getViewSize ().width / 2;
      int yr = ownerBrowser.getViewSize ().height / 2;
      double radius = Math.sqrt (xr * xr + yr * yr);
      Point logicalCenter = new Point (ownerBrowser.getViewOrigin ().x + xr,
                                       ownerBrowser.getViewOrigin ().y + yr);
      Point screenCenter = new Point (ownerBrowser.getViewSize ().width / 2,
                                      ownerBrowser.getViewSize ().height / 2);
      Enumeration e = objects.elements ();
      while (e.hasMoreElements ())
         ((LensRadarObject) e.nextElement ()).paint (g, logicalCenter, screenCenter,
                                                     (int) (innerRadiusFactor * radius));
/*
      g.setColor (new Color (0xFF000000));  // alpha = FF
      g.fillArc (screenCenter.x - (int) (radius * innerRadiusFactor), screenCenter.y - (int) (radius * innerRadiusFactor),
                 2 * (int) (radius * innerRadiusFactor), 2 * (int) (radius * innerRadiusFactor), 0, 360);
*/
   }

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   public void notifyViewChanged ()
   {
      ownerBrowser.redrawRect (new Rectangle (ownerBrowser.getViewOrigin ().x,
                                              ownerBrowser.getViewOrigin ().y,
                                              ownerBrowser.getViewSize ().width,
                                              ownerBrowser.getViewSize ().height));
      ownerBrowser.issueRepaint ();
      Thread.yield ();
   }
}

class LensRadarViewMonitor extends Thread
{
   LensRadarViewerBrowserCore browser;
   Browser ownerBrowser;
   BailInOut bailoutPoint;

   public LensRadarViewMonitor (LensRadarViewerBrowserCore browser, Browser ownerBrowser, BailInOut bailoutPoint)
   {
      this.browser = browser;
      this.ownerBrowser = ownerBrowser;
      this.bailoutPoint = bailoutPoint;
   }

   public void run ()
   {
      String keyName;
      SelfObjectState objectState = new SelfObjectState ();

      Thread.yield ();

      for (;;)
         {
            try
               {
               browser.downlinkStream.nextToken ();

               if (browser.downlinkStream.ttype == StreamTokenizer.TT_WORD)
                  {
                  keyName = browser.downlinkStream.sval;
            
                  if (keyName == null)
                     System.out.println ("!!!!!");

                  browser.downlinkStream.nextToken ();

                  if (browser.downlinkStream.ttype == StreamTokenizer.TT_NUMBER)
                     objectState.setValue (keyName, browser.downlinkStream.nval);
                  else if ((browser.downlinkStream.ttype == StreamTokenizer.TT_WORD) ||
                           (browser.downlinkStream.ttype == '\"'))
                     objectState.setValue (keyName, browser.downlinkStream.sval);
                  else
                     {
                     System.out.println ("Unexpected second token following " + keyName + 
                                         ": type is " + browser.downlinkStream.ttype);
                     }
/* 
                  try
                     {
                     System.out.println (keyName + " " + objectState.getStringValue (keyName));
                     }
                  catch (SelfMissingStateException e)
                     {
                     }
*/
                  // Is this a complete object update, if so, it will end with "o"
                  if (keyName.equals ("o"))
                     {
                     try 
                        {
                        if (objectState.getStringValue ("owner").equals ("nil"))
                           browser.objects.remove (objectState.getStringValue ("o"));
                        }
                     catch (SelfMissingStateException e) 
                        {
                        try 
                           {
                           LensRadarObject existingObject = 
                                       (LensRadarObject) browser.objects.get (objectState.getStringValue ("o"));
                           if (existingObject == null)
                              browser.objects.put (objectState.getStringValue ("o"), new LensRadarObject (objectState));
                           else
                              existingObject.setState (objectState);
                           }
                        catch (SelfMissingStateException e2) 
                           {
                           }
                        }

//                     System.out.println ("LensRadarview: " + browser.objects.size () + " objects");
                     objectState = new SelfObjectState ();

                     ownerBrowser.redrawRect (new Rectangle (ownerBrowser.getViewOrigin ().x,
                                                             ownerBrowser.getViewOrigin ().y,
                                                             ownerBrowser.getViewSize ().width,
                                                             ownerBrowser.getViewSize ().height));
                     ownerBrowser.issueRepaint ();
                     Thread.yield ();
                     }
                  } 
               else
                  {
                  if (browser.downlinkStream.ttype == StreamTokenizer.TT_EOF)
                     {
                     System.out.println ("Radarview EOF, closing down: " + Thread.currentThread ().hashCode ());
                     bailoutPoint.bailout ();
                     }
                  }
               }
             catch (IOException e)
               {
               System.out.println ("Radarview IOException, closing down: " + Thread.currentThread ().hashCode ());
               bailoutPoint.bailout ();
               }
         }
   }
}
//-------------------------------------------------------------------------
// Kansas Java interface -- bringing Kansas to the Web
//
//   Structure.java
//
// $Revision: 30.1 $
//      Andy Collins, Sun Microsystems Laboratories, Summer 1996
//-------------------------------------------------------------------------


//------------------------------------------------------------------
// Structure.java - general structural interfaces and classes for
//                  the Java Self browsers
// Andy Collins, 8/5/96
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
// Interfaces:
//
//   BailInOut             requires bailin () and bailout () methods to
//                         connect or disconnect itself and all children.
//                         All components in the browser will implement this
//                         so that the top-level applet can be used as a 
//                         total browser bailout point to disconnect and
//                         put the program in a state from which it can
//                         reconnect.
//
//   Browser               a generalized view into some logical rectangular
//                         areas, supporting management both of the view
//                         area and damage-list style redraws.  A browser
//                         is presumed to use a BrowserCore to do the actual
//                         drawing.
//
// Classes:
//
//   BrowserPanel          is a Panel which can contain a browser core
//   BrowserMorph          is a Morph which can contain a browser core
//
//     see Viewer.java and RadarViewer.java for browser core
//     implementations.  The interface used is BailInOut down and
//     Browser up
//------------------------------------------------------------------
import java.awt.*;
import java.applet.Applet;
import java.io.*;
import java.net.*;
import java.util.*;

//------------------------------------------------------------------
//------------------------------------------------------------------
interface Browser extends BailInOut
{
   public void setBrowserCore (BrowserCore core);

   // view area management
   public Point getViewOrigin ();
   public void setViewOrigin (Point p);
   public Dimension getViewSize ();
   public Rectangle getViewArea ();
   public void moveTowards (String direction);
   public void moveTowards (String direction, float fraction);

   // coordinate xforms
   public Rectangle screenToLogical (Rectangle screen);
   public Rectangle logicalToScreen (Rectangle logical);

   // painting management
   public void redrawRect (Rectangle r);
   public void issueRepaint ();

   // misc
   public void setMessage (String msg);   
   public Point getGlobalMouseLoc ();
   public Component getComponent ();
}

//------------------------------------------------------------------
//------------------------------------------------------------------
class BrowserCore implements BailInOut
{
   Browser ownerBrowser;
   BailInOut bailoutPoint;

   BrowserCore (BrowserPanel browser, BailInOut bailoutPt)
   {
      ownerBrowser = browser;
      bailoutPoint = bailoutPt;
   }

   public void bailin ()
   {
   }

   public synchronized void bailout ()
   {
   }

   public void paint (Graphics g, Rectangle region)
   {
   }

   public void notifyViewChanged ()
   {
   }

   public void notifyShouldDisable (int numPaintsPending)
   {
   }
   public void notifyShouldEnable ()
   {
   }

   public boolean uiEvent (Event evt, int x, int y, int key)
   {
      return (false);
   }

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   // passback stuff

   void redrawRect (Rectangle r)
   {
      ownerBrowser.redrawRect (r);
   }
   void issueRepaint ()
   {
      ownerBrowser.issueRepaint ();
   }

   public Component getComponent ()
   {
      return (ownerBrowser.getComponent ());
   }
}

//------------------------------------------------------------------
//------------------------------------------------------------------
class BrowserPanel extends Panel implements Browser
{
   protected Point logicalViewOrigin = null;
   protected BrowserCore browserCore = null;
   protected Label messageLabel;

   public BrowserPanel (BrowserCore core, Point viewOrigin, Label messageLabel)
   {
      logicalViewOrigin = viewOrigin;
      browserCore = core;
      this.messageLabel = messageLabel;
   }

   public void setMessage (String msg)
   {
      messageLabel.setText (msg);
   }

   public Component getComponent ()
   {
      return ((Component) this);
   }

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   // BailInOut support
   public void bailin ()
   {
      if (browserCore != null)
         browserCore.bailin ();
   }
   public synchronized void bailout ()
   {
      if (browserCore != null)
         browserCore.bailout ();
   }

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   // Structure management
   public void setBrowserCore (BrowserCore core)
   {
      browserCore = core;
//      browserCores.addElement (core);
   }

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   // Get/Set the viewing area in logical coordinates:

   public Point getViewOrigin ()
   {
      return (logicalViewOrigin);
   }
   public void setViewOrigin (Point p)
   {
      logicalViewOrigin.x = p.x;
      logicalViewOrigin.y = p.y;
   }

   // No sets because changing the logical to physical ratio is not allowed
   public Dimension getViewSize ()    
   {
      return (new Dimension (size ().width, size ().height));
   }
   public Rectangle getViewArea ()
   {
      return (new Rectangle (logicalViewOrigin.x, logicalViewOrigin.y,
                             size ().width, size ().height));
   }

   // Move towards one of ("N", "E", "S", "W", "NE", "NW", "SW", "SE")
   // by either an 1/2 or by a fraction of the current view
   // size in that dimension

   public void moveTowards (String direction)
   {
      moveTowards (direction, (float) 0.25);
   }
   public void moveTowards (String direction, float fraction)
   {
      Point viewOrigin = getViewOrigin ();
      Dimension viewSize = getViewSize ();

      if (direction.equals ("NW") || direction.equals ("N") || direction.equals ("NE"))
         viewOrigin.y -= viewSize.height * fraction;
      if (direction.equals ("SW") || direction.equals ("S") || direction.equals ("SE"))
         viewOrigin.y += viewSize.height * fraction;

      if (direction.equals ("NW") || direction.equals ("W") || direction.equals ("SW"))
         viewOrigin.x -= viewSize.width * fraction;
      if (direction.equals ("NE") || direction.equals ("E") || direction.equals ("SE"))
         viewOrigin.x += viewSize.width * fraction;

      Rectangle oldViewArea = getViewArea ();
      setViewOrigin (viewOrigin);
      redrawRect (oldViewArea);
      redrawRect (getViewArea ());
      issueRepaint ();

      browserCore.notifyViewChanged ();
   }

   public void reshape (int x, int y, int width, int height)
   {
      super.reshape (x, y, width, height);
      makeDoubleBuffer (width, height);

      browserCore.notifyViewChanged ();
   }

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   // Coordinte transforms, to coords relative to this Panel
   public Rectangle screenToLogical (Rectangle screen)
   {
      // *****
      return (new Rectangle (0,0,0,0));
   }
   public Rectangle logicalToScreen (Rectangle logical)
   {
      // *****
      return (new Rectangle (0,0,0,0));
   }

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   // Painting management

   public void update (Graphics g)
   {
      paint (g);
   }

   protected Dimension offscreenSize;
   protected Image offscreenImage;
   protected Graphics offscreenGC = null;

   protected void makeDoubleBuffer (int width, int height)
   {
      if ((width > 0) && (height > 0))
         {
         offscreenSize = new Dimension (width, height);
         offscreenImage = createImage (width, height);
         offscreenGC = offscreenImage.getGraphics ();
         offscreenGC.setColor (new Color (240, 240, 240));
         offscreenGC.fillRect (0, 0, width, height);
         }
      else
         offscreenGC = null;
   }

   private Vector damageRects = new Vector ();

   public void redrawRect (Rectangle passedRect)
   {
      boolean foundOne = false;
      Rectangle rect = new Rectangle (passedRect.x - 20, passedRect.y - 20, 
                                      passedRect.width + 40, passedRect.height + 40);

      synchronized (damageRects)
         {
         for (int i=0; i<damageRects.size (); ++i)
            if (rect.intersects ((Rectangle) damageRects.elementAt (i)))
               {
               foundOne = true;
               damageRects.setElementAt (((Rectangle) damageRects.elementAt (i)).union (rect), i);
               }
         if (!foundOne)
            damageRects.addElement (rect);
         }
   }

   protected int numPaintsPending = 0;
   protected boolean paintsPending = false;
   public void issueRepaint ()
   {
      synchronized (damageRects)
         {
         if (!paintsPending)
            repaint ();
         paintsPending = true;
         ++numPaintsPending;
         if ((numPaintsPending % 10) == 0)
            System.out.println ("!!! now have " + numPaintsPending + " paints pending.");
         browserCore.notifyShouldDisable (numPaintsPending);
         }
   }

   public void paint (Graphics g)
   {
      if (offscreenGC == null)
         makeDoubleBuffer (size ().width, size ().height);
      if (offscreenGC == null)
         return;

      synchronized (damageRects)
         {
         for (int i=0; i < damageRects.size (); ++i)
            {
            Point viewOrigin = getViewOrigin ();
            Rectangle rect = (Rectangle) damageRects.elementAt (i);
            Rectangle xlated = new Rectangle (rect.x - viewOrigin.x, rect.y - viewOrigin.y,
                                              rect.width, rect.height);

            Graphics drawOnGC = offscreenGC.create ();
            drawOnGC.setColor (new Color (240, 240, 240));
            drawOnGC.fillRect (xlated.x, xlated.y, xlated.width, xlated.height);
            drawOnGC.clipRect (xlated.x, xlated.y, xlated.width, xlated.height);

            browserCore.paint (drawOnGC, xlated);
            }
         damageRects = new Vector (); 

         paintsPending = false;
         numPaintsPending = 0;
         browserCore.notifyShouldEnable ();
         }

      g.drawImage (offscreenImage, 0, 0, this);
   }  

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   // event and focus management

   Boolean haveFocus = Boolean.FALSE;
   public boolean gotFocus (Event evt, Object what)
   {
      synchronized (haveFocus)
         {
         haveFocus = Boolean.TRUE;
         }
      return (true);
   }
   public boolean lostFocus (Event evt, Object what)
   {
      synchronized (haveFocus)
         {
         haveFocus = Boolean.FALSE;
         }
      return (true);
   }

   private boolean uiEvent (Event evt, int x, int y, int key)
   {
      boolean needToGetFocus;
      synchronized (haveFocus)
         {
         needToGetFocus = !haveFocus.booleanValue ();
         }
      if (needToGetFocus)
         requestFocus ();

      if ((evt.id == Event.MOUSE_MOVE) || (evt.id == Event.MOUSE_DRAG))
         {
         xMouseLoc = x;
         yMouseLoc = y;
         }
 
      return (browserCore.uiEvent (evt, x, y, key));
   }

   int xMouseLoc;
   int yMouseLoc;

   public Point getGlobalMouseLoc ()
   {
      return (new Point (xMouseLoc + getViewOrigin ().x, yMouseLoc + getViewOrigin ().y));
   }

   public boolean mouseMove (Event evt, int x, int y) { xMouseLoc = x; yMouseLoc = y; return (uiEvent (evt, x, y, -1)); }
   public boolean mouseDrag (Event evt, int x, int y) { xMouseLoc = x; yMouseLoc = y; return (uiEvent (evt, x, y, -1)); }
   public boolean mouseUp   (Event evt, int x, int y) { xMouseLoc = x; yMouseLoc = y; return (uiEvent (evt, x, y, -1)); }
   public boolean mouseDown (Event evt, int x, int y) { xMouseLoc = x; yMouseLoc = y; return (uiEvent (evt, x, y, -1)); }

   public boolean keyUp     (Event evt, int key)      { return (uiEvent (evt, xMouseLoc, yMouseLoc, key)); }
   public boolean keyDown   (Event evt, int key)      { return (uiEvent (evt, xMouseLoc, yMouseLoc, key)); }

}


import java.awt.*;
import java.awt.image.*;
import java.applet.Applet;
import java.io.*;
import java.net.*;
import java.util.*;
//-------------------------------------------------------------------------
// Kansas Java interface -- bringing Kansas to the Web
//
//   Utils.java - lots o stuff
//
// $Revision: 30.1 $
//      Andy Collins, Sun Microsystems Laboratories, Summer 1996
//-------------------------------------------------------------------------


//------------------------------------------------------------------
//------------------------------------------------------------------
interface BailInOut 
{
   public void bailin ();     // Start all connections
   public void bailout ();    // Stop all connections and return 
                              // to start state
}

class InstrumentedInputStream extends InputStream
{
   InputStream is;
   int bytesRead;
   long startMillis;

   public InstrumentedInputStream (InputStream is)
   {
      this.is = is;
      bytesRead = 0;
      startMillis = System.currentTimeMillis ();
   }

   public int read () throws IOException
   {
      int charRead;

      ++bytesRead;
      if (bytesRead > 10240)
         {
         System.out.println ("InstrumentedInputStream: " + (bytesRead * 1000) / (System.currentTimeMillis () - startMillis)
                              + "bytes/sec");
         bytesRead = 0;
         startMillis = System.currentTimeMillis ();
         }

      charRead = is.read ();

      return (charRead);
   }
}

class StringImageBadSizeException extends Exception
{
   public StringImageBadSizeException ()
   { 
      super ();
   }
}

class StringImageException extends Exception
{
   public StringImageException ()
   { 
      super ();
   }
}

abstract class StringImageCreator
{
   public static Image createFrom (String colors, String pixels, int width, Component comp)
                                   throws StringImageBadSizeException, StringImageException
   {
      return (createFrom (colors, pixels, width, comp, true));
   }
   public static Image createFrom (String colors, String pixels, int width, Component comp, boolean useColors) 
                                   throws StringImageBadSizeException, StringImageException
   {
      int size = (pixels.length () / 2);
      int height = size / width;
      if ((size != (height * width)) || (size * 2 != pixels.length ()))
         {
         System.out.println ("bad width/data string");
         throw new StringImageBadSizeException ();
         }

      int numColors = (colors.length () / 8);
      if (numColors * 8 != colors.length ())
         {
         System.out.println ("bad color string");
         throw new StringImageBadSizeException ();
         }

      System.out.println ("Image data: " + width + "x" + height + ", " + numColors + " colors.");

      int pixelData[] = new int[size];
      for (int i = 0; i < size; ++i)
         {
         int colorOffset = Integer.parseInt (pixels.substring (i*2, i*2 + 2), 16);
         int rgb = Integer.parseInt (colors.substring (colorOffset*8+2, colorOffset*8 + 6), 16);
         if (useColors)
            pixelData[i] = rgb;
         else
            pixelData[i] = (rgb & 0x7f000000);   // knock off top alpha and all color, make a shadow
         }

      Image retval = comp.createImage (new MemoryImageSource (width, height, pixelData, 0, width));
      MediaTracker tracker = new MediaTracker (comp);
      tracker.addImage (retval, 1);
      try 
         {
         tracker.waitForID (1);
         }
      catch (InterruptedException e)
         {
         System.out.println ("interrupted");
         throw new StringImageException ();
         }

      return (retval);       
   }
}

abstract class FontManager 
{
   public static String resolveXFont (String xFont)
   {
      // This makes the rather simplistic assumption that:
      //    helvetica goes to Helvetica
      //    courier   goes to Courier
      //    symbol    goes to Symbol
      //    all else  goes to TimesRoman
      // Note that most of the other fonts are serif fonts that Java won't let me have.

      if (-1 != xFont.indexOf ("helvetica"))
         return ("Helvetica");
      if (-1 != xFont.indexOf ("courier"))
         return ("Courier");
      if (-1 != xFont.indexOf ("symbol"))
         return ("Symbol");

      return ("TimesRoman");
   }

   public static int extractStyle (String xFont)
   {
      int retval = Font.PLAIN;

      if (-1 != xFont.indexOf ("bold"))
         retval |= Font.BOLD;

      if (-1 != xFont.indexOf ("-i-"))
         retval |= Font.ITALIC;
      if (-1 != xFont.indexOf ("-o-"))
         retval |= Font.ITALIC;

      return (retval);
   }
}

//----------------------------------------------------------------------------------

class BailoutTimer extends Thread
{
   BailInOut app;
   long millis;

   BailoutTimer (BailInOut app, long millis)
   {
      this.app = app;
      this.millis = millis;
      start ();
   }

   public void run ()
   {
      try 
         {
         sleep (millis);
         System.out.println ("Timed out, closing down");
         app.bailout ();
         }
      catch (InterruptedException e)
         {
         }
   }
}
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfMissingStateException extends Exception
{
   String missingKey;
   public SelfMissingStateException ()
   {
      super ();
      missingKey = "<unknown>";
   }

   public SelfMissingStateException (String s)
   {
      super ();
      missingKey = new String (s);
   }
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfObjectState
{
   private Hashtable hash;

   public final static int TT_STRING = '\"';
   public final static int TT_NUMBER = -2;

   public SelfObjectState ()
   {
      hash = new Hashtable ();
   }

   public void clear ()
   {
      hash.clear ();
   }
  
   public Enumeration getKeys ()
   {
      return (hash.keys ());
   }

   public String getStringValueOrNull (String key)
   {
      return ((String) hash.get (key));
   }
   public String getStringValue (String key) throws SelfMissingStateException
   {
      String retval = getStringValueOrNull (key);
      if (retval == null)
         throw new SelfMissingStateException (key);
      return (retval);
   }

   public Double getNumberValueOrNull (String key)
   {
      String str = getStringValueOrNull (key);
      if (str == null)
         return (null);

      Double d;

      try
         {
         d = Double.valueOf (str);
         }
      catch (NumberFormatException e)
         {
         d = new Double (0.0);
         }

      return (d);
   }
   public double getNumberValue (String key) throws SelfMissingStateException
   {
      double d;

      try
         {
         d = Double.valueOf (getStringValue (key)).doubleValue ();
         }
      catch (NumberFormatException e)
         {
         d = 0.0;
         }

      return (d);
   }

   public void setValue (String key, String value)
   {
      if (key == null)
         System.out.println ("SelfObjectState.setValue: key is null, about to fail");
      if (value == null)
         System.out.println ("SelfObjectState.setValue: value is null, about to fail");
         
      hash.put (key, value);
   }

   public void setValue (String key, double value)
   {
      setValue (key, String.valueOf (value));
   }

   public void removeKey (String key)
   {
      hash.remove (key);
   }
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------

class IdleIndicator extends Panel
{
   boolean value;
   long notIdleSinceMillis;

   IdleIndicator (boolean initVal)
   {
      value = initVal;
      if (value == false)
         notIdleSinceMillis = System.currentTimeMillis ();
      else
         notIdleSinceMillis = 0;
   }

   public void paint (Graphics g)
   {
      g.setColor (Color.black);
      g.fillRect (0, 0, size ().width, size ().height);

      if (value)
         g.setColor (Color.green.darker ());
      else
         g.setColor (Color.red.darker ());
      g.fillRect (1, 1, size ().width - 2, size ().height - 2);
   }

   public void setValue (boolean newVal)
   {
      if ((value == true) && (newVal == false))
         notIdleSinceMillis = System.currentTimeMillis ();
      else if ((value == false) && (newVal == true))
         notIdleSinceMillis = 0;

      value = newVal;
      repaint ();
   }

   public boolean getValue ()
   {
      return (value);
   }

   public long getNotIdleTimeMillis ()
   {
      if (value == false)
         return (System.currentTimeMillis () - notIdleSinceMillis);
      else
         return (0);
   }

   public boolean mouseDown (Event evt, int x, int y) 
   { 
      value = true;
      repaint ();
      return (true); 
   }
}


import java.awt.*;
import java.awt.image.*;
import java.applet.Applet;
import java.io.*;
import java.net.*;
import java.util.*;

//-------------------------------------------------------------------------
// Kansas Java interface -- bringing Kansas to the Web
//
//   CutoutBrowser.java the Browser for the fish-eye view browser
//
// $Revision: 30.1 $
//      Andy Collins, Sun Microsystems Laboratories, Summer 1996
//-------------------------------------------------------------------------

class CircleFilter extends RGBImageFilter 
{
   Point center;
   int radius;
   double radiusFactor;

   public CircleFilter (double radiusFactor, Rectangle area)
   {
      this.radiusFactor = radiusFactor;
      setArea (area);
   }

   public void setArea (Rectangle area)
   {
      center = new Point (area.x + area.width / 2, area.y + area.height / 2);

      int xr = area.width / 2;
      int yr = area.height / 2;
      radius = (int) (radiusFactor * Math.sqrt (xr * xr + yr * yr));
      System.out.println ("Filter set up: center (" + center.x + ", " + center.y + ") radius " + radius);

   }

   public int filterRGB (int x, int y, int rgb)
   {
      if ((x - center.x) * (x - center.x) + (y - center.y) * (y - center.y) <= (radius * radius))
         {
         return (0x00000000);    // alpha = 00
         }
      else
         return (rgb);
   }
}

//----------------------------------------------------------------------------------
// A browser panel which keeps two cores, and displays one of them inside a 
// circular region and the other one outside that region
//----------------------------------------------------------------------------------

class CutoutBrowserPanel extends BrowserPanel
{
   CircleFilter imageFilter = null;
   private BrowserCore outsideBrowserCore;

   public CutoutBrowserPanel (BrowserCore insideBrowserCore, BrowserCore outsideBrowserCore,
                              Point viewOrigin, Label messageLabel, double radiusFactor)
   {
      super (insideBrowserCore, viewOrigin, messageLabel);
      imageFilter = new CircleFilter (radiusFactor, getViewArea ());
      this.outsideBrowserCore = outsideBrowserCore;
   }

   public void bailin ()
   {
      super.bailin ();
      if (outsideBrowserCore != null)
         outsideBrowserCore.bailin ();
   }

   public void bailout ()
   {
      super.bailout ();
      if (outsideBrowserCore != null)
         outsideBrowserCore.bailout ();
   }

   public void setOutsideBrowserCore (BrowserCore core)
   {
      outsideBrowserCore = core;
   }
   public void setInsideBrowserCore (BrowserCore core)
   {
      super.setBrowserCore (core);
   }

   public void moveTowards (String direction)
   {
      super.moveTowards (direction);
      outsideBrowserCore.notifyViewChanged ();
   }
   public void reshape (int x, int y, int width, int height)
   {
      super.reshape (x, y, width, height);
      outsideBrowserCore.notifyViewChanged ();
   }

   protected Image outsideOffscreenImage;
   protected Graphics outsideOffscreenGC = null;

   protected Image insideOffscreenImage;
   protected Graphics insideOffscreenGC = null;

   protected void makeDoubleBuffer (int width, int height)
   {
      super.makeDoubleBuffer (width, height);

      if ((width > 0) && (height > 0))
         {
         outsideOffscreenImage = createImage (width, height);
         outsideOffscreenGC = outsideOffscreenImage.getGraphics ();
         outsideOffscreenGC.setColor (new Color (240, 240, 240));
         outsideOffscreenGC.fillRect (0, 0, width, height);
         outsideOffscreenGC.clipRect (0, 0, width, height);

         insideOffscreenImage = createImage (width, height);
         insideOffscreenGC = insideOffscreenImage.getGraphics ();
         insideOffscreenGC.setColor (new Color (240, 240, 240));
         insideOffscreenGC.fillRect (0, 0, width, height);
         }
      else
         {
         insideOffscreenGC = null;
         outsideOffscreenGC = null;
         }
   }

   // Note that the outside core is drawn without any damage rectangles.
   // This is Ok as long as it is a radarviewer

   public void paint (Graphics g)
   {
      // Painting: first paint the outside image.  Then XOR the inside image, then
      // paint a black circle over the cutout, then XOR the insize image again.  The
      // outside area has been painted and double XORed, and the inside area has 
      // been painted black, and then XORed once, which puts the XORed values in

      if (outsideOffscreenGC == null)
         makeDoubleBuffer (size ().width, size ().height);
      if (outsideOffscreenGC == null)
         return;

      Rectangle xlated = new Rectangle (0,0,size ().width, size ().height);

      // Draw the outside image into a buffer

      outsideOffscreenGC.setColor (new Color (240, 240, 240));
      outsideOffscreenGC.fillRect (0, 0, size ().width, size ().height);
      outsideBrowserCore.paint (outsideOffscreenGC, xlated);

      // Draw the inside image into a buffer
//      insideOffscreenGC.setColor (new Color (240, 240, 240));
//      insideOffscreenGC.fillRect (0, 0, size ().width, size ().height);
      super.paint (insideOffscreenGC);

      outsideOffscreenGC.setXORMode (Color.black);
      outsideOffscreenGC.drawImage (insideOffscreenImage, 0, 0, this);
      outsideOffscreenGC.setPaintMode ();
      outsideOffscreenGC.setColor (Color.black);

      int xr = size ().width / 2;
      int yr = size ().height / 2;
      int radius = (int) (0.6 * Math.sqrt (xr * xr + yr * yr));

      int x = size ().width / 2 - radius;
      int y = size ().height / 2 - radius;
      outsideOffscreenGC.fillOval (x, y, radius * 2, radius * 2);

      outsideOffscreenGC.setXORMode (Color.black);
      outsideOffscreenGC.drawImage (insideOffscreenImage, 0, 0, this);
      outsideOffscreenGC.setPaintMode ();

      g.drawImage (outsideOffscreenImage, 0, 0, this);
   }
}
//-------------------------------------------------------------------------
// Kansas Java interface -- bringing Kansas to the Web
//
//   SelfDisconnectButton.java
//
// $Revision: 30.1 $
//      Andy Collins, Sun Microsystems Laboratories, Summer 1996
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
// a simple class that displays a button to order any/all SelfViewers in
// the AppletContext to disconnect (using the bailout () method).
//
// Andy Collins, 7/16/96
//-------------------------------------------------------------------------

import java.awt.*;
import java.applet.Applet;
import java.io.*;
import java.net.*;
import java.util.*;
//import SelfViewer;

public class SelfDisconnectButton extends Applet
{
   public void init ()   
   {
   setLayout (new BorderLayout ());
   add ("Center", new Button ("Disconnect"));
   }

   public void destroy ()
   {
   }

   public void start ()
   {
   }

   public void stop ()
   {
   }
 
   public boolean action (Event evt, Object obj)
   {
      if (evt.target instanceof Button)
         {
         String label = (String) obj;

         if (label.equals ("Disconnect"))
            {
            Enumeration e = getAppletContext ().getApplets ();
            while (e.hasMoreElements ())
               {
               Applet app = (Applet) e.nextElement ();
               if (app instanceof BailInOut)
                  ((BailInOut)app).bailout ();
               }
            return (true);
            }

         return (true);
         }
      return (false);
   }

}
import java.awt.*;
import java.applet.Applet;
import java.io.*;
import java.net.*;
import java.util.*;

//-------------------------------------------------------------------------
// Kansas Java interface -- bringing Kansas to the Web
//
//   RadarViewer.java -- the radar view Browser Core
//
// $Revision: 30.1 $
//      Andy Collins, Sun Microsystems Laboratories, Summer 1996
//-------------------------------------------------------------------------

//---------------------------------------------------------------------
//---------------------------------------------------------------------
class SelfRadarObject
{
   Rectangle rect = new Rectangle (0,0,0,0);
   Color color = Color.black;

   SelfRadarObject (SelfObjectState objectState)
   { 
      setState (objectState);
   }

   public void setState (SelfObjectState objectState)
   {
      try 
         {
         rect.x = (int) objectState.getNumberValue ("r.l");
         rect.y = (int) objectState.getNumberValue ("r.t");
         rect.width = (int) (objectState.getNumberValue ("r.r") - rect.x);
         rect.height = (int) (objectState.getNumberValue ("r.b") - rect.y);
         }
      catch (SelfMissingStateException e)
         {
         }

      try 
         {
         color = new Color ((float) objectState.getNumberValue ("c.r"),
                            (float) objectState.getNumberValue ("c.g"),
                            (float) objectState.getNumberValue ("c.b"));
         }
      catch (SelfMissingStateException e)
         {
         }
   }

   public void paint (Graphics g, Rectangle logicalArea, double xZoomFactor, double yZoomFactor)
   {
      if (rect.intersects (logicalArea))
         {
         g.setColor (color);
         g.fillRect ((int) ((rect.x - logicalArea.x) / xZoomFactor), 
                     (int) ((rect.y - logicalArea.y) / yZoomFactor),
                     Math.max (1, (int) (rect.width / xZoomFactor)), 
                     Math.max (1, (int) (rect.height / yZoomFactor)));
         }
   }
}

class RadarViewerBrowserCore extends BrowserCore
{
   String hostname = "localhost";
   int port = 1420;

   Thread runThread = null;

   Socket downlinkSocket = null;
   public StreamTokenizer downlinkStream;

   double xZoomFactor;
   double yZoomFactor;
   Hashtable objects;

   RadarViewerBrowserCore (BrowserPanel browser, BailInOut bailoutPt,
                           String hostname, int port,
                           double xZoomFactor, double yZoomFactor)
   {
      super (browser, bailoutPt);
 
      this.hostname = hostname;
      this.port = port;

      setZoom (xZoomFactor, yZoomFactor);
   }

   public void bailin ()
   {
      System.out.println ("RadarViewerBrowserCore.bailin (): " + Thread.currentThread ().hashCode ());
      objects = new Hashtable ();

      try 
         {
         // open the downlink socket (and follow the Self server . protocol)
         downlinkSocket = new Socket (hostname, port);
         DataOutputStream downlinkBackStream = 
                        new DataOutputStream (downlinkSocket.getOutputStream ());
         downlinkBackStream.writeBytes ("<radarview>\r\n");
         downlinkBackStream.flush ();
         downlinkStream = new StreamTokenizer (downlinkSocket.getInputStream ());
         downlinkStream.ordinaryChar (39);
         downlinkStream.wordChars (60, 62);
         downlinkStream.eolIsSignificant (false);
         downlinkStream.parseNumbers ();

         if (runThread != null)
            runThread.stop ();
         runThread = new RadarViewMonitor (this, ownerBrowser, bailoutPoint);
         runThread.start ();
         }
      catch (IOException e)
         {
         System.out.println ("Radarview initialization failure, closing down");
         bailoutPoint.bailout ();
         }      
   }

   public synchronized void bailout ()
   {
      System.out.println ("RadarViewerBrowserCore.bailout (): " + Thread.currentThread ().hashCode ());
      
      if (runThread == Thread.currentThread ())
         System.out.println ("  runThread is currentThread");

      try 
         {
         if (downlinkSocket != null)
            downlinkSocket.close ();
         }
      catch (IOException e)
         {
         }

      if (runThread != null)
         {
         System.out.println ("  Killing thread - " + runThread.hashCode ());
         runThread.stop ();
         runThread = null;
         }
      else
         System.out.println ("  Thread is already dead");

      System.out.println ("  returning");
   }

   public void setZoom (double xZoomFactor, double yZoomFactor)
   {
      this.xZoomFactor = xZoomFactor;
      this.yZoomFactor = yZoomFactor;
   }
   public void setZoom (double zoomFactor)
   {
      setZoom (zoomFactor, zoomFactor);
   }

   public void paint (Graphics g, Rectangle region)
   {
      Rectangle logicalArea = new Rectangle (0, 0, (int) (ownerBrowser.getViewSize ().width * xZoomFactor),
                                                   (int) (ownerBrowser.getViewSize ().height * yZoomFactor));
      logicalArea.x = (int) (ownerBrowser.getViewOrigin ().x - ((logicalArea.width - ownerBrowser.getViewSize ().width) / 2));
      logicalArea.y = (int) (ownerBrowser.getViewOrigin ().y - ((logicalArea.height - ownerBrowser.getViewSize ().height) / 2));

      Rectangle displayInto = new Rectangle (0,0,ownerBrowser.getViewSize ().width, ownerBrowser.getViewSize ().height);
      Graphics paintOn = g.create (displayInto.x, displayInto.y, displayInto.width, displayInto.height);
      paintOn.setColor (Color.white);
      paintOn.fillRect (0,0,displayInto.width,displayInto.height);

      Enumeration e = objects.elements ();
      while (e.hasMoreElements ())
         ((SelfRadarObject) e.nextElement ()).paint (paintOn, logicalArea, xZoomFactor, yZoomFactor);
   }

   public void notifyViewChanged ()
   {
      ownerBrowser.redrawRect (new Rectangle (ownerBrowser.getViewOrigin ().x,
                                              ownerBrowser.getViewOrigin ().y,
                                              ownerBrowser.getViewSize ().width,
                                              ownerBrowser.getViewSize ().height));
      ownerBrowser.issueRepaint ();
      Thread.yield ();
   }
}

class RadarViewMonitor extends Thread
{
   RadarViewerBrowserCore browser;
   Browser ownerBrowser;
   BailInOut bailoutPoint;

   public RadarViewMonitor (RadarViewerBrowserCore browser, Browser ownerBrowser, BailInOut bailoutPoint)
   {
      this.browser = browser;
      this.ownerBrowser = ownerBrowser;
      this.bailoutPoint = bailoutPoint;
   }

   public void run ()
   {
      String keyName;
      SelfObjectState objectState = new SelfObjectState ();

      Thread.yield ();

      for (;;)
         {
            try
               {
               browser.downlinkStream.nextToken ();

               if (browser.downlinkStream.ttype == StreamTokenizer.TT_WORD)
                  {
                  keyName = browser.downlinkStream.sval;
            
                  if (keyName == null)
                     System.out.println ("!!!!!");

                  browser.downlinkStream.nextToken ();

                  if (browser.downlinkStream.ttype == StreamTokenizer.TT_NUMBER)
                     objectState.setValue (keyName, browser.downlinkStream.nval);
                  else if ((browser.downlinkStream.ttype == StreamTokenizer.TT_WORD) ||
                           (browser.downlinkStream.ttype == '\"'))
                     objectState.setValue (keyName, browser.downlinkStream.sval);
                  else
                     {
                     System.out.println ("Unexpected second token following " + keyName + 
                                         ": type is " + browser.downlinkStream.ttype);
                     }
/* 
                  try
                     {
                     System.out.println (keyName + " " + objectState.getStringValue (keyName));
                     }
                  catch (SelfMissingStateException e)
                     {
                     }
*/
                  // Is this a complete object update, if so, it will end with "o"
                  if (keyName.equals ("o"))
                     {
                     try 
                        {
                        if (objectState.getStringValue ("owner").equals ("nil"))
                           browser.objects.remove (objectState.getStringValue ("o"));
                        }
                     catch (SelfMissingStateException e) 
                        {
                        try 
                           {
                           SelfRadarObject existingObject = 
                                       (SelfRadarObject) browser.objects.get (objectState.getStringValue ("o"));
                           if (existingObject == null)
                              browser.objects.put (objectState.getStringValue ("o"), new SelfRadarObject (objectState));
                           else
                              existingObject.setState (objectState);
                           }
                        catch (SelfMissingStateException e2) 
                           {
                           }
                        }

//                     System.out.println ("Radarview: " + browser.objects.size () + " objects");
                     objectState = new SelfObjectState ();

                     ownerBrowser.redrawRect (new Rectangle (ownerBrowser.getViewOrigin ().x,
                                                             ownerBrowser.getViewOrigin ().y,
                                                             ownerBrowser.getViewSize ().width,
                                                             ownerBrowser.getViewSize ().height));
                     ownerBrowser.issueRepaint ();
                     Thread.yield ();
                     }
                  } 
               else
                  {
                  if (browser.downlinkStream.ttype == StreamTokenizer.TT_EOF)
                     {
                     System.out.println ("Radarview EOF, closing down: " + Thread.currentThread ().hashCode ());
                     bailoutPoint.bailout ();
                     }
                  }
               }
             catch (IOException e)
               {
               System.out.println ("Radarview IOException, closing down: " + Thread.currentThread ().hashCode ());
               bailoutPoint.bailout ();
               }
         }
   }
}
import java.awt.*;
import java.applet.Applet;
import java.io.*;
import java.net.*;
import java.util.*;

//-------------------------------------------------------------------------
// Kansas Java interface -- bringing Kansas to the Web
//
//   Viewer.java -- The standard browser core
//
// $Revision: 30.1 $
//      Andy Collins, Sun Microsystems Laboratories, Summer 1996
//-------------------------------------------------------------------------


//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
abstract class CanvasObject extends Object
{
   Color color;

   // posn is the position of the owning Self object, and should be treated as
   // an offset (i.e. subtracted when constructing and added when drawing)

   public CanvasObject (SelfObjectState cmd, Point posn)
   {
      try
         {
         color = new Color ((float) cmd.getNumberValue ("c.r"),
                            (float) cmd.getNumberValue ("c.g"),
                            (float) cmd.getNumberValue ("c.b"));
         }
      catch (SelfMissingStateException e)
         {
         color = Color.black;
         }
   }

   public void paintBase (Graphics g, double xOffset, double yOffset)
   {
   }

   public void paint (Graphics g, double xOffset, double yOffset, Point posn, boolean shadowFlag)
   {
      if (shadowFlag)
         g.setColor (SelfMorph.shadowColor);
      else
         g.setColor (color);

      paintBase (g, xOffset + posn.x, yOffset + posn.y);
   }
}

class CanvasImageObject extends CanvasObject
{
   Image image;
   int xLoc;
   int yLoc;
   Component comp;

   public CanvasImageObject (SelfObjectState cmd, Point posn, Component comp)
   {
      super (cmd, posn);

//      System.out.println ("Creating image object");

      this.comp = comp;
      String colors;
      String pixels;
      int width;

      try
         {
         xLoc = (int) cmd.getNumberValue ("x") - posn.x;
         yLoc = (int) cmd.getNumberValue ("y") - posn.y;
         colors = cmd.getStringValue ("c");
         pixels = cmd.getStringValue ("p");
         width = (int) cmd.getNumberValue ("w");
         }
      catch (SelfMissingStateException e)
         {
         xLoc = 0;
         yLoc = 0;

         // 1x1 bitmap of a black dot
         colors = "ff000000";
         pixels = "00";
         width = 1;
         }

      try
         {
         image = StringImageCreator.createFrom (colors, pixels, width, comp);
         }
      catch (Exception e)
         {
         image = null;
         System.out.println ("Exception creating image !!!!!");
         }
   }

   public void paintBase (Graphics g, double xOffset, double yOffset)
   {
      if (image != null)
         g.drawImage (image, (int) (xLoc + xOffset), (int) (yLoc + yOffset), comp);
   }
}

class CanvasTextObject extends CanvasObject
{
   String string;
   Font font;
   int xLoc;
   int yLoc;

   public CanvasTextObject (SelfObjectState cmd, Point posn)
   {
      super (cmd, posn);
      try
         {
         string = cmd.getStringValue ("s");

         xLoc = (int) cmd.getNumberValue ("x") - posn.x;
         yLoc = (int) cmd.getNumberValue ("y") - posn.y;

         font = new Font (FontManager.resolveXFont (cmd.getStringValue ("fn")),
                          FontManager.extractStyle (cmd.getStringValue ("fn")),
                          (int) cmd.getNumberValue ("fs"));
         }
      catch (SelfMissingStateException e)
         {
         string = "";
         xLoc = 0;
         yLoc = 0;
         font = new Font ("TimesRoman", Font.PLAIN, 12);
         }
   }

   public void paintBase (Graphics g, double xOffset, double yOffset)
   {
      g.setFont (font);
      g.drawString (string, (int) (xLoc + xOffset), (int) (yLoc + yOffset));
   }
}

abstract class CanvasWidthObject extends CanvasObject
{
   int width;

   public CanvasWidthObject (SelfObjectState cmd, Point posn)
   {
      super (cmd, posn);
      try
         {
         width = (int) cmd.getNumberValue ("w");
         }
      catch (SelfMissingStateException e)
         {
         width = 1;
         }
   }

}

abstract class CanvasPointListObject extends CanvasWidthObject
{
   int xpoints[];
   int ypoints[];
   int numPoints;

   public CanvasPointListObject (SelfObjectState cmd, Point posn)
   {
      super (cmd, posn);
      try
         {
         StringTokenizer xvals = new StringTokenizer (cmd.getStringValue ("xs"), ",");
         StringTokenizer yvals = new StringTokenizer (cmd.getStringValue ("ys"), ",");

         numPoints = xvals.countTokens ();
         if (yvals.countTokens () < numPoints)
            numPoints = yvals.countTokens ();         // Take the min, rather than raise an error

         xpoints = new int [numPoints + 1];
         ypoints = new int [numPoints + 1];

         for (int i=0; i<numPoints; ++i)
            {
            xpoints[i] = Integer.valueOf (xvals.nextToken ()).intValue () - posn.x;
            ypoints[i] = Integer.valueOf (yvals.nextToken ()).intValue () - posn.y;
            }

         }
      catch (SelfMissingStateException e)
         {
         // This is a safe default, even if Polygon tries to close it
         numPoints = 0;
         xpoints = new int[1];
         ypoints = new int[1];

         xpoints[0] = 0;
         ypoints[0] = 0;
         }
   }

   // At this point, we can put the paint method here, since the only distinction
   // among the subclasses is closing the polygon

   public void paintBase (Graphics g, double xOffset, double yOffset)
   {
      int xlatedXPoints[] = new int[numPoints];
      int xlatedYPoints[] = new int[numPoints];

      for (int i=0; i<numPoints; ++i)
         {
         xlatedXPoints[i] = xpoints[i] + (int) xOffset;
         xlatedYPoints[i] = ypoints[i] + (int) yOffset;
         }

      if (width < 0)
         g.fillPolygon (xlatedXPoints, xlatedYPoints, numPoints);
      else
         g.drawPolygon (xlatedXPoints, xlatedYPoints, numPoints);
   }
}

class CanvasPolygonObject extends CanvasPointListObject
{
   public CanvasPolygonObject (SelfObjectState cmd, Point posn)
   {
      super (cmd, posn);

      // Complete the polygon         
      xpoints[numPoints] = xpoints[0];
      ypoints[numPoints] = ypoints[0];
      ++numPoints;
   }
}

class CanvasLinesObject extends CanvasPointListObject
{
   public CanvasLinesObject (SelfObjectState cmd, Point posn)
   {
      super (cmd, posn);

      // Don't complete the polygon
   }
}

abstract class CanvasBBoxObject extends CanvasWidthObject
{
   Rectangle bbox;

   public CanvasBBoxObject (SelfObjectState cmd, Point posn)
   {
      super (cmd, posn);
      try
         {
         bbox = new Rectangle ((int) (cmd.getNumberValue ("r.l")) - posn.x,
                               (int) (cmd.getNumberValue ("r.t")) - posn.y,
                               (int) (cmd.getNumberValue ("r.r") -
                                      cmd.getNumberValue ("r.l")),
                               (int) (cmd.getNumberValue ("r.b") -
                                      cmd.getNumberValue ("r.t")));
         }
      catch (SelfMissingStateException e)
         {
         bbox = new Rectangle (0,0,0,0);
         }
   }
}

class CanvasArcObject extends CanvasBBoxObject
{
   int startAngle;
   int spanAngle;

   public CanvasArcObject (SelfObjectState cmd, Point posn)
   {
      super (cmd, posn);
      try
         {
         startAngle = (int) cmd.getNumberValue ("st");
         spanAngle = (int) cmd.getNumberValue ("sp");
         }
      catch (SelfMissingStateException e)
         {
         startAngle = 0; 
         spanAngle = 360;
         }
   }

   public void paintBase (Graphics g, double xOffset, double yOffset)
   {
      if (width < 0)
         g.fillArc ((int) (bbox.x + xOffset), (int) (bbox.y + yOffset), bbox.width, bbox.height,
                    startAngle, spanAngle);
      else
         g.drawArc ((int) (bbox.x + xOffset), (int) (bbox.y + yOffset), bbox.width, bbox.height,
                    startAngle, spanAngle);
   }
}

class CanvasRectObject extends CanvasBBoxObject
{
   public CanvasRectObject (SelfObjectState cmd, Point posn)
   {
      super (cmd, posn);
   }

   public void paintBase (Graphics g, double xOffset, double yOffset)
   {
      if (width < 0)
         g.fillRect ((int) (bbox.x + xOffset), (int) (bbox.y + yOffset), bbox.width, bbox.height);
      else
         g.drawRect ((int) (bbox.x + xOffset), (int) (bbox.y + yOffset), bbox.width, bbox.height);
   }
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfMorph extends Object
{
   protected Vector children;
   protected SelfMorph parent;
   public int index;

   Rectangle baseBounds = new Rectangle (0,0,0,0);
   String objectIDString = null;
   String parentIDString = "<none>";
   boolean isWorldMorphFlag = false;
   Color color = Color.black;
   boolean hasCanvasObjects = false;
   Vector canvasObjects = null;
   int childNumber = 2000000000;    // close enough to maxint
   String canvasCmd = "no canvas command";

   Component comp;

   public SelfMorph (SelfObjectState state, Component comp) throws SelfMissingStateException
   {
      children = new Vector ();
      parent = null;
      index = -42;
      overallBounds = new Rectangle (0,0,0,0);

      this.comp = comp;
      setSelfMorphState (state, comp);      
   }

   public void setState (SelfObjectState objectState) throws SelfMissingStateException
   {
      // I really wanted static binding here, just to save code while forcing
      // my desired ordering on the constructor sequence.  Everyone else is
      // now going to do something equally silly here
      setSelfMorphState (objectState, comp);
   }

   public void setSelfMorphState (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      try
         {
         baseBounds = new Rectangle ((int) objectState.getNumberValue ("baseBounds.left"),
                                     (int) objectState.getNumberValue ("baseBounds.top"),
                                     (int) (objectState.getNumberValue ("baseBounds.right") -
                                            objectState.getNumberValue ("baseBounds.left")),
                                     (int) (objectState.getNumberValue ("baseBounds.bottom") -
                                            objectState.getNumberValue ("baseBounds.top"))); 
         }
      catch (SelfMissingStateException e) {}

      try
         {
         int x = (int) objectState.getNumberValue ("p.l");
         int y = (int) objectState.getNumberValue ("p.t");
         baseBounds.x = x;
         baseBounds.y = y;
         }
      catch (SelfMissingStateException e) {}
       
      try { color = new Color ((float) objectState.getNumberValue ("color.red"),
                               (float) objectState.getNumberValue ("color.green"),
                               (float) objectState.getNumberValue ("color.blue")); }
         catch (SelfMissingStateException e) {}

      try { objectIDString = objectState.getStringValue ("objectID"); }
         catch (SelfMissingStateException e) {}
      try { parentIDString = objectState.getStringValue ("owner"); }
         catch (SelfMissingStateException e) {}
      try { isWorldMorphFlag = objectState.getStringValue ("isWorldMorph").equals ("true"); }
         catch (SelfMissingStateException e) {}
      try 
         { 
         int tempChildNumber = (int) objectState.getNumberValue ("childNumber");
         if (tempChildNumber != -1)
            childNumber = tempChildNumber;
         }
      catch (SelfMissingStateException e) {}

      try
         {
         canvasCmd = objectState.getStringValue ("canvasCmd"); 
         canvasObjects = new Vector ();

         String keyName;
         StringTokenizer tokens = new StringTokenizer (canvasCmd, "|");
         SelfObjectState aCmd = new SelfObjectState ();
 
         while (tokens.hasMoreTokens ())
            {
            keyName = tokens.nextToken ();

            if (tokens.hasMoreTokens ())
               aCmd.setValue (keyName, tokens.nextToken ());
            else
               break;

            if (keyName.equals ("item"))
               {
                try
                  {
                  if (aCmd.getStringValue ("item").equals ("arc"))
                     canvasObjects.addElement (new CanvasArcObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("lines"))
                     canvasObjects.addElement (new CanvasLinesObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("polygon"))
                     canvasObjects.addElement (new CanvasLinesObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("rect"))
                     canvasObjects.addElement (new CanvasRectObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("text"))
                     canvasObjects.addElement (new CanvasTextObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("image"))
                     canvasObjects.addElement (new CanvasImageObject (aCmd, getPosition (), comp));
                  }
               catch (SelfMissingStateException e)
                  {
                  }
               aCmd = new SelfObjectState ();
               }
            }
         hasCanvasObjects = true;
         }
      catch (SelfMissingStateException e)
         {
         }

      if ((color == null) || (objectIDString == null) || (parentIDString == null))
         throw new SelfMissingStateException ("unknown");

      computeOverallBounds ();
   }


   public void setSelfMorphStateUsingNulls (SelfObjectState objectState, Component comp)
   {
      // Check for baseBounds, and set if we find what we need
      Double bbLeft = objectState.getNumberValueOrNull ("baseBounds.left");
      Double bbTop = objectState.getNumberValueOrNull ("baseBounds.top");
      Double bbRight = objectState.getNumberValueOrNull ("baseBounds.right");
      Double bbBottom = objectState.getNumberValueOrNull ("baseBounds.bottom");

      if ((bbLeft != null) && (bbTop != null) && (bbRight != null) && (bbBottom != null))
         {
         baseBounds = new Rectangle ((int) bbLeft.doubleValue (),
                                     (int) bbTop.doubleValue (),
                                     (int) (bbRight.doubleValue () - bbLeft.doubleValue ()),
                                     (int) (bbBottom.doubleValue () - bbTop.doubleValue ())); 
         }
       
      Double x = objectState.getNumberValueOrNull ("p.l");
      Double y = objectState.getNumberValueOrNull ("p.t");
      if ((x != null) && (y != null))
         {
         baseBounds.x = (int) x.doubleValue ();
         baseBounds.y = (int) y.doubleValue ();
         }

       
       Double redVal = objectState.getNumberValueOrNull ("color.red");
       Double greenVal = objectState.getNumberValueOrNull ("color.green");
       Double blueVal = objectState.getNumberValueOrNull ("color.blue");

       if ((redVal != null) && (greenVal != null) && (blueVal != null))
         { 
         color = new Color ((float) redVal.doubleValue (),
                            (float) greenVal.doubleValue (),
                            (float) blueVal.doubleValue ());
         }

      String newOID = objectState.getStringValueOrNull ("objectID");
      if (newOID != null)
         objectIDString = newOID;
      String newOwnerOID = objectState.getStringValueOrNull ("owner");
      if (newOwnerOID != null)
         parentIDString = newOwnerOID;
      String isWorldMorph = objectState.getStringValueOrNull ("isWorldMorph");
      if (isWorldMorph != null)
         isWorldMorphFlag = isWorldMorph.equals ("true");

      Double childNum = objectState.getNumberValueOrNull ("childNumber");
      if (childNum != null)
         { 
         int tempChildNumber = (int) childNum.doubleValue ();
         if (tempChildNumber != -1)
            childNumber = tempChildNumber;
         }

      String newCanvasCmd = objectState.getStringValueOrNull ("canvasCmd");
      if (newCanvasCmd != null)
         {
         canvasCmd = newCanvasCmd; 
         canvasObjects = new Vector ();

         String keyName;
         StringTokenizer tokens = new StringTokenizer (canvasCmd, "|");
         SelfObjectState aCmd = new SelfObjectState ();
 
         while (tokens.hasMoreTokens ())
            {
            keyName = tokens.nextToken ();

            if (tokens.hasMoreTokens ())
               aCmd.setValue (keyName, tokens.nextToken ());
            else
               break;

            if (keyName.equals ("item"))
               {
               try
                  {
                  if (aCmd.getStringValue ("item").equals ("arc"))
                     canvasObjects.addElement (new CanvasArcObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("lines"))
                     canvasObjects.addElement (new CanvasLinesObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("polygon"))
                     canvasObjects.addElement (new CanvasLinesObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("rect"))
                     canvasObjects.addElement (new CanvasRectObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("text"))
                     canvasObjects.addElement (new CanvasTextObject (aCmd, getPosition ()));
                  else if (aCmd.getStringValue ("item").equals ("image"))
                     canvasObjects.addElement (new CanvasImageObject (aCmd, getPosition (), comp));
                  }
               catch (SelfMissingStateException e)
                  {
                  }
               aCmd = new SelfObjectState ();
               }
            }
         hasCanvasObjects = true;
         }
/*
      if ((color == null) || (objectIDString == null) || (parentIDString == null))
         throw new SelfMissingStateException ("unknown");
*/
      computeOverallBounds ();
      }

   public Point getPosition ()
   {
      // World morphs are special, but not so special as to deserve another class
      if (isWorldMorph ())
         return (new Point (0,0));

      // Most morphs work this way
      return (new Point (baseBounds.x, baseBounds.y));
   }
   public Point getGlobalPosition ()
   {
      Point myPosition = getPosition ();

      if ((parent != null) && (parent != this))
         {
         Point parentPosition = parent.getGlobalPosition ();
         return (new Point (myPosition.x + parentPosition.x, myPosition.y + parentPosition.y));
         }
      else
         return (new Point (myPosition.x, myPosition.y));
   }

   Rectangle overallBounds;
   public Rectangle getGlobalBounds ()
   {
      Rectangle globalBounds = new Rectangle (overallBounds.x, overallBounds.y, 
                                              overallBounds.width, overallBounds.height);
      if ((parent != null) && (parent != this))
         {
         Point parentPosition = parent.getGlobalPosition ();
         globalBounds.x += parentPosition.x;
         globalBounds.y += parentPosition.y;
         }
      return (globalBounds);
   }
   void computeOverallBounds ()
   {
      int xmin = 0;
      int ymin = 0;
      int xmax = baseBounds.width;
      int ymax = baseBounds.height;
   
      Rectangle childBounds;

      synchronized (children)
         {
         for (int i=0; i<children.size (); ++i)
            {
            childBounds = ((SelfMorph) children.elementAt (i)).overallBounds;

            if (childBounds.x < xmin) 
               xmin = childBounds.x;
            if (childBounds.y < ymin) 
               ymin = childBounds.y;
            if ((childBounds.x + childBounds.width) > xmax) 
               xmax = childBounds.x + childBounds.width;
            if ((childBounds.y + childBounds.height) > ymax) 
               ymax = childBounds.y + childBounds.height;
            }
         }

      Rectangle retval = new Rectangle (xmin, ymin, xmax - xmin, ymax - ymin);
      retval.x += baseBounds.x;
      retval.y += baseBounds.y;

      // If we are about to change our bounds, then be sure to tell our parent 
      // *after* we do it (not before)
      if (!overallBounds.equals (retval))
         {
         overallBounds = retval;
         if (parent != null)
            parent.computeOverallBounds ();
         }
   }

   public static final Color shadowColor = Color.black.brighter ();

   public void paintBase (Graphics g, double xOffset, double yOffset, boolean shadowFlag)
   {
      if (hasCanvasObjects)
         {
         for (int i=0; i<canvasObjects.size (); ++i)
            ((CanvasObject) canvasObjects.elementAt (i)).paint (g, xOffset, yOffset, getPosition (), shadowFlag);
         }
      else
         {
         if (shadowFlag)
            g.setColor (shadowColor);
         else
            g.setColor (color);

         g.fillRect ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset),
                     baseBounds.width, baseBounds.height);
         }
   }

   public String asString ()
   {
      return (objectIDString + " a SelfMorph: " + canvasCmd);
   }

   public void printCoreSample (int x, int y, String prefix)
   {
      Rectangle checkRect = new Rectangle (x, y, 1, 1);
      System.out.println (prefix + asString ());
      synchronized (children)
         {
         for (int i = children.size () - 1; i >= 0; --i)
            {
            SelfMorph m = (SelfMorph) children.elementAt (i);
            if (checkRect.intersects (m.baseBounds))
               m.printCoreSample (x - m.getPosition ().x , y - m.getPosition ().y, prefix + "  ");
            }
         }
   }

   public int paint (Graphics g, double xOffset, double yOffset, String prefix, Rectangle damageRect, boolean shadowFlag)
   {
      Rectangle xlated = new Rectangle (overallBounds.x + (int) xOffset, overallBounds.y + (int) yOffset,
                                        overallBounds.width, overallBounds.height);

      if (xlated.intersects (damageRect))
         {
         paintBase (g, xOffset, yOffset, shadowFlag);

         int count = 1;
         synchronized (children)
            {
            for (int i = children.size () - 1; i >= 0; --i)
               {
               count += ((SelfMorph) children.elementAt (i)).paint (g, xOffset + getPosition ().x, yOffset + getPosition ().y, 
                                                                    prefix + "  ", damageRect, shadowFlag);
               }
            }
         return (count);
         }
      else
         return (0);
   }

   int paintCount = 0;

   public void paint (Graphics g, ViewerBrowserCore browser, double xViewMin, double yViewMin, 
                      double xViewMax, double yViewMax, Rectangle damageRect)
   {
      long startMillis = System.currentTimeMillis ();

      // This is called only from the outside, and only on world morphs.  Step 1 is the vacuum cleaner
      // that gets rid of any top-level objects which no longer intersect the viewing area.

      if ((++paintCount % 20) == 0)
         {
         synchronized (children)
            {
            for (int i=children.size () - 1; i >= 0; --i)
               {
               SelfMorph child = ((SelfMorph) children.elementAt (i));
               if ( !(child.intersects (xViewMin, yViewMin, xViewMax, yViewMax)) && 
                    !(child instanceof SelfMyHandMorph) )
                  {
                  removeChild (child);
                  child.removeFrom (browser);
                  }
               }
            }
         }

      long middleMillis = System.currentTimeMillis ();
      int numObjects = paint (g, -1.0 * xViewMin, -1.0 * yViewMin, "", damageRect, false);
      long endMillis = System.currentTimeMillis ();

      System.out.println ("Painted " + numObjects + " objects in " +
                          (endMillis - middleMillis) + " ms.  (+ " + (middleMillis - startMillis) + " ms for vacuum.)  Thread is: "
                         + Thread.currentThread ().hashCode () + " priority: " + Thread.currentThread ().getPriority ());
   }

   public boolean intersects (double xMin, double yMin, double xMax, double yMax)
   {
      if (isWorldMorph ())
         return (true);

      if ((overallBounds.y + overallBounds.height) < yMin)
         return (false);
      if (overallBounds.y > yMax)
         return (false);
      if (overallBounds.x > xMax)
         return (false);
      if (overallBounds.x + overallBounds.width < xMin)
         return (false);

      return (true);
   }

   public void addChild (SelfMorph child, int index)
   {
 /*
     if (child != null)
         System.out.println ("- " + this.objectID () + ".addChild (" + child.objectID () + ", " + index + ")");
      else
         System.out.println ("- " + this.objectID () + ".addChild (null, " + index + ")");
*/         
      if (this == child)
         {
         System.out.println ("!!!!! Bad dog, trying to create parent loop.");
         return;
         }

      if ((child != null) /*&& (index != -1)*/)
         {
         removeChild (child);

         synchronized (children)
            {
            int i = 0;
            for (i=0; (i < children.size ()) && (((SelfMorph) children.elementAt (i)).index < index); ++i) ;
            
            children.insertElementAt (child, i);
            child.index = index;
            child.parent = this;
            }

         computeOverallBounds ();
         }
   }

   public void removeChild (SelfMorph child)
   {
      if ((child!= null) && children.contains (child))
         {
         synchronized (children)
            {
            children.removeElement (child);
            child.parent = null;
            }

         computeOverallBounds ();
         }
   }

   public String parentID ()
   {
      return (parentIDString);
   }

   public String objectID ()
   {
      return (objectIDString);
   }

   public boolean isWorldMorph ()
   {
      return (isWorldMorphFlag);
   }

   public int getChildNumber ()
   {
      return (childNumber);
   }

   public void removeFrom (ViewerBrowserCore browser)
   {
      synchronized (children)
         {
         Enumeration e = children.elements ();
         while (e.hasMoreElements ())
            ((SelfMorph) e.nextElement ()).removeFrom (browser);
         }

      browser.selfObjects.remove (objectID ());
   }
}

//----------------------------------------------------------------------------------
///----------------------------------------------------------------------------------
class SelfHandMorph extends SelfMorph
{
   SelfHandMorph (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
   }

   public String asString ()
   {
      return (objectID () + " a SelfHandMorph, position = " + getPosition ());
   }

   public int paint (Graphics g, double xOffset, double yOffset, String prefix, Rectangle damageRect, boolean shadowFlag)
   {
      Rectangle xlated = new Rectangle (overallBounds.x + (int) xOffset, overallBounds.y + (int) yOffset,
                                        overallBounds.width, overallBounds.height);

      if (xlated.intersects (damageRect))
         {
         // Draw all my children's shadows
         for (int i = children.size () - 1; i >= 0; --i)
            {
            ((SelfMorph) children.elementAt (i)).paint (g, xOffset + getPosition ().x + 5.0, yOffset + getPosition ().y + 5.0, 
                                                        prefix + "- ", damageRect, true);
            }

         // Draw all my children
         int count = 1;
         for (int i = children.size () - 1; i >= 0; --i)
            {
            count += ((SelfMorph) children.elementAt (i)).paint (g, xOffset + getPosition ().x, yOffset + getPosition ().y, 
                                                                 prefix + "  ", damageRect, shadowFlag);
            }

         // HandMorphs are backwards from the other morphs, and draw themselves on top of their children
         paintBase (g, xOffset, yOffset, shadowFlag);

         return (count);
         }
      else
         return (0);
   }
}


//----------------------------------------------------------------------------------
// SelfMyHandMorph is a very special morph.  It represents my hand object, which
// is in the world on the self side but is never updated to me.  It's position is
// maintained locally, and serves as a base for the position of any objects it owns
// (the process of gaining and losing children happens automatically as I pick up
// and drop things, and this object is in the list of normal objects for that reason)
//
// This object is special-cased to ensure that it is never vacuum cleaned.
//----------------------------------------------------------------------------------
class SelfMyHandMorph extends SelfHandMorph
{
   SelfMyHandMorph (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
   }

   public String asString ()
   {
      return (objectID () + " my pointer, a SelfMyHandMorph, position = " + getPosition ());
   }

   public void paintBase (Graphics g, double xOffset, double yOffset, boolean shadowFlag)
   {
      // This space intentionally left blank :)
   }

   public void moveTo (double x, double y, BrowserCore browser)
   {
      Rectangle oldGlobalBounds = null;

      if (children.size () > 0)
         oldGlobalBounds = getGlobalBounds ();

      baseBounds.x = (int) x;
      baseBounds.y = (int) y;

      if (parent != null)
         parent.addChild (this, 0);
 
      computeOverallBounds ();

      if (children.size () > 0)
         {
         browser.redrawRect (oldGlobalBounds);
         browser.redrawRect (getGlobalBounds ());
         browser.issueRepaint ();
         }
   }
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfFrameMorph extends SelfMorph
{
   public static final int SELF_BEZEL_STYLE = 0;
   public static final int SELF_FLAT_STYLE = 2;
   public static final int SELF_INSET_BEZEL_STYLE = 1;

   int borderWidth = 0;
   boolean filled = false;
   int frameStyle = SELF_FLAT_STYLE;

   public String asString ()
   {
      return (objectID () + " a SelfFrameMorph, baseBounds = " + baseBounds);
   }

   public SelfFrameMorph (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
      setSelfFrameMorphState (objectState);
   }
   public void setState (SelfObjectState objectState) throws SelfMissingStateException
   {
      super.setState (objectState);
      setSelfFrameMorphState (objectState);
   }
   public void setSelfFrameMorphState (SelfObjectState objectState) throws SelfMissingStateException
   {
//      System.out.println ("SelfFrameMorph.setState () -- " + objectState.getNumberValue ("borderWidth") +
//                          "; " + objectState.getStringValue ("filled") + "; " + objectState.getNumberValue ("frameStyle"));
  
      try { borderWidth = (int) objectState.getNumberValue ("borderWidth"); }
         catch (SelfMissingStateException e) {}
      try { filled = (0 == objectState.getStringValue ("filled").compareTo ("true"));  }
        catch (SelfMissingStateException e) {}
      try { frameStyle = (int) objectState.getNumberValue ("frameStyle"); }
        catch (SelfMissingStateException e) {}
   }

   public void paintBase (Graphics g, double xOffset, double yOffset, boolean shadowFlag)
   {
      Color base = color;
      Color dark = base.darker ();
      Color light = base.brighter ();

      if (shadowFlag && filled)
         {
         g.setColor (shadowColor);
         g.fillRect ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset),
                     baseBounds.width, baseBounds.height);
         return;
         }
      else if (shadowFlag)
         {
         base = shadowColor;
         dark = shadowColor;
         light = shadowColor;
         }

      if (filled)
         {
         g.setColor (base);
         g.fillRect ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset),
                     baseBounds.width, baseBounds.height);
         }

      switch (frameStyle)
         {
         case SELF_BEZEL_STYLE: g.setColor (light); break;
         case SELF_INSET_BEZEL_STYLE: g.setColor (dark); break;
         default: g.setColor (base); break;
         }

      g.fillRect ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset),
                  baseBounds.width, borderWidth);
      g.fillRect ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset),
                  borderWidth, baseBounds.height);

      switch (frameStyle)
         {
         case SELF_BEZEL_STYLE: g.setColor (dark); break;
         case SELF_INSET_BEZEL_STYLE: g.setColor (light); break;
         default: g.setColor (base); break;
         }

      int X[] = new int[4];
      int Y[] = new int[4];
      X[0] = (int) (baseBounds.x + xOffset);
      Y[0] = (int) (baseBounds.y + baseBounds.height + yOffset);
      X[1] = (int) (baseBounds.x + borderWidth + xOffset);
      Y[1] = (int) (baseBounds.y + baseBounds.height - borderWidth+ yOffset);
      X[2] = (int) (baseBounds.x + baseBounds.width - borderWidth + xOffset);
      Y[2] = (int) (baseBounds.y + baseBounds.height - borderWidth + yOffset);
      X[3] = (int) (baseBounds.x + baseBounds.width + xOffset);
      Y[3] = (int) (baseBounds.y + baseBounds.height + yOffset);
      g.fillPolygon (X, Y, 4);
//      System.out.println ("Drew polygon 1: " + X[0] +"," + Y[0] + " " + X[1] +"," + Y[1] + " " +
//                                               X[2] +"," + Y[2] + " " + X[3] +"," + Y[3] + " ");
     
      X[0] = (int) (baseBounds.x + baseBounds.width + xOffset);
      Y[0] = (int) (baseBounds.y + baseBounds.height + yOffset);
      X[1] = (int) (baseBounds.x + baseBounds.width - borderWidth + xOffset);
      Y[1] = (int) (baseBounds.y + baseBounds.height - borderWidth + yOffset);
      X[2] = (int) (baseBounds.x + baseBounds.width - borderWidth + xOffset);
      Y[2] = (int) (baseBounds.y + borderWidth + yOffset);
      X[3] = (int) (baseBounds.x + baseBounds.width + xOffset);
      Y[3] = (int) (baseBounds.y + yOffset);
      g.fillPolygon (X, Y, 4);

//      System.out.println ("Drew polygon2 : " + X[0] +"," + Y[0] + " " + X[1] +"," + Y[1] + " " +
//                                               X[2] +"," + Y[2] + " " + X[3] +"," + Y[3] + " ");

   }   
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfUI2Button extends SelfFrameMorph
{
   SelfUI2Button (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
      setSelfUI2ButtonState (objectState);
   }
   public void setState (SelfObjectState objectState) throws SelfMissingStateException
   {
      super.setState (objectState);
      setSelfUI2ButtonState (objectState);
   }
   public void setSelfUI2ButtonState (SelfObjectState state) throws SelfMissingStateException
   {
      filled = true;
   }

   public String asString ()
   {
      return (objectID () + " a SelfUI2Button, baseBounds = " + baseBounds);
   }

}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfLabelMorph extends SelfMorph
{
   Font font = new Font ("TimesRoman", Font.PLAIN, 12);
   String label = "";

   SelfLabelMorph (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
      setSelfLabelMorphState (objectState);
   }
   public void setState (SelfObjectState objectState) throws SelfMissingStateException
   {
      super.setState (objectState);
      setSelfLabelMorphState (objectState);
   }
   public void setSelfLabelMorphState (SelfObjectState objectState) throws SelfMissingStateException
   {
      try { font = new Font (FontManager.resolveXFont (objectState.getStringValue ("fontName")),
                             FontManager.extractStyle (objectState.getStringValue ("fontName")),
                             (int) objectState.getNumberValue ("fontSize")); }
         catch (SelfMissingStateException e) {}
      try { label = objectState.getStringValue ("label"); }
         catch (SelfMissingStateException e) {}
   }

   public void paintBase (Graphics g, double xOffset, double yOffset, boolean shadowFlag)
   {
      FontMetrics fm = g.getFontMetrics (font);

      Graphics g2 = g.create ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset),
                              baseBounds.width, baseBounds.height);

      if (shadowFlag)
         g2.setColor (shadowColor);
      else
         g2.setColor (color);
      g2.setFont (font);
      g2.drawString (label, 0, baseBounds.height - fm.getDescent ());
   }

   public String asString ()
   {
      return (objectID () + " a SelfLabelMorph, '" + label + "'");
   }
}
 
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfCircleMorph extends SelfMorph
{
   SelfCircleMorph (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
   }

   public void paintBase (Graphics g, double xOffset, double yOffset, boolean shadowFlag)
   {
      if (shadowFlag)
         g.setColor (shadowColor);
      else
         g.setColor (color);

      g.fillOval ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset),
                  baseBounds.width, baseBounds.height);
   }

   public Point getPosition ()
   {
      return (new Point (baseBounds.x + (baseBounds.width / 2),
                         baseBounds.y + (baseBounds.height / 2 )));
   }

   public String asString ()
   {
      return (objectID () + " a SelfCircleMorph, position = " + getPosition ());
   }
}
 
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfJavaUserMorph extends SelfMorph
{
   SelfJavaUserMorph (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
   }

   public void paintBase (Graphics g, double xOffset, double yOffset, boolean shadowFlag)
   {
      if (shadowFlag)
         g.setColor (shadowColor);
      else
         g.setColor (color);

      g.drawRect ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset),
                  baseBounds.width, baseBounds.height);
   }

   public String asString ()
   {
      return (objectID () + " a SelfJavaUserMorph, baseBounds = " + baseBounds);
   }

}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfUI2TextField extends SelfMorph
{
   int numLines = 0;
   String text[] = new String[0];
   Point cursor = new Point (0,0);
   int offset = 0;
   boolean isFocus = false;

   int fontHeight = 0;
   int fontWidth = 0;
   int lineHeight = 0;
   Point cornerOffset = new Point (0,0);
   
   boolean hasSelection = false;
   Point selectionEnd = new Point (0,0);

   Color fontColor = Color.black;
   Color backgroundColor = Color.white;
   Color selectionColor = Color.red;
   Color cursorColor = Color.black;

   SelfUI2TextField (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
      setSelfUI2TextFieldState (objectState);
   }
   public void setState (SelfObjectState objectState) throws SelfMissingStateException
   {
      super.setState (objectState);
      setSelfUI2TextFieldState (objectState);
   }
   public void setSelfUI2TextFieldState (SelfObjectState objectState) throws SelfMissingStateException
   {
      try { fontHeight = (int) objectState.getNumberValue ("fontHeight");              } catch (SelfMissingStateException e) {}
      try { lineHeight = (int) objectState.getNumberValue ("lineHeight");              } catch (SelfMissingStateException e) {}
      try 
         { 
         fontWidth  = (int) objectState.getNumberValue ("fontWidth");
         }
      catch (SelfMissingStateException e) {}
      try
         {
         cornerOffset = new Point ((int) objectState.getNumberValue ("cornerOffset.x"), 
                                   (int) objectState.getNumberValue ("cornerOffset.y"));
         }
      catch (SelfMissingStateException e) {}

      try { offset  = (int) objectState.getNumberValue ("off");             } catch (SelfMissingStateException e) {}
      try { isFocus = objectState.getStringValue ("focus").equals ("true"); } catch (SelfMissingStateException e) {}

      try { hasSelection = objectState.getStringValue ("hasSelection").equals ("true"); } catch (SelfMissingStateException e) {}

      try { fontColor = new Color ((float) objectState.getNumberValue ("fontColor.red"),
                                   (float) objectState.getNumberValue ("fontColor.green"),
                                   (float) objectState.getNumberValue ("fontColor.blue")); }
         catch (SelfMissingStateException e) {}

      try { backgroundColor = new Color ((float) objectState.getNumberValue ("backgroundColor.red"),
                                         (float) objectState.getNumberValue ("backgroundColor.green"),
                                         (float) objectState.getNumberValue ("backgroundColor.blue")); }
         catch (SelfMissingStateException e) {}

      try { cursorColor = new Color ((float) objectState.getNumberValue ("cursorColor.red"),
                                     (float) objectState.getNumberValue ("cursorColor.green"),
                                     (float) objectState.getNumberValue ("cursorColor.blue")); }
         catch (SelfMissingStateException e) {}

      try { selectionColor = new Color ((float) objectState.getNumberValue ("selectionColor.red"),
                                        (float) objectState.getNumberValue ("selectionColor.green"),
                                        (float) objectState.getNumberValue ("selectionColor.blue")); }
         catch (SelfMissingStateException e) {}

      try 
         { 
         numLines = (int) objectState.getNumberValue ("numLines");
         text = new String[numLines];
         for (int i=0; i<numLines; ++i)
            text[i] = "-";
         }
      catch (SelfMissingStateException e) {}

      try
         {
         cursor = new Point ((int) objectState.getNumberValue ("cursorx"), 
                             (int) objectState.getNumberValue ("cursory"));
         }
      catch (SelfMissingStateException e) {}

      try
         {
         selectionEnd = new Point ((int) objectState.getNumberValue ("selectionx"), 
                                   (int) objectState.getNumberValue ("selectiony"));
         }
      catch (SelfMissingStateException e) {}

      Enumeration e = objectState.getKeys ();
      while (e.hasMoreElements ())
         {
         String s = (String) e.nextElement ();
         if (s.startsWith ("line"))
            {
            try 
               {
               int i = Integer.parseInt (s.substring (4));
               if ((i >= 0) && (i < numLines))
                  text[i] = objectState.getStringValue (s);
               }
            catch (NumberFormatException ex)
               {
               }
            }
         }
   }

   Point selectionUL ()
   {
      Point retval;
      if (cursor.y < selectionEnd.y)
         retval = new Point (cursor.x, cursor.y);
      else if (cursor.x < selectionEnd.x)
         retval = new Point (cursor.x, cursor.y);
      else
         retval = new Point (selectionEnd.x, selectionEnd.y);

      if (retval.y < 0)
         retval.y = 0;
      if (retval.x < 0) 
         retval.x = 0;
      if (retval.y >= numLines)
         retval.y = (numLines - 1);
      if (retval.x > text[retval.y].length ())
         retval.x = text[retval.y].length () - 1;

      return (retval);
   }
   Point selectionLR ()
   {
      Point retval;
      if (cursor.y < selectionEnd.y)
         retval = new Point (selectionEnd.x, selectionEnd.y);
      else if (cursor.x < selectionEnd.x)
         retval = new Point (selectionEnd.x, selectionEnd.y);
      else
         retval = new Point (cursor.x, cursor.y);

      if (retval.y < 0)
         retval.y = 0;
      if (retval.x < 0) 
         retval.x = 0;
      if (retval.y >= numLines)
         retval.y = (numLines-1);
      if (retval.x > text[retval.y].length ())
         retval.x = text[retval.y].length ();

      return (retval);
   }

   Font font = null;
   int actualFontWidth = 0;

   public void paintBase (Graphics g, double xOffset, double yOffset, boolean shadowFlag)
   {
      if (shadowFlag)
         return;

      if ((font == null) || (actualFontWidth != fontWidth))
         {
         int guessSize = 12;
         Font guessFont = new Font ("courier", Font.PLAIN, guessSize);
         int width = g.getFontMetrics (guessFont).stringWidth ("M");    // monospaced font, letter is arbitrary
         while (width > fontWidth)
            {
            --guessSize;
            guessFont = new Font ("courier", Font.PLAIN, guessSize);
            width = g.getFontMetrics (guessFont).stringWidth ("M");
            }
         while (width < fontWidth)
            {
            ++guessSize;
            guessFont = new Font ("courier", Font.PLAIN, guessSize);
            width = g.getFontMetrics (guessFont).stringWidth ("M");
            }
       
         font = guessFont;
         actualFontWidth = width;
         System.out.println ("Font matcher: target was " + fontWidth + "; got " + actualFontWidth + " by using " + guessSize + " points");
         }

      Graphics clipped = g.create ();
      clipped.clipRect ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset), baseBounds.width, baseBounds.height);
      clipped.setColor (backgroundColor);
      clipped.fillRect ((int) (baseBounds.x + xOffset), (int) (baseBounds.y + yOffset), baseBounds.width, baseBounds.height);
      
      int incr = lineHeight;

      clipped.setFont (font);
      clipped.setColor (fontColor);

      int baseLine = (int) (baseBounds.y + yOffset) - clipped.getFontMetrics (font).getDescent () + cornerOffset.y;
      for (int i = offset; (i < numLines) && (baseLine <= (int) (baseBounds.y + baseBounds.height + yOffset)); ++i)
         {
         baseLine += incr;

         if (hasSelection)
            {
            g.setColor (selectionColor);
            if ((selectionUL ().y < i) && (selectionLR ().y > i))
               g.fillRect ((int) (baseBounds.x + xOffset), baseLine - incr + clipped.getFontMetrics (font).getDescent (), 
                           baseBounds.width, incr);
 
            else if ((selectionUL ().y == i) && (selectionLR ().y == i))
               g.fillRect ((int) (baseBounds.x + xOffset + 
                                  clipped.getFontMetrics (font).stringWidth (text[i].substring (0, selectionUL ().x))) + (cornerOffset.x + 1),
                           baseLine - incr + clipped.getFontMetrics (font).getDescent (),
                           clipped.getFontMetrics (font).stringWidth (text[i].substring (selectionUL ().x, selectionLR ().x)),
                           incr);

            else if (selectionUL ().y == i)
               g.fillRect ((int) (baseBounds.x + xOffset + 
                                  clipped.getFontMetrics (font).stringWidth (text[i].substring (0, selectionUL ().x))) + (cornerOffset.x + 1),
                           baseLine - incr + clipped.getFontMetrics (font).getDescent (),
                           baseBounds.width - clipped.getFontMetrics (font).stringWidth (text[i].substring (0, selectionUL ().x)) - (cornerOffset.x + 1),
                           incr);

            else if (selectionLR ().y == i)
               g.fillRect ((int) (baseBounds.x + xOffset), baseLine - incr + clipped.getFontMetrics (font).getDescent (),
                           clipped.getFontMetrics (font).stringWidth (text[i].substring (0, selectionLR ().x)) + (cornerOffset.x + 1),
                           incr);
            }

         g.setColor (fontColor);
         clipped.drawString (text[i], (int) (baseBounds.x + xOffset) + (cornerOffset.x + 1), baseLine);

         if (!hasSelection && (cursor.y == i))
            {
            int xoff = clipped.getFontMetrics (font).stringWidth (text[i].substring (0, cursor.x));
            g.setColor (cursorColor);
            g.drawLine ((int) (baseBounds.x + xoff + xOffset) + (cornerOffset.x + 1), baseLine + clipped.getFontMetrics (font).getDescent (), 
                        (int) (baseBounds.x + xoff + xOffset) + (cornerOffset.x + 1), baseLine - incr + clipped.getFontMetrics (font).getDescent ());
            }
         }
   }

   public String asString ()
   {
      return (objectID () + " a SelfUI2TextField");
   }
}


//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfImageMorph extends SelfMorph
{
   Image image;
   Image shadowImage;
   Component comp;

   SelfImageMorph (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
      this.comp = comp;
      setSelfImageMorphState (objectState);
   }
   public void setState (SelfObjectState objectState) throws SelfMissingStateException
   {
      super.setState (objectState);
      setSelfImageMorphState (objectState);
   }
   public void setSelfImageMorphState (SelfObjectState objectState) throws SelfMissingStateException
   {
      String colors;
      String pixels;
      int width;

      try
         {
         colors = objectState.getStringValue ("imageColormap");
         pixels = objectState.getStringValue ("imagePixels");
         width = (int) objectState.getNumberValue ("imageWidth");

         image = StringImageCreator.createFrom (colors, pixels, width, comp);
         shadowImage = StringImageCreator.createFrom (colors, pixels, width, comp, false);
         }
      catch (SelfMissingStateException e)
         {
         }
      catch (StringImageBadSizeException e)
         {
         image = null;
         System.out.println ("bad size Exception creating image !!!!!");
         }
      catch (StringImageException e)
         {
         image = null;
         System.out.println ("generic Exception creating image !!!!!");
         }
   }

   public void paintBase (Graphics g, double xOffset, double yOffset, boolean shadowFlag)
   {
      if (shadowFlag)
         {
         if (shadowImage != null)
            g.drawImage (shadowImage, (int) (getPosition ().x + xOffset), (int) (getPosition ().y + yOffset), comp);
         }
      else
         {
         if (image != null)
            g.drawImage (image, (int) (getPosition ().x + xOffset), (int) (getPosition ().y + yOffset), comp);
         }
   }

   public String asString ()
   {
      return (objectID () + " a SelfImageMorph");
   }
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class SelfTemplateMorph extends SelfMorph
{
   SelfTemplateMorph (SelfObjectState objectState, Component comp) throws SelfMissingStateException
   {
      super (objectState, comp);
   }

   public void paintBase (Graphics g, double xOffset, double yOffset, boolean shadowFlag)
   {
   }

   public String asString ()
   {
      return (objectID () + " a SelfTemplateMorph");
   }
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------

class MonitorThread extends Thread
{
   BailInOut bailoutPoint;
   ViewerBrowserCore browser;
//   SelfMorph secondChanceMorph;
   SecondChanceList secondChanceList;

   public MonitorThread (ViewerBrowserCore viewer, BailInOut bailoutPt)
   {
      bailoutPoint = bailoutPt;
      browser = viewer;
//      secondChanceMorph = null;
      secondChanceList = new SecondChanceList (10);
   }

   public void run ()
   {
      String keyName;
      SelfObjectState objectState = new SelfObjectState ();

      for (;;)
         {
            try
               {
               browser.downlinkStream.nextToken ();

               if (browser.downlinkStream.ttype == StreamTokenizer.TT_WORD)
                  {
                  keyName = browser.downlinkStream.sval;
                  browser.downlinkStream.nextToken ();

                  if (browser.downlinkStream.ttype == StreamTokenizer.TT_NUMBER)
                     {
                     objectState.setValue (keyName, browser.downlinkStream.nval);
                     }
                  else if ((browser.downlinkStream.ttype == StreamTokenizer.TT_WORD) ||
                           (browser.downlinkStream.ttype == '\"'))
                     {
                     objectState.setValue (keyName, browser.downlinkStream.sval);
                     }
                  else
                     {
                     System.out.println ("Unexpected second token following " + keyName + 
                                         ": type is " + browser.downlinkStream.ttype);
                     bailoutPoint.bailout ();
                     }
/* 
                  try
                     {
                     System.out.println (keyName + " " + objectState.getStringValue (keyName));
                     }
                  catch (SelfMissingStateException e)
                     {
                     }
*/

                  // Is this a complete object update, if so, it will end with "objectID"
                  if (0 == keyName.compareTo ("objectID"))
                     {
/*
                     try 
                        {
                        System.out.println ("--- object " + objectState.getStringValue ("objectID") + " downlinked --- ");
                        }
                     catch (Exception e)  
                        {
                        }
*/
                     SelfMorph changedMorph = null;
                     SelfMorph existingParent = null;
                     SelfMorph newParent = null;

                     try
                        {
                        boolean thisIsDownloadObject = false;
                        String dlString = objectState.getStringValueOrNull ("isADownloadObject");
                        if (dlString != null)
                           thisIsDownloadObject = dlString.equals ("true");

                        changedMorph = ((SelfMorph) browser.selfObjects.get (objectState.getStringValue ("objectID")));
                        if (changedMorph != null)
                           existingParent = ((SelfMorph) browser.selfObjects.get (changedMorph.parentID ()));

                        String newOwnerOID = objectState.getStringValueOrNull ("owner");
                        if (newOwnerOID != null)
                           newParent = ((SelfMorph) browser.selfObjects.get (newOwnerOID));

                        // Ok, first thing to check is whether we want to handle this now or go ahead and call
                        // in the reinforcements in the form of requesting a complete download of the substructure
                        // of this morph.  This is done if we know this morph's owner, but not it.  In this case,
                        // odds are this is a small update and not enough information to instantiate this morph
                        // now, so if we are going to download anyway, that will send a complete update, so why
                        // bother instantiating now?
                        if ((changedMorph == null) && (newParent != null) && !thisIsDownloadObject)
                           {
                           // Request more information
//                           System.out.println ("  requesting download from " + objectState.getStringValue ("objectID"));
                           synchronized (browser.uplinkStream)
                              {
//                              browser.netIdleIndicator.setValue (false);

                              browser.uplinkStream.writeBytes ("Download " + objectState.getStringValue ("objectID") + "\r\n");
                              }
                           }
                        else
                           {
                           if (changedMorph == null)
                              {
                              if (0 == objectState.getStringValue ("javaClass").compareTo ("SelfUI2Button"))
                                 changedMorph = new SelfUI2Button (objectState, browser.getComponent ());
                              else if (0 == objectState.getStringValue ("javaClass").compareTo ("SelfFrameMorph"))
                                 changedMorph = new SelfFrameMorph (objectState, browser.getComponent ());
                              else if (0 == objectState.getStringValue ("javaClass").compareTo ("SelfLabelMorph"))
                                 changedMorph = new SelfLabelMorph (objectState, browser.getComponent ());
                              else if (0 == objectState.getStringValue ("javaClass").compareTo ("SelfCircleMorph"))
                                 changedMorph = new SelfCircleMorph (objectState, browser.getComponent ());
                              else if (0 == objectState.getStringValue ("javaClass").compareTo ("SelfJavaUserMorph"))
                                 changedMorph = new SelfJavaUserMorph (objectState, browser.getComponent ());
                              else if (0 == objectState.getStringValue ("javaClass").compareTo ("SelfHandMorph"))
                                 changedMorph = new SelfHandMorph (objectState, browser.getComponent ());
                              else if (0 == objectState.getStringValue ("javaClass").compareTo ("SelfUI2TextField"))
                                 changedMorph = new SelfUI2TextField (objectState, browser.getComponent ());
                              else if (0 == objectState.getStringValue ("javaClass").compareTo ("SelfImageMorph"))
                                 changedMorph = new SelfImageMorph (objectState, browser.getComponent ());
                              else 
                                 changedMorph = new SelfMorph (objectState, browser.getComponent ());

                              // This might get ripped right back out, see below
                              browser.selfObjects.put (objectState.getStringValue ("objectID"), changedMorph);

                              // Now that the world is here, make my hand a child of it and be done with it.
                              if (changedMorph.isWorldMorph ())
                                 {
                                 System.out.println ("Putting myHandMorph into world");
                                 changedMorph.addChild (browser.myHandMorph, 0);
                                 }
                              }                        
                           else
                              {
/*
                              if (changedMorph == secondChanceMorph)
                                 {
                                 secondChanceMorph = null;
                                 }
*/
                              secondChanceList.findAndRemove (changedMorph);

                              Rectangle oldGlobalBounds = changedMorph.getGlobalBounds ();
                              changedMorph.setState (objectState);
                              browser.redrawRect (oldGlobalBounds);
//                              System.out.println ("Object (either found or recovered): " + changedMorph.objectID () + " parent is " + 
//                                                  changedMorph.parentID ());
                              }

//                           System.out.println ("Morph update: objectID " + changedMorph.objectID () + "; parentID: " +
//                                                changedMorph.parentID ());

                           // If we don't know the owner, and this isn't a worldMorph, then it is just
                           // a lost child, and we can drop it.  It will never be drawn.

                           if ((browser.selfObjects.get (changedMorph.parentID ()) != null) || changedMorph.isWorldMorph ())
                              {                             
                              newParent = ((SelfMorph) browser.selfObjects.get (changedMorph.parentID ()));
                              if (newParent != null)
                                 {
//                                 System.out.println ("We have a newParent (" + newParent.objectID () + " for " + changedMorph.objectID () + ")");
                                 if (existingParent != null)
                                    {
//                                    System.out.println ("We have an existingParent (" + 
//                                                        newParent.objectID () + " for " + changedMorph.objectID () + ")");
                                    if (0 != existingParent.objectID ().compareTo (newParent.objectID ()))
                                       {
                                       existingParent.removeChild (changedMorph);
                                       newParent.addChild (changedMorph, changedMorph.getChildNumber ());
                                       }
                                    else
                                       existingParent.addChild (changedMorph, changedMorph.getChildNumber ());
                                    }
                                 else
                                    {
                                    newParent.addChild (changedMorph, changedMorph.getChildNumber ());
                                    }
                                 }
 
                                 browser.redrawRect (changedMorph.getGlobalBounds ());
                              }
                           else
                              {
                              // Whoops - remember to check and see if the orphan object is currently in the 
                              // hash table.  If so, then that object was just deleted, and needs to be
                              // removed here as well

//                              System.out.println ("   Deleting object " + changedMorph.objectID ());
                              if (existingParent != null)
                                 existingParent.removeChild (changedMorph);
                           
                              // New deletion system: delete the object in secondChanceOID, and put myself there
/*
                              if (secondChanceMorph != null)
                                 {
                                 secondChanceMorph.removeFrom (browser);
                                 }
                              secondChanceMorph = changedMorph;
*/
                              SelfMorph victim = (SelfMorph) secondChanceList.insertGetVictim (changedMorph);
                              if (victim != null)
                                 victim.removeFrom (browser);
                              }
 
                           browser.issueRepaint ();
                           browser.updateToolbarText ();
/* This is broken in netscape, so use the disable/enable method
                           if (!thisIsDownloadObject)
                              currentThread ().yield ();
*/
                           }
                        }
                     catch (SelfMissingStateException e)
                        {
//                        System.out.println ("SelfMissingStateException in DL, clearing object: " + e.missingKey );
                        }

//                     objectState = new SelfObjectState ();
                     objectState.clear ();
                     }

                  // Is this a complete object action, if so, it will end with "javaAction"
                  else if (0 == keyName.compareTo ("javaAction"))
                     {
                     try
                        {
//                        objectState = new SelfObjectState ();
                        objectState.clear ();
                        }
                     catch (Exception e)
                        {
                        System.out.println ("EXCEPTION 4");
                        bailoutPoint.bailout ();
                        }
                     }

                  // Is this a simple message ack?  If so, deal with it, but don't clear objectState
                  else if (0 == keyName.compareTo ("javaMessageAck"))
                     {
                     objectState.removeKey ("javaMessageAck");
                     browser.caughtUpIndicator.setValue (true);
                     }

                  // Is this the end of a download, if so yield and let draw
                  else if (0 == keyName.compareTo ("adviseEndOfDownload"))
                     {
                     objectState.removeKey ("adviseEndOfDownload");
//                     browser.netIdleIndicator.setValue (true);
                     currentThread ().yield ();
                     }
                  }
               else
                  {
                  if (browser.downlinkStream.ttype == StreamTokenizer.TT_EOF)
                     {
                     System.out.println ("EOF, closing down");
                     bailoutPoint.bailout ();
                     }
                  }
               }
            catch (IOException e)
               {
               System.out.println ("IOException, closing down");
               bailoutPoint.bailout ();
               }
         }
   }
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------

class ViewerBrowserCore extends BrowserCore
{
   Socket downlinkSocket;
   public StreamTokenizer downlinkStream;
   Socket uplinkSocket;
   public DataOutputStream uplinkStream;

   public Hashtable selfObjects;
   MonitorThread monitorThread;

   String hostname = "localhost";
   int port = 1420;
   String userName = "java user";
   String userPassword = "";

   public SelfMorph myHandMorph;            // I need to hang on to this from the time I create it
                                            // until the worldMorph arrives.

   public CaughtUpIndicator caughtUpIndicator;
   public IdleIndicator netIdleIndicator;

   ViewerBrowserCore (BrowserPanel browser, BailInOut bailoutPt, String hostname, int port,
                      String userName, String userPassword,
                      CaughtUpIndicator caughtUp, IdleIndicator idle)
   {
      super (browser, bailoutPt);
      caughtUpIndicator = caughtUp;
      netIdleIndicator = idle;

      this.hostname = hostname;
      this.port = port;
      this.userName = userName;
      this.userPassword = userPassword;
   }

   public void updateToolbarText ()
   {
      Point mouse = ownerBrowser.getGlobalMouseLoc ();
      ownerBrowser.setMessage ("" + mouse.x + ", " + mouse.y + "   " + selfObjects.size () + " objects.");
   }

   public void bailin ()
   {
      System.out.println ("initing display...");

      // General initialization stuff
      selfObjects = new Hashtable ();

      try 
         {
         // open the downlink socket (and follow the Self server . protocol)
         downlinkSocket = new Socket (hostname, port);
         System.out.println ("Opened downlink socket");

         DataOutputStream downlinkBackStream = 
                        new DataOutputStream (downlinkSocket.getOutputStream ());
         downlinkBackStream.writeBytes (userName + "&" + userPassword + "\r\n");
         downlinkBackStream.flush ();
         System.out.println ("  wrote my name");

         downlinkStream = new StreamTokenizer (new InstrumentedInputStream (downlinkSocket.getInputStream ()));
//         downlinkStream = new StreamTokenizer (downlinkSocket.getInputStream ());

         downlinkStream.ordinaryChar (39);
         downlinkStream.wordChars (60, 62);
         downlinkStream.eolIsSignificant (false);
         downlinkStream.parseNumbers ();
         if (downlinkStream.nextToken () == StreamTokenizer.TT_WORD)
            {
            System.out.println ("  got my OID");
            // open the uplink socket
            uplinkSocket = new Socket (hostname, port);
            uplinkStream = new DataOutputStream (uplinkSocket.getOutputStream ());
            uplinkStream.writeBytes (downlinkStream.sval + "\r\n");
            
            uplinkStream.writeBytes ("View " + ownerBrowser.getViewOrigin ().x + " " 
                                             + (ownerBrowser.getViewOrigin ().y + ownerBrowser.getViewSize ().height) + " " 
                                             + (ownerBrowser.getViewOrigin ().x + ownerBrowser.getViewSize ().width) + " " 
                                             + ownerBrowser.getViewOrigin ().y+ "\r\n");
            System.out.println ("View " + ownerBrowser.getViewOrigin ().x + " " 
                                        + (ownerBrowser.getViewOrigin ().y + ownerBrowser.getViewSize ().height) + " " 
                                        + (ownerBrowser.getViewOrigin ().x + ownerBrowser.getViewSize ().width) + " "
                                        + ownerBrowser.getViewOrigin ().y);

            // This is the added twiddle of the ! protocol, read the objectID of my hand out of the 
            // stream and set up the object for it
            SelfObjectState objectState = new SelfObjectState ();
            objectState.setValue ("owner", downlinkStream.sval);

            if (downlinkStream.nextToken () == StreamTokenizer.TT_WORD)
               {
               System.out.println ("  got my hands OID");
               if (downlinkStream.sval == null)
                  {
                  System.out.println ("!!!! TT_WORD, but sval is null !!!!");
                  bailoutPoint.bailout ();
                  }

               objectState.setValue ("objectID", downlinkStream.sval);
               objectState.setValue ("owner", "<none>");
               objectState.setValue ("baseBounds.left", ownerBrowser.getViewOrigin ().x);
               objectState.setValue ("baseBounds.right", ownerBrowser.getViewOrigin ().x);
               objectState.setValue ("baseBounds.top", ownerBrowser.getViewOrigin ().y);
               objectState.setValue ("baseBounds.bottom", ownerBrowser.getViewOrigin ().y);
               objectState.setValue ("color.red", 0.0);
               objectState.setValue ("color.green", 0.0);
               objectState.setValue ("color.blue", 0.0);
               objectState.setValue ("isWorldMorph", "false");
       
               try
                  {
                  myHandMorph = new SelfMyHandMorph (objectState, getComponent ());

                  if (downlinkStream.sval == null)
                     {
                     System.out.println ("!!!!!!!! TT_WORD, but sval is null !!!!!!!!");
                     bailoutPoint.bailout ();
                     }

                  selfObjects.put (downlinkStream.sval, myHandMorph);
                  }
               catch (SelfMissingStateException e)
                  {
                  System.out.println ("!!!! This better not happen !!!!");
                  bailoutPoint.bailout ();
                  }
               }
            else
               {
               System.out.println ("!!! no hand morph ID found");
               bailoutPoint.bailout ();
               }

            // Make damn sure that we don't start this thread until *after* we're done with
            // the downlinkStream, 'cause it's gonna start reading it !!!!!
            monitorThread = new MonitorThread (this, bailoutPoint);
            monitorThread.setPriority (Thread.NORM_PRIORITY + 2);
            monitorThread.start ();
            }
         else
            {
            System.out.println ("!!! no user morph ID found");
            bailoutPoint.bailout ();
            }
         } 
      catch (IOException e) 
         {
         System.out.println ("!!! IOException thrown during connect");
         bailoutPoint.bailout ();
         }
   }

   public void bailout ()
   {
      System.out.println ("SelfWorldDisplay.destroy ()");
      try
         {
         if (uplinkStream != null)
            uplinkStream.writeBytes ("Disconnect\r\n");
         }
      catch (IOException e)
         {
         }

      try
         {
         if (uplinkSocket != null)
            uplinkSocket.close ();
         if (downlinkSocket != null)
            downlinkSocket.close ();
         }
      catch (IOException e)
         {
         }

      if (monitorThread != null)
         {
         monitorThread.stop ();
         monitorThread = null;
         }
   }

   public void notifyViewChanged ()
   {
      if (uplinkStream != null)
         {
         try
            {
            uplinkStream.writeBytes ("View " + ownerBrowser.getViewOrigin ().x + " "
                                             + (ownerBrowser.getViewOrigin ().y + ownerBrowser.getViewSize ().height) + " " 
                                             + (ownerBrowser.getViewOrigin ().x + ownerBrowser.getViewSize ().width) + " " 
                                             + ownerBrowser.getViewOrigin ().y+ "\r\n");
            System.out.println ("View " + ownerBrowser.getViewOrigin ().x + " " 
                                        + (ownerBrowser.getViewOrigin ().y + ownerBrowser.getViewSize ().height) + " " 
                                        + (ownerBrowser.getViewOrigin ().x + ownerBrowser.getViewSize ().width) + " " 
                                        + ownerBrowser.getViewOrigin ().y);
            }
         catch (IOException e)
            {
               System.out.println ("IOException on uplink (2), closing down");
               bailoutPoint.bailout ();
            }
         }
   }

   public void notifyShouldDisable (int numPaintsPending)
   {
      if (numPaintsPending > 1)
         {
         try
            {
            synchronized (uplinkStream)
               {
               uplinkStream.writeBytes ("Disable\r\n");
               netIdleIndicator.setValue (false);
               }         
            }
         catch (IOException e)
            {
            }
         }
   }
   public void notifyShouldEnable ()
   {
      try
         {
         synchronized (uplinkStream)
            {
            netIdleIndicator.setValue (true);
            uplinkStream.writeBytes ("Enable\r\n");
            }         
         }
      catch (IOException e)
         {
         }
   }

   public void paint (Graphics g, Rectangle region) 
   {
      Enumeration objects = selfObjects.elements ();
      while (objects.hasMoreElements ())
         {
         SelfMorph currMorph = ((SelfMorph) objects.nextElement ());
         if (currMorph.isWorldMorph ())
            {
            currMorph.paint (g, this, ownerBrowser.getViewOrigin ().x, ownerBrowser.getViewOrigin ().y, 
                             ownerBrowser.getViewOrigin ().x + ownerBrowser.getViewSize ().width, 
                             ownerBrowser.getViewOrigin ().y + ownerBrowser.getViewSize ().height, region);
            }
         }
//      netIdleIndicator.setValue (true);
   }

   public void printCoreSample (int x, int y)
   {
      Enumeration objects = selfObjects.elements ();
      while (objects.hasMoreElements ())
         {
         SelfMorph currMorph = ((SelfMorph) objects.nextElement ());
         if (currMorph.isWorldMorph ())
            {
            currMorph.printCoreSample (x + ownerBrowser.getViewOrigin ().x, y + ownerBrowser.getViewOrigin ().y, "");
            }
         }
   }

   public static final int SELF_BUTTON1_MASK = 256;
   public static final int SELF_BUTTON2_MASK = 512;
   public static final int SELF_BUTTON3_MASK = 1024;
   public static final int SELF_CONTROL_MASK = 4;
   public static final int SELF_SHIFT_MASK = 1;

   int getSelfState (Event evt)
   {
      int retval = 0;
      if ((evt.id == Event.MOUSE_DOWN) || (evt.id == Event.MOUSE_DRAG))
         {
         if ((evt.modifiers & Event.META_MASK) != 0)
            retval |= SELF_BUTTON3_MASK;
         else if ((evt.modifiers & Event.ALT_MASK) != 0)
            retval |= SELF_BUTTON2_MASK;
         else
            retval |= SELF_BUTTON1_MASK;            // No way to generate buttons 4 or 5
         }

/*
      if ((evt.modifiers & Event.CTRL_MASK) != 0)
         retval |= SELF_CONTROL_MASK;
      if ((evt.modifiers & Event.SHIFT_MASK) != 0)
         retval |= SELF_SHIFT_MASK;                 // No way to get logMask or mod[1-6]Mask
*/

      return (retval);
   }

   String getSelfEventType (Event evt, boolean doubleClick)
   {
      int selfState = getSelfState (evt);
      String whichButton;
      
      if ((evt.id == Event.MOUSE_MOVE) || (evt.id == Event.MOUSE_DRAG))
         return ("mouseMotion");

      if ((evt.modifiers & Event.SHIFT_MASK) != 0)      // Should be META_MASK to be normal
         whichButton = "right";
      else if ((evt.modifiers & Event.CTRL_MASK) != 0)  // Should be ALT_MASK to be normal
         whichButton = "middle";
      else
         whichButton = "left";

      if (doubleClick)
         return (whichButton + "DoubleClick");

      switch (evt.id)
         {
         case Event.MOUSE_DOWN:
            return (whichButton + "MouseDown");
         case Event.MOUSE_UP:
            return (whichButton + "MouseUp");

         case Event.KEY_PRESS:
         case Event.KEY_ACTION:
            return ("keyDown");
         case Event.KEY_RELEASE:
         case Event.KEY_ACTION_RELEASE:
            return ("keyUp");
         default:
            return ("ignore");
         }
   }

   long lastDownTime = 0;
   final static long DOUBLE_CLICK_TIME = 500;

   public boolean uiEvent (Event evt, int x, int y, int key)
   {
      if ((x < 0) || (y <0) ||
          (x > ownerBrowser.getViewSize ().width) ||
          (y > ownerBrowser.getViewSize ().height))
         return (false);

      if ((evt.id == Event.MOUSE_MOVE) || (evt.id == Event.MOUSE_DRAG))
         {
         if (myHandMorph != null)
            ((SelfMyHandMorph)myHandMorph).moveTo (ownerBrowser.getViewOrigin ().x + x, ownerBrowser.getViewOrigin ().y + y, this);
         }
 
      boolean doubleClick = false;
      if (evt.id == Event.MOUSE_DOWN) 
         {
         if ((evt.when - lastDownTime) < DOUBLE_CLICK_TIME)
            doubleClick = true;
         lastDownTime = evt.when;
         }
/*
      if (getSelfEventType (evt, doubleClick).equals ("middleMouseDown") && ((evt.modifiers & Event.ALT_MASK) != 0))
         {
         printCoreSample (x, y);
         return (true);
         }
*/
      try
         {
         if (caughtUpIndicator.getValue () || !getSelfEventType (evt, doubleClick).equals ("mouseMotion"))
            {
            synchronized (uplinkStream)
               {
               uplinkStream.writeBytes ("Event " + getSelfEventType (evt, doubleClick) + " " + 
                                        (int)(x + ownerBrowser.getViewOrigin ().x) + " " + 
                                        (int)(y + ownerBrowser.getViewOrigin ().y) + " " +
                                        getSelfState (evt) + " " + key + "\r\n"); 
               }

            System.out.println ("Event " + getSelfEventType (evt, doubleClick) + " " + 
                                     (int)(x + ownerBrowser.getViewOrigin ().x) + " " + 
                                     (int)(y + ownerBrowser.getViewOrigin ().y) + " " +
                                     getSelfState (evt) + " " + key + "   --- Thread priority: " + Thread.currentThread ().getPriority ());

//            System.out.println ("           ^^^^^                                            TS: " +
//                                 (System.currentTimeMillis () - app.startTimeMillis));

            if (getSelfEventType (evt, doubleClick).equals ("mouseMotion"))
               {
               caughtUpIndicator.setValue (false);
               }

            lastUnsentMouseMove = null;
            }
         else
            {
               // this message is being skipped
               lastUnsentMouseMove = evt;
            }
         }
      catch (IOException e)
         {
            System.out.println ("IOException on uplink (3), closing down");
            bailoutPoint.bailout ();
         }

      updateToolbarText ();
      return (true);
   }

   public Event lastUnsentMouseMove = null;


   void redrawRect (Rectangle r)
   {
//     netIdleIndicator.setValue (false);
      super.redrawRect (r);
   }
}

class CaughtUpIndicator extends IdleIndicator
{
   ViewerBrowserCore browser;

   CaughtUpIndicator (boolean initVal, ViewerBrowserCore browser)
   {
      super (initVal);
      this.browser = browser;
   }

   public void setBrowser (ViewerBrowserCore browser)
   {
      this.browser = browser;
   }

   public void setValue (boolean newVal)
   {
      super.setValue (newVal);
      if (browser == null)
         return;

      if ((value == true) && (browser.lastUnsentMouseMove != null))
         {
         browser.uiEvent (browser.lastUnsentMouseMove, 
                          browser.lastUnsentMouseMove.x,
                          browser.lastUnsentMouseMove.y, -1);
         }
   }
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------

class SecondChanceItem extends Object
{
   public SecondChanceItem (SelfMorph o, SecondChanceItem n)
   {
      item = o;
      next = n;
   }
   public SelfMorph item;
   public SecondChanceItem next;
}

class SecondChanceList extends Object
{
   protected SecondChanceItem head;
   protected SecondChanceItem tail;
   int size;
   int numItems;

   //----------------------------------------------------------------
   // Create a second chance list to hold size items
   //----------------------------------------------------------------
   public SecondChanceList (int size)
   {
      head = null;
      tail = null;

      this.size = size;
      numItems = 0;
   }

   //----------------------------------------------------------------
   // Insert o at the back of the queue, and, if the queue is full,
   // remove the item from the front and return it for the application
   // to deal with.  Return null if the queue is not yet full
   //----------------------------------------------------------------
   public synchronized SelfMorph insertGetVictim (SelfMorph o)
   {
      SelfMorph retval = null;

      if (head == null)
         {
         head = new SecondChanceItem (o, null);
         tail = head;
         numItems = 1;
         }
      else
         {
         // Add the new item
         tail.next = new SecondChanceItem (o, null);
         tail = tail.next;

         // Either bump numItems or remove one to make it up
         if (numItems >= size)
            {
            retval = head.item;
            head = head.next;
//            System.out.println ("SecondChanceList.insertGetVictim - inserted and victimized - size is still: " + numItems);
            }
         else
            {
            ++numItems;
//            System.out.println ("SecondChanceList.insertGetVictim - did not victimize - size is now: " + numItems);
            }
         }
      return (retval);
   }

   //----------------------------------------------------------------
   // Search out o and remove it if found.  Return true if found,
   // false otherwise
   //----------------------------------------------------------------
   public synchronized boolean findAndRemove (SelfMorph o)
   {
      SecondChanceItem trailerItem = null;
      SecondChanceItem tempItem = head;
      while (tempItem != null)
         {
         if (tempItem.item == o)
            {
            if (trailerItem == null)
               {
               head = tempItem.next;     // Found the first item, special case
               if (head == null)         // Found the only item
                  tail = null;
               }
            else
               {
               trailerItem.next = tempItem.next;
               if (trailerItem.next == null)
                  tail = trailerItem;         // Found the last item
               }
//            System.out.println ("SecondChanceList.findAndRemove - found and removed - size is: " + numItems);
            --numItems;
            return (true);
            }
         tempItem = tempItem.next;
         }
//      System.out.println ("SecondChanceList.findAndRemove - did not find - size is still: " + numItems);
      return (false);
   }
}
########################################################################
# Makefile for the java browser.  Not totally foolproof
#
# $Revision: 30.1 $
#     Andy Collins, Sun Microsystems Laboratories, Summer 1996
########################################################################

SelfViewer = SelfViewer.class
Utils = SelfObjectState.class
Viewer = ViewerBrowserCore.class
Structure = BrowserPanel.class
RadarViewer = RadarViewerBrowserCore.class
LensRadarViewer = LensRadarViewerBrowserCore.class
CutoutBrowser = CutoutBrowserPanel.class
SelfDisconnectButton = SelfDisconnectButton.class

all: $(SelfViewer) $(SelfDisconnectButton)

$(SelfViewer): SelfViewer.java $(Utils) $(RadarViewer) $(Viewer) \
               $(LensRadarViewer) $(Structure) $(CutoutBrowser)
	./makedate
	javac -cp . BuildInfo.java
	javac -cp . SelfViewer.java

$(Utils): Utils.java
	javac -cp . Utils.java

$(Viewer): Viewer.java $(Utils) $(Structure)
	javac -cp . Viewer.java

$(Structure): Structure.java $(Utils)
	javac -cp . Structure.java

$(RadarViewer): RadarViewer.java $(Utils) $(Structure)
	javac -cp . RadarViewer.java

$(LensRadarViewer): LensRadarViewer.java $(Utils) $(Structure)
	javac -cp . LensRadarViewer.java

$(CutoutBrowser): CutoutBrowser.java $(Structure) $(Utils)
	javac -cp . CutoutBrowser.java

$(SelfDisconnectButton): SelfDisconnectButton.java $(SelfViewer)
	javac -cp . SelfDisconnectButton.java
import java.awt.*;
import java.applet.Applet;
import java.io.*;
import java.net.*;
import java.util.*;

//-------------------------------------------------------------------------
// Kansas Java interface -- bringing Kansas to the Web
//
//   SelfViewer.java -- the top-level applet with navigation controls
//
// $Revision: 30.1 $
//      Andy Collins, Sun Microsystems Laboratories, Summer 1996
//-------------------------------------------------------------------------


//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
class LoginScreen extends Panel
{
   TextField loginName;
   TextField password;
   TextField hostname;
   TextField port;
   int defaultPort;

   public String getLoginName ()
   {
      return (loginName.getText ());
   }
   public String getPassword ()
   {
      return (password.getText ());
   }
   public String getHostname ()
   {
      return (hostname.getText ());
   }
   public int getPort ()
   {
      int d;
      try 
         {
         d = Integer.parseInt (port.getText ());
         }
      catch (NumberFormatException e)
         {
         d = defaultPort;
         }
      return (d);
   }

   public LoginScreen (String defaultHostname, int defaultPort)
   {
      this.defaultPort = defaultPort;

      GridBagLayout loginLayout = new GridBagLayout ();
      setLayout (loginLayout);

      GridBagConstraints topBottom = new GridBagConstraints ();
      topBottom.gridwidth = GridBagConstraints.REMAINDER;

      GridBagConstraints left = new GridBagConstraints ();
      left.anchor = GridBagConstraints.EAST;
      left.weightx = 1.0;
      GridBagConstraints right = new GridBagConstraints ();
      right.anchor = GridBagConstraints.WEST;
      right.gridwidth = GridBagConstraints.REMAINDER;
      right.weightx = 1.0;

      Component c = new Label ("Kansas login:");
      loginLayout.setConstraints (c, topBottom);
      add (c);

      c = new Label ("Name: ");
      loginLayout.setConstraints (c, left);
      add (c);
      loginName = new TextField ("java user", 20);
      loginLayout.setConstraints (loginName, right);
      add (loginName);

      c = new Label ("Password: ");
      loginLayout.setConstraints (c, left);
      add (c);
      password = new TextField (20);
      loginLayout.setConstraints (password, right);
      add (password);

      c = new Label ("Host: ");
      loginLayout.setConstraints (c, left);
      add (c);
      hostname = new TextField (defaultHostname, 30);
      loginLayout.setConstraints (hostname, right);
      add (hostname);

      c = new Label ("Port: ");
      loginLayout.setConstraints (c, left);
      add (c);
      port = new TextField (String.valueOf (defaultPort), 10);
      loginLayout.setConstraints (port, right);
      add (port);

      c = new Button ("Reconnect");
      loginLayout.setConstraints (c, topBottom);
      add (c);
   }
}

public class SelfViewer extends Applet implements BailInOut
{
   private BrowserPanel disp = null;

   LoginScreen stoppedMessage = null;
   Panel toolbar = null;
   Panel indicators = null;
   Label toolbarText = null;
   Button navButtons[]= new Button[8];       // NW N NE W E SW S SE

   boolean canStart = true;

   public long startTimeMillis = 0;

   CaughtUpIndicator caughtUpIndicator;
   IdleIndicator netIdleIndicator;

   String hostname;
   int port;
   Point viewOrigin;

   String getParam (String p, String d)
   {
      String s = getParameter (p);
      if (s == null)
         return (d);
      else
         return (s);
   }
   int getParam (String p, int d)
   {
      try 
         {
         d = Integer.parseInt (getParameter (p));
         }
      catch (NumberFormatException e)
         {
         }
      return (d);
   }
   double getParam (String p, double d)
   {
      try 
         {
         d = Double.valueOf (getParameter (p)).doubleValue ();
         }
      catch (NumberFormatException e)
         {
         }
      catch (NullPointerException e)
         {
         }
      return (d);
   }

   public void init ()
   {
      URL docURL = getDocumentBase ();
      if (docURL != null)
         {
         hostname = docURL.getHost ();
         System.out.println ("Got hostname: " + hostname);
         }
      else
         hostname = getParam ("hostname", "localhost");

      port = getParam ("port", 1420);
      viewOrigin = new Point (getParam ("xorigin", 0), getParam ("yorigin", 0));

      
      startTimeMillis = System.currentTimeMillis ();
/*
      stoppedMessage = new Panel ();
      stoppedMessage.setLayout (new FlowLayout (FlowLayout.CENTER, 10, 50));
      stoppedMessage.add (new Label ("Disconnected", Label.CENTER));
      stoppedMessage.add (new Button ("Reconnect"));
*/
      stoppedMessage = new LoginScreen (hostname, port);

      toolbar = new Panel ();
      toolbar.setLayout (new BorderLayout ());
      toolbarText = new Label ("-");
      toolbar.add ("Center", toolbarText);
      
      caughtUpIndicator = new CaughtUpIndicator (true, null);
      netIdleIndicator = new IdleIndicator (false);

      indicators = new Panel ();
      indicators.setLayout (new FlowLayout ());
      netIdleIndicator.resize (15, 15);
      indicators.add (netIdleIndicator);
      caughtUpIndicator.resize (15, 15);
      indicators.add (caughtUpIndicator);

      toolbar.add ("East", indicators);

      navButtons[0] = new Button ("NW");
      navButtons[1] = new Button ("N");
      navButtons[2] = new Button ("NE");
      navButtons[3] = new Button ("W");
      navButtons[4] = new Button ("E");
      navButtons[5] = new Button ("SW");
      navButtons[6] = new Button ("S");
      navButtons[7] = new Button ("SE");

      Container north = new Panel ();
      north.setLayout (new BorderLayout ());
      north.add ("East", navButtons[2]);
      north.add ("Center", navButtons[1]);
      north.add ("West", navButtons[0]);
      north.add ("North", new Label ("Kansas viewer: built " + BuildInfo.buildDate + " on host " + BuildInfo.buildHost));

      Container south = new Panel ();
      south.setLayout (new BorderLayout ());
      south.add ("East", navButtons[7]);
      south.add ("Center", navButtons[6]);
      south.add ("West", navButtons[5]);
      south.add ("South", toolbar);

      setLayout (new BorderLayout ());
      add ("North", north);
      add ("South", south);
      add ("East", navButtons[4]);
      add ("West", navButtons[3]);
      add ("Center", stoppedMessage);
      resize (size ().width, size ().height);

// Do not automatically start the viewer.  Instead, start at the login screen
//      bailin ();
   }

   public void destroy ()
   {
      if (disp != null)
         disp.bailout ();
   }

   public void start ()
   {
   }

   public void bailin ()
   {
      // bail out if we can't init in 10 sec
      BailoutTimer initTimeout = new BailoutTimer ((BailInOut) this, 10000);

      if ((disp == null) && canStart)
         {
         System.out.println ("  starting");

         BrowserPanel browser = null;

         boolean cutout = (getParam ("showCutoutLens", "false").equals ("true"));
         boolean radarViewer = (getParam ("showRadarView", "false").equals ("true"));
         boolean lensRadarViewer = (getParam ("showLensRadarView", "false").equals ("true"));

         if (cutout)
            {
            browser = new CutoutBrowserPanel (null, null, viewOrigin, toolbarText, getParam ("lensInnerRadiusFactor", 0.6));
            BrowserCore insideCore = new ViewerBrowserCore (browser, (BailInOut) this, 
                                                            stoppedMessage.getHostname (), stoppedMessage.getPort (),
                                                            stoppedMessage.getLoginName (), stoppedMessage.getPassword (),
                                                            caughtUpIndicator, netIdleIndicator);
            caughtUpIndicator.setBrowser ((ViewerBrowserCore) insideCore);
            ((CutoutBrowserPanel)browser).setInsideBrowserCore (insideCore);

            BrowserCore outsideCore = new LensRadarViewerBrowserCore (browser, (BailInOut) this, 
                                                                 stoppedMessage.getHostname (), stoppedMessage.getPort (),
                                                                      getParam ("lensInnerRadiusFactor", 0.6));
            ((CutoutBrowserPanel)browser).setOutsideBrowserCore (outsideCore);
            }
         else
            {
            browser = new BrowserPanel (null, viewOrigin, toolbarText);
            BrowserCore core = null;

            if (radarViewer)
               {
               core = new RadarViewerBrowserCore (browser, (BailInOut) this, 
                                                  stoppedMessage.getHostname (), stoppedMessage.getPort (),
                                                  getParam ("radarXScale", 10.0), getParam ("radarYScale", 10.0));   
               caughtUpIndicator.setBrowser (null);
               }
            else if (lensRadarViewer)
               {
               core = new LensRadarViewerBrowserCore (browser, (BailInOut) this, 
                                                      stoppedMessage.getHostname (), stoppedMessage.getPort (),
                                                      getParam ("lensInnerRadiusFactor", 0.6));
               caughtUpIndicator.setBrowser (null);
               }
            else
               {
               core = new ViewerBrowserCore (browser, (BailInOut) this, 
                                             stoppedMessage.getHostname (), stoppedMessage.getPort (),
                                             stoppedMessage.getLoginName (), stoppedMessage.getPassword (), 
                                             caughtUpIndicator, netIdleIndicator);
               caughtUpIndicator.setBrowser ((ViewerBrowserCore) core);
               }

            browser.setBrowserCore (core);
            }

         disp = browser;
         if (stoppedMessage != null)
            remove (stoppedMessage);
         add ("Center", disp);
         resize (size ().width, size ().height);
         validate ();
         repaint ();

         if (disp != null)
            disp.bailin ();

         if (disp != null)      // failure here is an indication of failure to bailin
            {
            for (int i=0; i<8; ++i)
               navButtons[i].enable ();

            caughtUpIndicator.setValue (true);
            netIdleIndicator.setValue (false);
            }
         }

      // If we make it here in time, cancel the timeout
      initTimeout.stop ();
   }

   public void stop ()
   {
   }

   public synchronized void bailout ()
   {
      if ((disp != null) && (stoppedMessage != null))
         {
         System.out.println ("Bailing out applet");
         remove (disp);
         add ("Center", stoppedMessage);
         resize (size ().width, size ().height);
         validate ();
         repaint ();

         BrowserPanel tempDisp = disp;

         disp = null;
         updateToolbarText ();

         for (int i=0; i<8; ++i)
            navButtons[i].disable ();

         System.out.println ("About to bailout display");
         tempDisp.bailout ();
         // May not get past here, since this thread might be monitorThread, which just
         // got killed as the last step of the destroy
         System.out.println ("Back from that");
         }
      else
         System.out.println ("Couldn't bail out");
   }

   public void updateToolbarText ()
   {
      if (disp == null)
         toolbarText.setText ("disconnected.");
      else
         toolbarText.setText ("connected");
/*
         toolbarText.setText ("" + ((int) disp.xViewOrigin + disp.xMouseLoc) + ", " + 
                                   ((int) disp.yViewOrigin + disp.yMouseLoc) + "  " +
                                   disp.selfObjects.size () + " object" + 
                                   ((disp.selfObjects.size () == 1) ? "." : "s."));
*/
   }

   public boolean action (Event evt, Object obj)
   {
      if (evt.target instanceof Button)
         {
         String label = (String) obj;

         if (label.equals ("Reconnect"))
            {
            System.out.println ("Reconnecting...");
            bailin ();
            return (true);
            }

         disp.moveTowards (label);

         return (true);
         }
      return (false);
   }
}

package com.sun.kanban.parser_framework; 

import java.io.*;

import com.sun.kanban.parser_framework.lexer.input_streams.*;

interface bazorp extends apple, orange {}

abstract public class ParserTest extends foo.bar implements foo, a.b {
  static {foo = 12;}

  ParserTest(int a, Foo[][][] b) {foo = bar;}

  ParserTest a() {foo = bar;}
 int x = 12;
 Blort foo() {}
 ParserTest() {snort();}

 static { snort = 5; }

	
	abstract public void test(LexerInputStream s, boolean _print );
	
	abstract protected FilenameFilter filter();
	
	public void test_string(String s) {
		System.out.println("Input is: " + s);
		test((new StringLexerInputStream(s)), true);
	}

	public void test_file(String path) {
		System.out.println("Input is file: " + path);
		test((new FileLexerInputStream(path)), true);
	}
	
	public void test_directory(String dir_path) {
		File d = new File(dir_path);
		String names[] = d.list(filter());
		for (int i = 0;  i < names.length;  ++i) {
			test((new FileLexerInputStream(d.getAbsolutePath() + "/" + names[i])), false);
		}
		System.out.println("Done with " + names.length + " files.");
	}
}
class a {
  b c() { 
    while ( 23 ) 12
  }
}
class a {
  int b() { return ; }
}
class a {
  b c() { if ( 23 ) else }
}
class a {
  int b() { while (int)
                   ; }
}
class a {
  int b() { while (snort.bar())
                   ; }
}
class a {
  int foo() { synchronized ( 3 ) {  }
}
class a {
 b c() { foo: {}; }
}
class a {
 int a() {
   break 23
 }
}
class a {
  b c() {
    do ; while
  }
}
class a {
  b c() {
    for ( 12, 13; 14 ; 15, )
      23;
  }
}
class a {
  int b() { while ((3).) ; }
}
class a {
  int b() { while ( a += -= d)
                   ; }
}
class a {
  static 3 * 4 {}
};
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input()   /*-->*/ ( /*<--*/  == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Opening `(' does not match closing `}' in <<(Input()   /*-->*/ ( /*<--*/  == null)
	Running();
      else
	PacketPending();
    }>> at: [10@240, 5@244] */
class a {
  int b() { while (snort.bar[])
                   ; }
}
class a {
 int b() { throw ; }
}
class a {
  int b() { while (snort.bar)
                   ; }
}
class a {
  b c() { 
    while (
  }
}
class a {
  b c() {
    do ; while ( 23 )
  }
}
class a {
int snort() throws foo, {}
}
package foo.;
class a {
  int b() { while (3 instanceof )
                   ; }
}
class a {
  int b() { while (super.) super(12) ; }
}
class a {
  int b() { return 2 3; }
}
class a {
  int b() { while ((3).foo) ; }
}
class a {
  int b() { while (new fred.bob(1, 2) {})
                   ; }
}
class a.b extends c.d {}
class x {
  y z() {
    234;
  }
}
class a {
 a.b snort(c.d e, foo bar) {}
}
class a {
  int foo = {5, 34 ; 23};
}
class a {
  b c() { if ; }
}
class a {
  int b() { while (snort.bar.super(foo))
                   ; }
}
class a {
  int b() { while (new int)
                   ; }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new /*-->> TaskState <<--*/()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Expected a type such as int or class-name, but found <<()>> at: [69@491, 70@491] */
class a {
int snort() throws {}
}
class a {
  private static a.b.c snort;
}
/*
 * Copyright (c) 1997 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * This software is the confidential and proprietary information of Sun
 * Microsystems, Inc. ("Confidential Information").  You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Sun.
 * 
 * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
 * SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR ANY DAMAGES
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
 * THIS SOFTWARE OR ITS DERIVATIVES.
 * 
 */

/**=============================================================================
 * Interpreter.java
 *
 * This class implements a Java bytecode interpreter for the 
 * Java in Java VM.
 *
 * @system      JJava (Java in Java VM)
 * @subsystem   Bytecode interpreter
 * @author      Antero Taivalsaari, Sun Labs
 * @created     14 Oct 1997
 * @see         JJava.java, Method.java, ExecutionStack.java, ...
 *============================================================================*/

import java.io.*;
import java.util.*;
import Bytecodes;
// package JJava;

public
class Interpreter extends InternalObject {

/*==============================================================================
 * Constants
 *============================================================================*/


/*==============================================================================
 * Fields
 *============================================================================*/


/*==============================================================================
 * Constructors
 *============================================================================*/

    /**
     * Prevent the instantiation of this class.
     */
    private Interpreter() {}

/*==============================================================================
 * Internal methods
 *============================================================================*/

/*==============================================================================
 * The bytecode interpreter
 *============================================================================*/

    /**
     * interpret: this is the big kabloona; bytecode interpreter for 
     * running Java bytecodes. In order to operate, there must be an
     * active thread which contains the necessary virtual machine
     * registers.
     */
    public static void Interpret() {

      while (true) {
          
        // Get the bytecode to be executed
        byte bytecode = VM.get_instruction();

        System.out.println("Executing bytecode " + Bytecodes.get_bytecode_name(bytecode));

        switch (bytecode) {

        case Bytecodes.NOP:                       // 0x00
            break; 

        case Bytecodes.ACONST_NULL:               // 0x01
            VM.push(null);
            break;

        /*============================================================================*/

        case Bytecodes.ICONST_M1:                 // 0x02;
            VM.push(new Integer(-1));
            break;

        case Bytecodes.ICONST_0:                  // 0x03;
            VM.push(new Integer(0));
            break;

        case Bytecodes.ICONST_1:                  // 0x04;
            VM.push(new Integer(1));
            break;

        case Bytecodes.ICONST_2:                  // 0x05;
            VM.push(new Integer(2));
            break;

        case Bytecodes.ICONST_3:                  // 0x06;
            VM.push(new Integer(3));
            break;

        case Bytecodes.ICONST_4:                  // 0x07;
            VM.push(new Integer(4));
            break;

        case Bytecodes.ICONST_5:                  // 0x08;
            VM.push(new Integer(5));
            break;

        /*============================================================================*/

        case Bytecodes.LCONST_0:                  // 0x09;
            VM.push(new Long(0));
            break;

        case Bytecodes.LCONST_1:                  // 0x0A;
            VM.push(new Long(1));
            break;

        /*============================================================================*/

        case Bytecodes.FCONST_0:                  // 0x0B;   
            VM.push(new Float(0));
            break;

        case Bytecodes.FCONST_1:                  // 0x0C;
            VM.push(new Float(1));
            break;

        case Bytecodes.FCONST_2:                  // 0x0D;
            VM.push(new Float(2));
            break;

        /*============================================================================*/

        case Bytecodes.DCONST_0:                  // 0x0E;
            VM.push(new Double(2));
            break;

        case Bytecodes.DCONST_1:                  // 0x0F;
            VM.push(new Double(2));
            break;

        /*============================================================================*/

        case Bytecodes.BIPUSH:                    // 0x10;
            VM.push(new Integer(VM.get_inlined_parameter_byte1()));
            VM.increment_bcp(1);
            break;

        case Bytecodes.SIPUSH:                    // 0x11;
            VM.push(new Integer(VM.get_inlined_parameter_short1()));
            VM.increment_bcp(2);
            break;
        
        /*============================================================================*/

        case Bytecodes.LDC:                       // 0x12;
            VM.increment_bcp(1);
            break;
        
        case Bytecodes.LDC_W:                     // 0x13;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.LDC2_W:                    // 0x14;
            VM.increment_bcp(2);
            break;
        
        /*============================================================================*/

        case Bytecodes.ILOAD:                     // 0x15;
            VM.increment_bcp(1);
            break;
        
        case Bytecodes.LLOAD:                     // 0x16;
            VM.increment_bcp(1);
            break;
        
        case Bytecodes.FLOAD:                     // 0x17;
            VM.increment_bcp(1);
            break;

        case Bytecodes.DLOAD:                     // 0x18;
            VM.increment_bcp(1);
            break;
        
        case Bytecodes.ALOAD:                     // 0x19;
            VM.increment_bcp(1);
            break;
        
        /*============================================================================*/

        case Bytecodes.ILOAD_0:                   // 0x1A;
            break;
        
        case Bytecodes.ILOAD_1:                   // 0x1B;
            break;
        
        case Bytecodes.ILOAD_2:                   // 0x1C;
            break;
        
        case Bytecodes.ILOAD_3:                   // 0x1D;
            break;
        
        /*============================================================================*/

        case Bytecodes.LLOAD_0:                   // 0x1E;
            break;
        
        case Bytecodes.LLOAD_1:                   // 0x1F;
            break;

        case Bytecodes.LLOAD_2:                   // 0x20;
            break;
        
        case Bytecodes.LLOAD_3:                   // 0x21;
            break;
        
        /*============================================================================*/

        case Bytecodes.FLOAD_0:                   // 0x22;
            break;
        
        case Bytecodes.FLOAD_1:                   // 0x23;
            break;
        
        case Bytecodes.FLOAD_2:                   // 0x24;
            break;
        
        case Bytecodes.FLOAD_3:                   // 0x25;
            break;
        
        /*============================================================================*/

        case Bytecodes.DLOAD_0:                   // 0x26;
            break;
        
        case Bytecodes.DLOAD_1:                   // 0x27;
            break;

        case Bytecodes.DLOAD_2:                   // 0x28;
            break;
        
        case Bytecodes.DLOAD_3:                   // 0x29;
            break;
        
        /*============================================================================*/

        case Bytecodes.ALOAD_0:                   // 0x2A;
            break;
        
        case Bytecodes.ALOAD_1:                   // 0x2B;
            break;
        
        case Bytecodes.ALOAD_2:                   // 0x2C;
            break;
        
        case Bytecodes.ALOAD_3:                   // 0x2D;
            break;
        
        /*============================================================================*/

        case Bytecodes.IALOAD:                    // 0x2E;
            break;
        
        case Bytecodes.LALOAD:                    // 0x2F;
            break;

        case Bytecodes.FALOAD:                    // 0x30;
            break;
        
        case Bytecodes.DALOAD:                    // 0x31;
            break;
        
        case Bytecodes.AALOAD:                    // 0x32;
            break;
        
        case Bytecodes.BALOAD:                    // 0x33;
            break;
        
        case Bytecodes.CALOAD:                    // 0x34;
            break;
        
        case Bytecodes.SALOAD:                    // 0x35;
            break;
        
        /*============================================================================*/

        case Bytecodes.ISTORE:                    // 0x36;
            VM.increment_bcp(1);
            break;
        
        case Bytecodes.LSTORE:                    // 0x37;
            VM.increment_bcp(1);
            break;

        case Bytecodes.FSTORE:                    // 0x38;
            VM.increment_bcp(1);
            break;
        
        case Bytecodes.DSTORE:                    // 0x39;
            VM.increment_bcp(1);
            break;
        
        case Bytecodes.ASTORE:                    // 0x3A;
            VM.increment_bcp(1);
            break;
        
        /*============================================================================*/

        case Bytecodes.ISTORE_0:                  // 0x3B;
            break;
        
        case Bytecodes.ISTORE_1:                  // 0x3C;
            break;
        
        case Bytecodes.ISTORE_2:                  // 0x3D;
            break;
        
        case Bytecodes.ISTORE_3:                  // 0x3E;
            break;
        
        /*============================================================================*/

        case Bytecodes.LSTORE_0:                  // 0x3F;
            break;

        case Bytecodes.LSTORE_1:                  // 0x40;
            break;
        
        case Bytecodes.LSTORE_2:                  // 0x41;
            break;
        
        case Bytecodes.LSTORE_3:                  // 0x42;
            break;
        
        /*============================================================================*/

        case Bytecodes.FSTORE_0:                  // 0x43;
            break;
        
        case Bytecodes.FSTORE_1:                  // 0x44;
            break;
        
        case Bytecodes.FSTORE_2:                  // 0x45;
            break;
        
        case Bytecodes.FSTORE_3:                  // 0x46;
            break;
        
        /*============================================================================*/

        case Bytecodes.DSTORE_0:                  // 0x47;
            break;

        case Bytecodes.DSTORE_1:                  // 0x48;
            break;
        
        case Bytecodes.DSTORE_2:                  // 0x49;
            break;
        
        case Bytecodes.DSTORE_3:                  // 0x4A;
            break;
        
        /*============================================================================*/

        case Bytecodes.ASTORE_0:                  // 0x4B;
            break;
        
        case Bytecodes.ASTORE_1:                  // 0x4C;
            break;
        
        case Bytecodes.ASTORE_2:                  // 0x4D;
            break;
        
        case Bytecodes.ASTORE_3:                  // 0x4E;
            break;
        
        /*============================================================================*/

        case Bytecodes.IASTORE:                   // 0x4F;
            break;

        case Bytecodes.LASTORE:                   // 0x50;
            break;
        
        case Bytecodes.FASTORE:                   // 0x51;
            break;
        
        case Bytecodes.DASTORE:                   // 0x52;
            break;
        
        case Bytecodes.AASTORE:                   // 0x53;
            break;
        
        case Bytecodes.BASTORE:                   // 0x54;
            break;
        
        case Bytecodes.CASTORE:                   // 0x55;
            break;
        
        case Bytecodes.SASTORE:                   // 0x56;
            break;
        
        /*============================================================================*/

        case Bytecodes.POP:                       // 0x57;
            break;

        case Bytecodes.POP2:                      // 0x58;
            break;
        
        case Bytecodes.DUP:                       // 0x59;
            break;
        
        case Bytecodes.DUP_X1:                    // 0x5A;
            break;
        
        case Bytecodes.DUP_X2:                    // 0x5B;
            break;
        
        case Bytecodes.DUP2:                      // 0x5C;
            break;
        
        case Bytecodes.DUP2_X1:                   // 0x5D;
            break;
        
        case Bytecodes.DUP2_X2:                   // 0x5E;
            break;
        
        case Bytecodes.SWAP:                      // 0x5F;
            break;

        /*============================================================================*/

        case Bytecodes.IADD:                      // 0x60;
            break;
        
        case Bytecodes.LADD:                      // 0x61;
            break;
        
        case Bytecodes.FADD:                      // 0x62;
            break;
        
        case Bytecodes.DADD:                      // 0x63;
            break;
        
        /*============================================================================*/

        case Bytecodes.ISUB:                      // 0x64;
            break;
        
        case Bytecodes.LSUB:                      // 0x65;
            break;
        
        case Bytecodes.FSUB:                      // 0x66;
            break;
        
        case Bytecodes.DSUB:                      // 0x67;
            break;
        
        /*============================================================================*/

        case Bytecodes.IMUL:                      // 0x68;
            break;
        
        case Bytecodes.LMUL:                      // 0x69;
            break;
        
        case Bytecodes.FMUL:                      // 0x6A;
            break;
        
        case Bytecodes.DMUL:                      // 0x6B;
            break;
        
        /*============================================================================*/

        case Bytecodes.IDIV:                      // 0x6C;
            break;
        
        case Bytecodes.LDIV:                      // 0x6D;
            break;
        
        case Bytecodes.FDIV:                      // 0x6E;
            break;
        
        case Bytecodes.DDIV:                      // 0x6F;
            break;

        /*============================================================================*/

        case Bytecodes.IREM:                      // 0x70;
            break;
        
        case Bytecodes.LREM:                      // 0x71;
            break;
        
        case Bytecodes.FREM:                      // 0x72;
            break;
        
        case Bytecodes.DREM:                      // 0x73;
            break;
        
        /*============================================================================*/

        case Bytecodes.INEG:                      // 0x74;
            break;
        
        case Bytecodes.LNEG:                      // 0x75;
            break;
        
        case Bytecodes.FNEG:                      // 0x76;
            break;
        
        case Bytecodes.DNEG:                      // 0x77;
            break;

        /*============================================================================*/

        case Bytecodes.ISHL:                      // 0x78;
            break;
        
        case Bytecodes.LSHL:                      // 0x79;
            break;
        
        case Bytecodes.ISHR:                      // 0x7A;
            break;
        
        case Bytecodes.LSHR:                      // 0x7B;
            break;
        
        case Bytecodes.IUSHR:                     // 0x7C;
            break;
        
        case Bytecodes.LUSHR:                     // 0x7D;
            break;
        
        /*============================================================================*/

        case Bytecodes.IAND:                      // 0x7E;
            break;
        
        case Bytecodes.LAND:                      // 0x7F;
            break;

        case Bytecodes.IOR:                       // 0x80;
            break;
        
        case Bytecodes.LOR:                       // 0x81;
            break;
        
        case Bytecodes.IXOR:                      // 0x82;
            break;
        
        case Bytecodes.LXOR:                      // 0x83;
            break;
        
        /*============================================================================*/

        case Bytecodes.IINC:                      // 0x84;
            VM.increment_bcp(2);
            break;
        
        /*============================================================================*/

        case Bytecodes.I2L:                       // 0x85;
            break;
        
        case Bytecodes.I2F:                       // 0x86;
            break;
        
        case Bytecodes.I2D:                       // 0x87;
            break;

        case Bytecodes.L2I:                       // 0x88;
            break;
        
        case Bytecodes.L2F:                       // 0x89;
            break;
        
        case Bytecodes.L2D:                       // 0x8A;
            break;
        
        case Bytecodes.F2I:                       // 0x8B;
            break;
        
        case Bytecodes.F2L:                       // 0x8C;
            break;
        
        case Bytecodes.F2D:                       // 0x8D;
            break;
        
        case Bytecodes.D2I:                       // 0x8E;
            break;
        
        case Bytecodes.D2L:                       // 0x8F;
            break;

        case Bytecodes.D2F:                       // 0x90;
            break;
        
        case Bytecodes.I2B:                       // 0x91;
            break;
        
        case Bytecodes.I2C:                       // 0x92;
            break;
        
        case Bytecodes.I2S:                       // 0x93;
            break;
        
        /*============================================================================*/

        case Bytecodes.LCMP:                      // 0x94;
            break;
        
        case Bytecodes.FCMPL:                     // 0x95;
            break;
        
        case Bytecodes.FCMPG:                     // 0x96;
            break;
        
        case Bytecodes.DCMPL:                     // 0x97;
            break;

        case Bytecodes.DCMPG:                     // 0x98;
            break;
        
        /*============================================================================*/

        case Bytecodes.IFEQ:                      // 0x99;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IFNE:                      // 0x9A;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IFLT:                      // 0x9B;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IFGE:                      // 0x9C;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IFGT:                      // 0x9D;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IFLE:                      // 0x9E;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IF_ICMPEQ:                 // 0x9F;
            VM.increment_bcp(2);
            break;

        case Bytecodes.IF_ICMPNE:                 // 0xA0;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IF_ICMPLT:                 // 0xA1;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IF_ICMPGE:                 // 0xA2;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IF_ICMPGT:                 // 0xA3;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IF_ICMPLE:                 // 0xA4;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IF_ACMPEQ:                 // 0xA5;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IF_ACMPNE:                 // 0xA6;
            VM.increment_bcp(2);
            break;
        
        /*============================================================================*/

        case Bytecodes.GOTO:                      // 0xA7;
            VM.increment_bcp(2);
            break;

        case Bytecodes.JSR:                       // 0xA8;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.RET:                       // 0xA9;
            VM.increment_bcp(1);
            break;
        
        /*============================================================================*/

        case Bytecodes.TABLESWITCH:               // 0xAA;
            break;

        case Bytecodes.LOOKUPSWITCH:              // 0xAB;
            break;
        
        /*============================================================================*/

        case Bytecodes.IRETURN:                   // 0xAC;
            System.exit(0);
            break;
        
        case Bytecodes.LRETURN:                   // 0xAD;
            System.exit(0);
            break;
        
        case Bytecodes.FRETURN:                   // 0xAE;
            System.exit(0);
            break;
        
        case Bytecodes.DRETURN:                   // 0xAF;
            System.exit(0);
            break;

        case Bytecodes.ARETURN:                   // 0xB0;
            System.exit(0);
            break;
        
        case Bytecodes.RETURN:                    // 0xB1;
            System.exit(0);
            break;
        
        /*============================================================================*/

        case Bytecodes.GETSTATIC:                 // 0xB2;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.PUTSTATIC:                 // 0xB3;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.GETFIELD:                  // 0xB4;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.PUTFIELD:                  // 0xB5;
            VM.increment_bcp(2);
            break;
        
        /*============================================================================*/

        case Bytecodes.INVOKEVIRTUAL:             // 0xB6;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.INVOKESPECIAL:             // 0xB7;
            VM.increment_bcp(2);
            break;

        case Bytecodes.INVOKESTATIC:              // 0xB8;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.INVOKEINTERFACE:           // 0xB9;
            VM.increment_bcp(4);
            break;
        
        /*============================================================================*/

        case Bytecodes.UNUSED:                    // 0xBA;
            break;
        
        /*============================================================================*/

        case Bytecodes.NEW:                       // 0xBB;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.NEWARRAY:                  // 0xBC;
            VM.increment_bcp(1);
            break;
        
        case Bytecodes.ANEWARRAY:                 // 0xBD;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.ARRAYLENGTH:               // 0xBE;
            break;
        
        /*============================================================================*/

        case Bytecodes.ATHROW:                    // 0xBF;
            break;

        case Bytecodes.CHECKCAST:                 // 0xC0;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.INSTANCEOF:                // 0xC1;
            VM.increment_bcp(2);
            break;
        
        /*============================================================================*/

        case Bytecodes.MONITORENTER:              // 0xC2;
            break;
        
        case Bytecodes.MONITOREXIT:               // 0xC3;
            break;
        
        /*============================================================================*/

        case Bytecodes.WIDE:                      // 0xC4;
            break;
        
        /*============================================================================*/

        case Bytecodes.MULTIANEWARRAY:            // 0xC5;
            VM.increment_bcp(3);
            break;
        
        /*============================================================================*/

        case Bytecodes.IFNULL:                    // 0xC6;
            VM.increment_bcp(2);
            break;
        
        case Bytecodes.IFNONNULL:                 // 0xC7;
            VM.increment_bcp(2);
            break;

        /*============================================================================*/

        case Bytecodes.GOTO_W:                    // 0xC8;
            VM.increment_bcp(4);
            break;
        
        case Bytecodes.JSR_W:                     // 0xC9;
            VM.increment_bcp(4);
            break;
        
        /*============================================================================*/

        case Bytecodes.BREAKPOINT:                // 0xCA;
            break;
        
        /*============================================================================*/

        default:
            throw new RuntimeException("Runtime exception: illegal bytecode encountered");
        }

        // Proceed to the next bytecode to be executed
        VM.increment_bcp(1);

    }
  }
}
class a {
  b c() { if ( 23 }
}
class a {
  int b() { while (super)  ; }
}
class a {
  int b() { while (new)
                   ; }
}
class a {
  b c() {
   do ; while ( 23 ) ;
  }
}
class a {
 static {  ; }
}
class a {
  int b() { while (int[][].class)
                   ; }
}
class a {
  protected c.d foo, bar, baz;
};
class a {
int snort() throws 32 {}
}
class a {
  int b() { return return }
}
import a;
package b;
class a {
  b c() { if ( }
}

class a {
  b c() {
    for ()
  }
}
class a {
  int b() { while (this) this(true , false, null ) ; }
}
class a {
  int b() { while ((int)foo) ; }
}
class a {
 static { private ; }
}
class a extends c.d implements x, {}
class a {
  int b() { while (snort.bar.new foo)
                   ; }
}
class a {
  int b() { while (--foo) ; }
}
class a {
  b c() {
    for ( ; ; )
      23;
  }
}
interface snort {
  static {a = 3;}
}
class a {
  int foo = 5;
}
class a {
  b c() { 
    while 23
  }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count /*-->> + <<--*/ 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Extra junk found at end of expresion <<1>> at: [41@352, 41@352] */
class a {
  int b() { while (3 instanceof schlep)
                   ; }
}
class simple {}
interface simple {}
class a {
  b c() {
    for ( int foo = 12; ; )
      23;
  }
}
class me ;
package a;
import b;
import b.c;
import b.c.*;
class a {
  b c() { if }
}
class a {
  int foo(snort 34) {}
}
class a {
  b c() { try {} catch {} }
}
class a {
  b c() {
    do 23
  }
}
class a {
  int b() { while (()) ; }
}
class a {
  int b() { while (void 23)
                   ; }
}
class a {
 b c() { foo: bar: {}; }
}
class a {
 int foo() {
   try 23;
 }
}
class a {
  b c() { 
    while ( 23 )
  }
}
class a {
  int b() { while (++) ; }
}
class a {
  int foo() { synchronized ( {} ) ; }
}
class a {
  b.c() {}
};
class a {
  int b() {
    switch 23
  }
}
class a extends c.d implements x, y.z {}
interface b extends c.d, e.f {}
class a {
  int b() { while ( a += c -= d)
                   ; }
}
class a {
  public Foo +() {}
}
class a {
  int b() { while ( a ?x  ? b : snort : bar)
                   ; }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.  /*-->*/ ( /*<--*/  get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Opening `(' does not match closing `}' in <<(Task.get_queuePacketCount() == 23246 && Task.  /*-->*/ ( /*<--*/  get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }>> at: [10@496, 5@502] */
class a {
  int b() { while (new int[][]{2, 3} )
                   ; }
}
class a {
  int b() { while (snort.bar.new)
                   ; }
}
class a {
  int b() { while (void.)
                   ; }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState   /*-->*/ . /*<--*/  s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* formal paramater name must be an identifier <<,>> at: [71@323, 71@323] */
class a {
  int b() { while (super()) super(12) ; }
}
class a {
 int a() {
   break ;
 }
}
class a {
  int b() {
    switch ( 34 ) foo
    
  }
}
class a {
  int b() { while (snort.bar.this)
                   ; }
}
class a {
  int b() { try {} catch (foobar up) {} finally }
}
class a {
 static {   {;} }
}
class 23 {}
class a {
  int b() { while (int.class)
                   ; }
}
class a {
  int b() { while ( a ? b 23)
                   ; }
}
class a {
  int b() { while () ; }
}
class a {
  int foo() { synchronized 23 ; }
}
class a {
 int b() { throw }
}
class a {
  b c() { 
   if ( 23 )
      if (2) 3 ;
      else 4 ;
   else {} }
}
class a {
  int b() { while (new fred.bob(1, 2))
                   ; }
}
class a {
  int b() { while ( a ? b : snort)
                   ; }
}
interface foo {
  int snort() {  }
}
class a {
 static { final int a; }
}
class a {
  int b() { while ((int.class)+foo) ; }
}
class a {
  b c() { if ( 23 ) 32 ; else {} }
}
class a {
  int b() { while ( a ? ? b : snort : bar)
                   ; }
}
package a.b 34;
class a {
  int b() { try {} catch }
}
class a {
  int b() { while ((3).new dribble(foo)) ; }
}
class a {
  private long ;
};
class a {
  b c() {
    for ( 12, 13; ; )
      23;
  }
}
{
foobar
(snort)
]
import a;
;
import b;
class a {
  int foo(snort) {}
}
class a {
  b c() {
    for ( 12, 13; 14 ; 15)
      23;
  }
}
class a {
  int b() { while ((3).new dribble(foo) {int a; }) ; }
}
class a {
  b c() { if ( 23 ) 32 ; else }
}
class a {
 int foo {}
}
class a {
  int b() { while ((snort)foo) ; }
}
class a {
  private int snort( g.c x y) {}
}
class a {
  int b() { while (snort.bar[][].class)
                   ; }
}


class a {
  b c() {
    for ;
  }
}
class a {
 static {  static {} }
}
class a {
  int b() { while ((3)++) ; }
}
class a {
  b c() {
    do
  }
}
class a {
  static {}
};
class a extends b, c {}
class a {
  int snort() {
    long foo;
    b.c blat = 3;
  }
}
class a {
 int b() { throw 23 barf ; }
}
class a {
  static private {}
};
class a {
  int b() { while (this) this("b" 23) ; }
}
class a {
  b c() {
    for ( ; )
  }
}
class a {
  int b() { while (this) this('a') ; }
}
class a {
  int b() { while (new fred.)
                   ; }
}
foobar;
grabowsky {}
snort
class a {
  int foo = {5, };
}
class a {
  int foo() { synchronized ( 3 4 ) ; }
}
class a {
  int b() { while ((3).super) ; }
}
class a {
  b c() {
    for ( int foo = 12, 13; ; )
      23;
  }
}
class a {
  int b() { while ( a ? b :)
                   ; }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task   /*-->*/ hold /*<--*/  fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Expected <<;>> in field declaration instead of <<fn>> at: [32@392, 33@392] */
class a extends c.d implements x, y.z 3 * 4 {}
class a {
  int b() { while ((3).super(12)) ; }
}
class a {
  b c() { if ( 23 ) 32  }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (  /*-->*/ private /*<--*/  pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Expected a parenthesized expression, "this", "super", a literal, "new", an identifier, a basic type, or "void" instead of <<private>> at: [19@329, 25@329] */
class a {
  int b() { while (snort.bar[].)
                   ; }
}
class a {
  int b() { while (snort.bar.class)
                   ; }
}
class a {
 int a() { switch (23) { case 23 } }
}
class a {
  int b() { while ((3).new dribble) ; }
}
class a {
  int b() { while ( a ? b)
                   ; }
}
class a {
 int a() {
   continue
 }
}

class a {
  b c() {
    for 23
  }
}
class a {
  int b() { while ((3).this) ; }
}
class a {
  int b() { while (int[3].class)
                   ; }
}
class a {
  b c() {
    for ( ; ; )
  }
}
class a {
  int b() { while (super . foo)
                   super(12) ; }
}
class a {
  int b() { while (this) this(true , ) ; }
}
class a {
  int b() { while (void.23)
                   ; }
}
package a;
package b;
class a {
  int b() { while (void.class 23)
                   ; }
}
class a {
  int b() {
    switch (
  }
}
class a {
 int a() {
   break
 }
}
@
class a {
 int a() { switch (23) { case : } }
}
{ foo
bar }
]
class a {
  int foo() { synchronized }
}
class a {
  b c() {
    for
  }
}
class a {
  private b.c gorp(int a, ) {}
}
class a {
  int b() { while (new int[] )
                   ; }
}
prototype;
class a {
  int foo() { synchronized ( ) ; }
}
class a {
  int b() { while (snort.bar.new foo.bar)
                   ; }
}
class a {
  int b() { while (int 23)
                   ; }
}
class a {
  b c() {
    do ; while 23
  }
}
class a {
  private foo ;
};
class a {
  int b() { while (nort)
                   ; }
}
class a {
  int b() { while ((3).super.snort(gar)) ; }
}
class a {
  int b() { while ( a ?)
                   ; }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (/*-->> int <<--*/ n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* no formal paramater name found after its type <<n>> at: [41@114, 41@114] */
class a {
  int b() { return 2; }
}
class a {
 a.b snort(c.d e.f, foo bar) {}
}
class a {
  int b() { while ((snort)+foo) ; }
}
class a {
  int b() { return }
}
class a {
  b c() { 
   if ( 23 )
      if (2) 3 
      else 4 ;
   else {} }
}
class a {
 b c() { foo 3; }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* 
compilationUnit
  packageDcl( \/\/  Based on original version written in BCPL by Dr Martin Richards \/\/  in 1981 at Cambridge University Computer Laboratory, England \/\/  and a C++ version derived from a Smalltalk version written by \/\/  L Peter Deutsch. \/\/  Java version:  Copyright (C) 1995 Sun Microsystems, Inc. \/\/  Translation from C++, Mario Wolczko \/\/  Outer loop added by Alex Jacoby )  package
    nameNode COM . sun . labs . kanban . richards_deutsch_acc_virtual ;
  importDcl import
    nameNode Benchmark ;
  classDcl( \/\/----- Packet ------------------------------------------------------- )  class Packet
    extendsClass
    implementsInterfaces
    classBody {
      varDclsStatement
        modifiers static final
        basicType int
        variableDeclarator BUFSIZE =
          scalarInitializer 4 ;
      varDclsStatement
        modifiers private
        classOrInterfaceType
          nameNode Packet
        variableDeclarator link ;
      varDclsStatement
        modifiers private
        basicType int
        variableDeclarator id ;
      varDclsStatement
        modifiers private
        basicType int
        variableDeclarator kind ;
      varDclsStatement
        modifiers private
        basicType int
        variableDeclarator datum ;
      varDclsStatement
        modifiers private
        arrayType
          basicType int
          squareList [ ]
        variableDeclarator data =
          scalarInitializer
            newArray new
              basicType int
              dimensionExpression [
                nameNode BUFSIZE ] ;
      constructorDcl
        classOrInterfaceType
          nameNode Packet
        attributeName Packet
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet l ,
          formalParameter
            basicType int i ,
          formalParameter
            basicType int k )
        throws
        block {
          expressionStatement
            methodInvocation
              nameNode SetLink
              argumentList (
                argument
                  nameNode l ) ;
          expressionStatement
            methodInvocation
              nameNode SetIdent
              argumentList (
                argument
                  nameNode i ) ;
          expressionStatement
            methodInvocation
              nameNode SetKind
              argumentList (
                argument
                  nameNode k ) ;
          expressionStatement
            methodInvocation
              nameNode SetDatum
              argumentList (
                argument 0 ) ;
          forStatement for
            forParenList (
              forInit
                varDclsStatement
                  basicType int
                  variableDeclarator j =
                    scalarInitializer 0 ;
              forCond
                infixExpression
                  nameNode j <
                  nameNode BUFSIZE ;
              forUpdate
                statementExpressionList
                  postfixExpression
                    nameNode j ++ )
            expressionStatement
              methodInvocation
                nameNode SetData
                argumentList (
                  argument
                    nameNode j ,
                  argument 0 ) ; }
      methodDcl
        classOrInterfaceType
          nameNode Packet
        attributeName Link
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode link ; }
      methodDcl
        basicType int
        attributeName Ident
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode id ; }
      methodDcl
        basicType int
        attributeName Kind
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode kind ; }
      methodDcl
        basicType int
        attributeName Datum
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode datum ; }
      methodDcl
        basicType void
        attributeName SetLink
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet l )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode link =
              nameNode l ; }
      methodDcl
        basicType void
        attributeName SetIdent
        formalParameterList (
          formalParameter
            basicType int i )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode id =
              nameNode i ; }
      methodDcl
        basicType void
        attributeName SetKind
        formalParameterList (
          formalParameter
            basicType int k )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode kind =
              nameNode k ; }
      methodDcl
        basicType void
        attributeName SetDatum
        formalParameterList (
          formalParameter
            basicType int d )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode datum =
              nameNode d ; }
      methodDcl
        basicType int
        attributeName Data
        formalParameterList (
          formalParameter
            basicType int i )
        throws
        block {
          returnStatement return
            arrayAccess
              nameNode data
              dimensionExpression [
                nameNode i ] ; }
      methodDcl
        basicType void
        attributeName SetData
        formalParameterList (
          formalParameter
            basicType int i ,
          formalParameter
            basicType int d )
        throws
        block {
          expressionStatement
            infixExpression
              arrayAccess
                nameNode data
                dimensionExpression [
                  nameNode i ] =
              nameNode d ; }
      methodDcl
        classOrInterfaceType
          nameNode Packet
        attributeName append_to
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet list )
        throws
        block {
          expressionStatement
            methodInvocation
              nameNode SetLink
              argumentList (
                argument null ) ;
          ifStatement if
            parenList (
              infixExpression
                nameNode list == null )
            returnStatement return this ; else
            blockStatement
              block {
                varDclsStatement
                  classOrInterfaceType
                    nameNode Packet
                  variableDeclarator p =
                    scalarInitializer
                      nameNode list ;
                varDclsStatement
                  classOrInterfaceType
                    nameNode Packet
                  variableDeclarator next =
                    scalarInitializer
                      methodInvocation
                        nameNode p . Link
                        argumentList ( ) ;
                whileStatement while
                  parenList (
                    infixExpression
                      nameNode next != null )
                  blockStatement
                    block {
                      expressionStatement
                        infixExpression
                          nameNode p =
                          nameNode next ;
                      expressionStatement
                        infixExpression
                          nameNode next =
                          methodInvocation
                            nameNode p . Link
                            argumentList ( ) ; }
                expressionStatement
                  methodInvocation
                    nameNode p . SetLink
                    argumentList (
                      argument this ) ;
                returnStatement return
                  nameNode list ; } } }
  classDcl
    modifiers( \/\/----- Task Records------------------------------ )  abstract class TaskRec
    extendsClass
    implementsInterfaces
    classBody { } ( \/\/ so we have a common type for all task records ) 
  classDcl class DeviceTaskRec
    extendsClass extends
      classOrInterfaceName TaskRec
    implementsInterfaces
    classBody {
      varDclsStatement
        modifiers private
        classOrInterfaceType
          nameNode Packet
        variableDeclarator pending ;
      constructorDcl
        classOrInterfaceType
          nameNode DeviceTaskRec
        attributeName DeviceTaskRec
        formalParameterList ( )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode pending = null ; }
      methodDcl
        classOrInterfaceType
          nameNode Packet
        attributeName Pending
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode pending ; }
      methodDcl
        basicType void
        attributeName SetPending
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet p )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode pending =
              nameNode p ; } }
  classDcl class IdleTaskRec
    extendsClass extends
      classOrInterfaceName TaskRec
    implementsInterfaces
    classBody {
      varDclsStatement
        modifiers private
        basicType int
        variableDeclarator control ,
        variableDeclarator count ;
      constructorDcl
        classOrInterfaceType
          nameNode IdleTaskRec
        attributeName IdleTaskRec
        formalParameterList ( )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode control = 1 ;
          expressionStatement
            infixExpression
              nameNode count = 10000 ; }
      methodDcl
        basicType int
        attributeName Control
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode control ; }
      methodDcl
        basicType int
        attributeName Count
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode count ; }
      methodDcl
        basicType void
        attributeName SetControl
        formalParameterList (
          formalParameter
            basicType int n )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode control =
              nameNode n ; }
      methodDcl
        basicType void
        attributeName SetCount
        formalParameterList (
          formalParameter
            basicType int n )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode count =
              nameNode n ; } }
  classDcl class HandlerTaskRec
    extendsClass extends
      classOrInterfaceName TaskRec
    implementsInterfaces
    classBody {
      varDclsStatement
        modifiers private
        classOrInterfaceType
          nameNode Packet
        variableDeclarator workIn ,
        variableDeclarator deviceIn ;
      constructorDcl
        classOrInterfaceType
          nameNode HandlerTaskRec
        attributeName HandlerTaskRec
        formalParameterList ( )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode workIn =
              infixExpression
                nameNode deviceIn = null ; }
      methodDcl
        classOrInterfaceType
          nameNode Packet
        attributeName WorkIn
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode workIn ; }
      methodDcl
        classOrInterfaceType
          nameNode Packet
        attributeName DeviceIn
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode deviceIn ; }
      methodDcl
        basicType void
        attributeName SetDeviceIn
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet p )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode deviceIn =
              nameNode p ; }
      methodDcl
        basicType void
        attributeName SetWorkIn
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet p )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode workIn =
              nameNode p ; }
      methodDcl
        classOrInterfaceType
          nameNode Packet
        attributeName WorkInAdd
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet p )
        throws
        block {
          returnStatement return
            infixExpression
              nameNode workIn =
              methodInvocation
                nameNode p . append_to
                argumentList (
                  argument
                    nameNode workIn ) ; }
      methodDcl
        classOrInterfaceType
          nameNode Packet
        attributeName DeviceInAdd
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet p )
        throws
        block {
          returnStatement return
            infixExpression
              nameNode deviceIn =
              methodInvocation
                nameNode p . append_to
                argumentList (
                  argument
                    nameNode deviceIn ) ; } }
  classDcl class WorkerTaskRec
    extendsClass extends
      classOrInterfaceName TaskRec
    implementsInterfaces
    classBody {
      varDclsStatement
        modifiers private
        basicType int
        variableDeclarator destination ;
      varDclsStatement
        modifiers private
        basicType int
        variableDeclarator count ;
      constructorDcl
        classOrInterfaceType
          nameNode WorkerTaskRec
        attributeName WorkerTaskRec
        formalParameterList ( )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode destination =
              nameNode Richards . I_HANDLERA ;
          expressionStatement
            infixExpression
              nameNode count = 0 ; }
      methodDcl
        basicType int
        attributeName Count
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode count ; }
      methodDcl
        basicType int
        attributeName Destination
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode destination ; }
      methodDcl
        basicType void
        attributeName SetCount
        formalParameterList (
          formalParameter
            basicType int n )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode count =
              nameNode n ; }
      methodDcl
        basicType void
        attributeName SetDestination
        formalParameterList (
          formalParameter
            basicType int d )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode destination =
              nameNode d ; } }
  classDcl( \/\/----- Task --------------------------------------------------------- )  class TaskState
    extendsClass
    implementsInterfaces
    classBody {
      varDclsStatement
        modifiers protected
        basicType boolean
        variableDeclarator packetPending ,
        variableDeclarator taskWaiting ,
        variableDeclarator taskHolding ;
      constructorDcl
        classOrInterfaceType
          nameNode TaskState
        attributeName TaskState
        formalParameterList ( )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode packetPending = true ;
          expressionStatement
            infixExpression
              nameNode taskWaiting = false ;
          expressionStatement
            infixExpression
              nameNode taskHolding = false ; }
      methodDcl
        classOrInterfaceType
          nameNode TaskState
        attributeName PacketPending
        formalParameterList ( )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode packetPending = true ;
          expressionStatement
            infixExpression
              nameNode taskWaiting =
              infixExpression
                nameNode taskHolding = false ;
          returnStatement return this ; }
      methodDcl
        classOrInterfaceType
          nameNode TaskState
        attributeName Waiting
        formalParameterList ( )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode packetPending =
              infixExpression
                nameNode taskHolding = false ;
          expressionStatement
            infixExpression
              nameNode taskWaiting = true ;
          returnStatement return this ; }
      methodDcl
        classOrInterfaceType
          nameNode TaskState
        attributeName Running
        formalParameterList ( )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode packetPending =
              infixExpression
                nameNode taskWaiting =
                infixExpression
                  nameNode taskHolding = false ;
          returnStatement return this ; }
      methodDcl
        classOrInterfaceType
          nameNode TaskState
        attributeName WaitingWithPacket
        formalParameterList ( )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode packetPending =
              infixExpression
                nameNode taskWaiting = true ;
          expressionStatement
            infixExpression
              nameNode taskHolding = false ;
          returnStatement return this ; }
      methodDcl
        basicType( \/\* accessing \*\/ )  boolean
        attributeName IsPacketPending
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode packetPending ; }
      methodDcl
        basicType boolean
        attributeName IsTaskWaiting
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode taskWaiting ; }
      methodDcl
        basicType boolean
        attributeName IsTaskHolding
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode taskHolding ; }
      methodDcl
        basicType void
        attributeName SetTaskHolding
        formalParameterList (
          formalParameter
            basicType boolean state )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode taskHolding =
              nameNode state ; }
      methodDcl
        basicType void
        attributeName SetTaskWaiting
        formalParameterList (
          formalParameter
            basicType boolean state )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode taskWaiting =
              nameNode state ; }
      methodDcl
        basicType void
        attributeName SetPacketPending
        formalParameterList (
          formalParameter
            basicType boolean state )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode packetPending =
              nameNode state ; }
      methodDcl
        basicType( \/\* testing \*\/ )  boolean
        attributeName IsTaskHoldingOrWaiting
        formalParameterList ( )
        throws
        block {
          returnStatement return
            infixExpression
              infixExpression
                methodInvocation
                  nameNode IsTaskHolding
                  argumentList ( ) ||
                prefixExpression !
                  methodInvocation
                    nameNode IsPacketPending
                    argumentList ( ) &&
              methodInvocation
                nameNode IsTaskWaiting
                argumentList ( ) ; }
      methodDcl
        basicType boolean
        attributeName IsWaitingWithPacket
        formalParameterList ( )
        throws
        block {
          returnStatement return
            infixExpression
              infixExpression
                methodInvocation
                  nameNode IsPacketPending
                  argumentList ( ) &&
                methodInvocation
                  nameNode IsTaskWaiting
                  argumentList ( ) &&
              prefixExpression !
                methodInvocation
                  nameNode IsTaskHolding
                  argumentList ( ) ; } }
  classDcl
    modifiers abstract class Task
    extendsClass extends
      classOrInterfaceName TaskState
    implementsInterfaces
    classBody {
      varDclsStatement
        modifiers static
        basicType int
        variableDeclarator layout =
          scalarInitializer 0 ;
      varDclsStatement
        modifiers protected
        classOrInterfaceType
          nameNode Task
        variableDeclarator link ;
      varDclsStatement
        modifiers protected
        basicType int
        variableDeclarator id ;
      varDclsStatement
        modifiers protected
        basicType int
        variableDeclarator pri ;
      varDclsStatement
        modifiers protected
        classOrInterfaceType
          nameNode Packet
        variableDeclarator wkq ;
      varDclsStatement
        modifiers protected
        classOrInterfaceType
          nameNode TaskRec
        variableDeclarator handle ;
      methodDcl
        classOrInterfaceType
          nameNode Task
        attributeName Link
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode link ; }
      methodDcl
        basicType int
        attributeName Ident
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode id ; }
      methodDcl
        basicType int
        attributeName Priority
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode pri ; }
      methodDcl
        classOrInterfaceType
          nameNode Packet
        attributeName Input
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode wkq ; }
      methodDcl
        classOrInterfaceType
          nameNode TaskRec
        attributeName Handle
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode handle ; }
      methodDcl
        basicType void
        attributeName SetLink
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Task x )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode link =
              nameNode x ; }
      methodDcl
        basicType void
        attributeName SetIdent
        formalParameterList (
          formalParameter
            basicType int x )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode id =
              nameNode x ; }
      methodDcl
        basicType void
        attributeName SetPriority
        formalParameterList (
          formalParameter
            basicType int x )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode pri =
              nameNode x ; }
      methodDcl
        basicType void
        attributeName SetInput
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet x )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode wkq =
              nameNode x ; }
      methodDcl
        basicType void
        attributeName SetHandle
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode TaskRec x )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode handle =
              nameNode x ; }
      varDclsStatement
        modifiers static final
        basicType int
        variableDeclarator TaskTabSize =
          scalarInitializer 10 ;
      varDclsStatement
        modifiers private static
        arrayType
          classOrInterfaceType
            nameNode Task
          squareList [ ]
        variableDeclarator taskTab =
          scalarInitializer
            newArray new
              classOrInterfaceType
                nameNode Task
              dimensionExpression [
                nameNode TaskTabSize ] ;
      methodDcl
        modifiers static
        classOrInterfaceType
          nameNode Task
        attributeName TaskTab
        formalParameterList (
          formalParameter
            basicType int i )
        throws
        block {
          returnStatement return
            arrayAccess
              nameNode taskTab
              dimensionExpression [
                nameNode i ] ; }
      methodDcl
        modifiers static
        basicType void
        attributeName SetTaskTab
        formalParameterList (
          formalParameter
            basicType int i ,
          formalParameter
            classOrInterfaceType
              nameNode Task t )
        throws
        block {
          expressionStatement
            infixExpression
              arrayAccess
                nameNode taskTab
                dimensionExpression [
                  nameNode i ] =
              nameNode t ; }
      varDclsStatement
        modifiers static
        classOrInterfaceType
          nameNode Task
        variableDeclarator taskList ;
      varDclsStatement
        modifiers static final
        basicType boolean
        variableDeclarator tracing =
          scalarInitializer false ;
      varDclsStatement
        modifiers private static
        basicType int
        variableDeclarator holdCount =
          scalarInitializer 0 ;
      varDclsStatement
        modifiers private static
        basicType int
        variableDeclarator qpktCount =
          scalarInitializer 0 ;
      methodDcl
        modifiers static
        basicType int
        attributeName get_holdCount
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode holdCount ; }
      methodDcl
        modifiers static
        basicType void
        attributeName set_holdCount
        formalParameterList (
          formalParameter
            basicType int i )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode holdCount =
              nameNode i ; }
      methodDcl
        modifiers static
        basicType int
        attributeName get_queuePacketCount
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode qpktCount ; }
      methodDcl
        modifiers static
        basicType void
        attributeName set_queuePacketCount
        formalParameterList (
          formalParameter
            basicType int i )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode qpktCount =
              nameNode i ; }
      constructorDcl
        classOrInterfaceType
          nameNode Task
        attributeName Task
        formalParameterList (
          formalParameter
            basicType int i ,
          formalParameter
            basicType int p ,
          formalParameter
            classOrInterfaceType
              nameNode Packet w ,
          formalParameter
            classOrInterfaceType
              nameNode TaskState initialState ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws
        block {
          expressionStatement
            infixExpression
              nameNode link =
              nameNode taskList ;
          expressionStatement
            methodInvocation
              nameNode SetIdent
              argumentList (
                argument
                  nameNode i ) ;
          expressionStatement
            methodInvocation
              nameNode SetPriority
              argumentList (
                argument
                  nameNode p ) ;
          expressionStatement
            methodInvocation
              nameNode SetInput
              argumentList (
                argument
                  nameNode w ) ;
          expressionStatement
            methodInvocation
              nameNode SetPacketPending
              argumentList (
                argument
                  methodInvocation
                    nameNode initialState . IsPacketPending
                    argumentList ( ) ) ;
          expressionStatement
            methodInvocation
              nameNode SetTaskWaiting
              argumentList (
                argument
                  methodInvocation
                    nameNode initialState . IsTaskWaiting
                    argumentList ( ) ) ;
          expressionStatement
            methodInvocation
              nameNode SetTaskHolding
              argumentList (
                argument
                  methodInvocation
                    nameNode initialState . IsTaskHolding
                    argumentList ( ) ) ;
          expressionStatement
            methodInvocation
              nameNode SetHandle
              argumentList (
                argument
                  nameNode r ) ;
          expressionStatement
            infixExpression
              nameNode taskList = this ;
          expressionStatement
            methodInvocation
              nameNode SetTaskTab
              argumentList (
                argument
                  nameNode i ,
                argument this ) ; }
      methodDcl
        modifiers abstract
        classOrInterfaceType
          nameNode Task
        attributeName fn
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet pkt ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws ;
      methodDcl
        modifiers private
        classOrInterfaceType
          nameNode Task
        attributeName AddPacket
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet p ,
          formalParameter
            classOrInterfaceType
              nameNode Task old )
        throws
        block {
          ifStatement if
            parenList (
              infixExpression
                methodInvocation
                  nameNode Input
                  argumentList ( ) == null )
            blockStatement
              block {
                expressionStatement
                  methodInvocation
                    nameNode SetInput
                    argumentList (
                      argument
                        nameNode p ) ;
                expressionStatement
                  methodInvocation
                    nameNode SetPacketPending
                    argumentList (
                      argument true ) ;
                ifStatement if
                  parenList (
                    infixExpression
                      methodInvocation
                        nameNode Priority
                        argumentList ( ) >
                      methodInvocation
                        nameNode old . Priority
                        argumentList ( ) )
                  returnStatement return this ; } else
            blockStatement
              block {
                expressionStatement
                  methodInvocation
                    nameNode p . append_to
                    argumentList (
                      argument
                        methodInvocation
                          nameNode Input
                          argumentList ( ) ) ; }
          returnStatement return
            nameNode old ; }
      methodDcl
        classOrInterfaceType
          nameNode Task
        attributeName RunTask
        formalParameterList ( )
        throws
        block {
          varDclsStatement
            classOrInterfaceType
              nameNode Packet
            variableDeclarator msg ;
          ifStatement if
            parenList (
              methodInvocation
                nameNode IsWaitingWithPacket
                argumentList ( ) )
            blockStatement
              block {
                expressionStatement
                  infixExpression
                    nameNode msg =
                    methodInvocation
                      nameNode Input
                      argumentList ( ) ;
                expressionStatement
                  methodInvocation
                    nameNode SetInput
                    argumentList (
                      argument
                        methodInvocation
                          nameNode msg . Link
                          argumentList ( ) ) ;
                ifStatement if
                  parenList (
                    infixExpression
                      methodInvocation
                        nameNode Input
                        argumentList ( ) == null )
                  expressionStatement
                    methodInvocation
                      nameNode Running
                      argumentList ( ) ; else
                  expressionStatement
                    methodInvocation
                      nameNode PacketPending
                      argumentList ( ) ; } else
            blockStatement
              block {
                expressionStatement
                  infixExpression
                    nameNode msg = null ; }
          returnStatement return
            methodInvocation
              nameNode fn
              argumentList (
                argument
                  nameNode msg ,
                argument
                  methodInvocation
                    nameNode Handle
                    argumentList ( ) ) ; }
      methodDcl
        modifiers protected
        classOrInterfaceType
          nameNode Task
        attributeName waitTask
        formalParameterList ( )
        throws
        block {
          expressionStatement
            methodInvocation
              nameNode SetTaskWaiting
              argumentList (
                argument true ) ;
          returnStatement return this ; }
      methodDcl
        modifiers protected
        classOrInterfaceType
          nameNode Task
        attributeName hold
        formalParameterList ( )
        throws
        block {
          expressionStatement
            methodInvocation
              nameNode set_holdCount
              argumentList (
                argument
                  infixExpression
                    methodInvocation
                      nameNode get_holdCount
                      argumentList ( ) + 1 ) ;
          expressionStatement
            methodInvocation
              nameNode SetTaskHolding
              argumentList (
                argument true ) ;
          returnStatement return
            methodInvocation
              nameNode Link
              argumentList ( ) ; }
      methodDcl
        modifiers protected
        classOrInterfaceType
          nameNode Task
        attributeName release
        formalParameterList (
          formalParameter
            basicType int i )
        throws
        block {
          varDclsStatement
            classOrInterfaceType
              nameNode Task
            variableDeclarator t =
              scalarInitializer
                methodInvocation
                  nameNode findtcb
                  argumentList (
                    argument
                      nameNode i ) ;
          expressionStatement
            methodInvocation
              nameNode t . SetTaskHolding
              argumentList (
                argument false ) ;
          returnStatement return
            expressionIf
              infixExpression
                methodInvocation
                  nameNode t . Priority
                  argumentList ( ) >
                methodInvocation
                  nameNode Priority
                  argumentList ( ) ?
              nameNode t : this ; }
      methodDcl
        modifiers protected
        classOrInterfaceType
          nameNode Task
        attributeName qpkt
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet pkt )
        throws
        block {
          varDclsStatement
            classOrInterfaceType
              nameNode Task
            variableDeclarator t =
              scalarInitializer
                methodInvocation
                  nameNode findtcb
                  argumentList (
                    argument
                      methodInvocation
                        nameNode pkt . Ident
                        argumentList ( ) ) ;
          expressionStatement
            methodInvocation
              nameNode set_queuePacketCount
              argumentList (
                argument
                  infixExpression
                    methodInvocation
                      nameNode get_queuePacketCount
                      argumentList ( ) + 1 ) ;
          expressionStatement
            methodInvocation
              nameNode pkt . SetLink
              argumentList (
                argument null ) ;
          expressionStatement
            methodInvocation
              nameNode pkt . SetIdent
              argumentList (
                argument
                  methodInvocation
                    nameNode Ident
                    argumentList ( ) ) ;
          returnStatement return
            methodInvocation
              nameNode t . AddPacket
              argumentList (
                argument
                  nameNode pkt ,
                argument this ) ; }
      methodDcl
        modifiers static
        classOrInterfaceType
          nameNode Task
        attributeName findtcb
        formalParameterList (
          formalParameter
            basicType int id )
        throws
        block {
          varDclsStatement
            classOrInterfaceType
              nameNode Task
            variableDeclarator t =
              scalarInitializer
                methodInvocation
                  nameNode Task . TaskTab
                  argumentList (
                    argument
                      nameNode id ) ;
          ifStatement if
            parenList (
              infixExpression
                nameNode t == null )
            expressionStatement
              methodInvocation
                nameNode System . out . println
                argumentList (
                  argument
                    infixExpression '
Bad task id ' +
                      nameNode id ) ;
          returnStatement return
            nameNode t ; }
      methodDcl
        modifiers static
        basicType void
        attributeName trace
        formalParameterList (
          formalParameter
            basicType char a )
        throws
        block {
          ifStatement if
            parenList (
              infixExpression
                prefixExpression --
                  nameNode layout <= 0 )
            blockStatement
              block {
                expressionStatement
                  methodInvocation
                    nameNode System . out . println
                    argumentList ( ) ;
                expressionStatement
                  infixExpression
                    nameNode layout = 50 ; }
          expressionStatement
            methodInvocation
              nameNode System . out . print
              argumentList (
                argument
                  nameNode a ) ; } }
  classDcl( \/\/----- DeviceTask --------------------------------------------------- )  class DeviceTask
    extendsClass extends
      classOrInterfaceName Task
    implementsInterfaces
    classBody {
      constructorDcl
        classOrInterfaceType
          nameNode DeviceTask
        attributeName DeviceTask
        formalParameterList (
          formalParameter
            basicType int i ,
          formalParameter
            basicType int p ,
          formalParameter
            classOrInterfaceType
              nameNode Packet w ,
          formalParameter
            classOrInterfaceType
              nameNode TaskState s ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws
        block {
          expressionStatement
            superInvocation super
              argumentList (
                argument
                  nameNode i ,
                argument
                  nameNode p ,
                argument
                  nameNode w ,
                argument
                  nameNode s ,
                argument
                  nameNode r ) ; }
      methodDcl
        classOrInterfaceType
          nameNode Task
        attributeName fn
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet pkt ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws
        block {
          varDclsStatement
            classOrInterfaceType
              nameNode DeviceTaskRec
            variableDeclarator d =
              scalarInitializer
                prefixExpression
                  coersion (
                    classOrInterfaceType
                      nameNode DeviceTaskRec )
                  nameNode r ;
          ifStatement if
            parenList (
              infixExpression
                nameNode pkt == null )
            blockStatement
              block {
                expressionStatement
                  infixExpression
                    nameNode pkt =
                    methodInvocation
                      nameNode d . Pending
                      argumentList ( ) ;
                ifStatement if
                  parenList (
                    infixExpression
                      nameNode pkt == null )
                  returnStatement return
                    methodInvocation
                      nameNode waitTask
                      argumentList ( ) ; else
                  blockStatement
                    block {
                      expressionStatement
                        methodInvocation
                          nameNode d . SetPending
                          argumentList (
                            argument null ) ;
                      returnStatement return
                        methodInvocation
                          nameNode qpkt
                          argumentList (
                            argument
                              nameNode pkt ) ; } } else
            blockStatement
              block {
                expressionStatement
                  methodInvocation
                    nameNode d . SetPending
                    argumentList (
                      argument
                        nameNode pkt ) ;
                ifStatement if
                  parenList (
                    nameNode tracing )
                  expressionStatement
                    methodInvocation
                      nameNode trace
                      argumentList (
                        argument
                          prefixExpression
                            coersion (
                              basicType char )
                            methodInvocation
                              nameNode pkt . Datum
                              argumentList ( ) ) ;
                returnStatement return
                  methodInvocation
                    nameNode hold
                    argumentList ( ) ; } } }
  classDcl( \/\/----- HandlerTask -------------------------------------------------- )  class HandlerTask
    extendsClass extends
      classOrInterfaceName Task
    implementsInterfaces
    classBody {
      constructorDcl
        classOrInterfaceType
          nameNode HandlerTask
        attributeName HandlerTask
        formalParameterList (
          formalParameter
            basicType int i ,
          formalParameter
            basicType int p ,
          formalParameter
            classOrInterfaceType
              nameNode Packet w ,
          formalParameter
            classOrInterfaceType
              nameNode TaskState s ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws
        block {
          expressionStatement
            superInvocation super
              argumentList (
                argument
                  nameNode i ,
                argument
                  nameNode p ,
                argument
                  nameNode w ,
                argument
                  nameNode s ,
                argument
                  nameNode r ) ; }
      methodDcl
        classOrInterfaceType
          nameNode Task
        attributeName fn
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet pkt ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws
        block {
          varDclsStatement
            classOrInterfaceType
              nameNode HandlerTaskRec
            variableDeclarator h =
              scalarInitializer
                prefixExpression
                  coersion (
                    classOrInterfaceType
                      nameNode HandlerTaskRec )
                  nameNode r ;
          ifStatement if
            parenList (
              infixExpression
                nameNode pkt != null )
            blockStatement
              block {
                ifStatement if
                  parenList (
                    infixExpression
                      methodInvocation
                        nameNode pkt . Kind
                        argumentList ( ) ==
                      nameNode Richards . K_WORK )
                  expressionStatement
                    methodInvocation
                      nameNode h . WorkInAdd
                      argumentList (
                        argument
                          nameNode pkt ) ; else
                  expressionStatement
                    methodInvocation
                      nameNode h . DeviceInAdd
                      argumentList (
                        argument
                          nameNode pkt ) ; }
          varDclsStatement
            classOrInterfaceType
              nameNode Packet
            variableDeclarator work =
              scalarInitializer
                methodInvocation
                  nameNode h . WorkIn
                  argumentList ( ) ;
          ifStatement if
            parenList (
              infixExpression
                nameNode work == null )
            returnStatement return
              methodInvocation
                nameNode waitTask
                argumentList ( ) ;
          varDclsStatement
            basicType int
            variableDeclarator count =
              scalarInitializer
                methodInvocation
                  nameNode work . Datum
                  argumentList ( ) ;
          ifStatement if
            parenList (
              infixExpression
                nameNode count >=
                nameNode Packet . BUFSIZE )
            blockStatement
              block {
                expressionStatement
                  methodInvocation
                    nameNode h . SetWorkIn
                    argumentList (
                      argument
                        methodInvocation
                          nameNode work . Link
                          argumentList ( ) ) ;
                returnStatement return
                  methodInvocation
                    nameNode qpkt
                    argumentList (
                      argument
                        nameNode work ) ; }
          varDclsStatement
            classOrInterfaceType
              nameNode Packet
            variableDeclarator dev =
              scalarInitializer
                methodInvocation
                  nameNode h . DeviceIn
                  argumentList ( ) ;
          ifStatement if
            parenList (
              infixExpression
                nameNode dev == null )
            returnStatement return
              methodInvocation
                nameNode waitTask
                argumentList ( ) ;
          expressionStatement
            methodInvocation
              nameNode h . SetDeviceIn
              argumentList (
                argument
                  methodInvocation
                    nameNode dev . Link
                    argumentList ( ) ) ;
          expressionStatement
            methodInvocation
              nameNode dev . SetDatum
              argumentList (
                argument
                  methodInvocation
                    nameNode work . Data
                    argumentList (
                      argument
                        nameNode count ) ) ;
          expressionStatement
            methodInvocation
              nameNode work . SetDatum
              argumentList (
                argument
                  infixExpression
                    nameNode count + 1 ) ;
          returnStatement return
            methodInvocation
              nameNode qpkt
              argumentList (
                argument
                  nameNode dev ) ; } }
  classDcl( \/\/----- IdleTask ----------------------------------------------------- )  class IdleTask
    extendsClass extends
      classOrInterfaceName Task
    implementsInterfaces
    classBody {
      constructorDcl
        classOrInterfaceType
          nameNode IdleTask
        attributeName IdleTask
        formalParameterList (
          formalParameter
            basicType int i ,
          formalParameter
            basicType int a1 ,
          formalParameter
            basicType int a2 ,
          formalParameter
            classOrInterfaceType
              nameNode TaskState s ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws
        block {
          expressionStatement
            superInvocation super
              argumentList (
                argument
                  nameNode i ,
                argument 0 ,
                argument null ,
                argument
                  nameNode s ,
                argument
                  nameNode r ) ; }
      methodDcl
        classOrInterfaceType
          nameNode Task
        attributeName fn
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet pkt ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws
        block {
          varDclsStatement
            classOrInterfaceType
              nameNode IdleTaskRec
            variableDeclarator i =
              scalarInitializer
                prefixExpression
                  coersion (
                    classOrInterfaceType
                      nameNode IdleTaskRec )
                  nameNode r ;
          expressionStatement
            methodInvocation
              nameNode i . SetCount
              argumentList (
                argument
                  infixExpression
                    methodInvocation
                      nameNode i . Count
                      argumentList ( ) - 1 ) ;
          ifStatement if
            parenList (
              infixExpression
                methodInvocation
                  nameNode i . Count
                  argumentList ( ) == 0 )
            blockStatement
              block {
                returnStatement return
                  methodInvocation
                    nameNode hold
                    argumentList ( ) ; } else
            ifStatement if
              parenList (
                infixExpression
                  parenList (
                    infixExpression
                      methodInvocation
                        nameNode i . Control
                        argumentList ( ) & 1 ) == 0 )
              blockStatement
                block {
                  expressionStatement
                    methodInvocation
                      nameNode i . SetControl
                      argumentList (
                        argument
                          infixExpression
                            methodInvocation
                              nameNode i . Control
                              argumentList ( ) \/ 2 ) ;
                  returnStatement return
                    methodInvocation
                      nameNode release
                      argumentList (
                        argument
                          nameNode Richards . I_DEVA ) ; } else
              blockStatement
                block {
                  expressionStatement
                    methodInvocation
                      nameNode i . SetControl
                      argumentList (
                        argument
                          infixExpression
                            parenList (
                              infixExpression
                                methodInvocation
                                  nameNode i . Control
                                  argumentList ( ) \/ 2 ) ^ 53256 ) ;
                  returnStatement return
                    methodInvocation
                      nameNode release
                      argumentList (
                        argument
                          nameNode Richards . I_DEVB ) ; } } }
  classDcl( \/\/----- WorkTask ----------------------------------------------------- )  class WorkTask
    extendsClass extends
      classOrInterfaceName Task
    implementsInterfaces
    classBody {
      constructorDcl
        classOrInterfaceType
          nameNode WorkTask
        attributeName WorkTask
        formalParameterList (
          formalParameter
            basicType int i ,
          formalParameter
            basicType int p ,
          formalParameter
            classOrInterfaceType
              nameNode Packet w ,
          formalParameter
            classOrInterfaceType
              nameNode TaskState s ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws
        block {
          expressionStatement
            superInvocation super
              argumentList (
                argument
                  nameNode i ,
                argument
                  nameNode p ,
                argument
                  nameNode w ,
                argument
                  nameNode s ,
                argument
                  nameNode r ) ; }
      methodDcl
        classOrInterfaceType
          nameNode Task
        attributeName fn
        formalParameterList (
          formalParameter
            classOrInterfaceType
              nameNode Packet pkt ,
          formalParameter
            classOrInterfaceType
              nameNode TaskRec r )
        throws
        block {
          varDclsStatement
            classOrInterfaceType
              nameNode WorkerTaskRec
            variableDeclarator w =
              scalarInitializer
                prefixExpression
                  coersion (
                    classOrInterfaceType
                      nameNode WorkerTaskRec )
                  nameNode r ;
          ifStatement if
            parenList (
              infixExpression
                nameNode pkt == null )
            returnStatement return
              methodInvocation
                nameNode waitTask
                argumentList ( ) ;
          varDclsStatement
            basicType int
            variableDeclarator dest =
              scalarInitializer
                parenList (
                  expressionIf
                    infixExpression
                      methodInvocation
                        nameNode w . Destination
                        argumentList ( ) ==
                      nameNode Richards . I_HANDLERA ?
                    nameNode Richards . I_HANDLERB :
                    nameNode Richards . I_HANDLERA ) ;
          expressionStatement
            methodInvocation
              nameNode w . SetDestination
              argumentList (
                argument
                  nameNode dest ) ;
          expressionStatement
            methodInvocation
              nameNode pkt . SetIdent
              argumentList (
                argument
                  nameNode dest ) ;
          expressionStatement
            methodInvocation
              nameNode pkt . SetDatum
              argumentList (
                argument 0 ) ;
          forStatement for
            forParenList (
              forInit
                varDclsStatement
                  basicType int
                  variableDeclarator i =
                    scalarInitializer 0 ;
              forCond
                infixExpression
                  nameNode i <
                  nameNode Packet . BUFSIZE ;
              forUpdate
                statementExpressionList
                  postfixExpression
                    nameNode i ++ )
            blockStatement
              block {
                expressionStatement
                  methodInvocation
                    nameNode w . SetCount
                    argumentList (
                      argument
                        infixExpression
                          methodInvocation
                            nameNode w . Count
                            argumentList ( ) + 1 ) ;
                ifStatement if
                  parenList (
                    infixExpression
                      methodInvocation
                        nameNode w . Count
                        argumentList ( ) > 26 )
                  expressionStatement
                    methodInvocation
                      nameNode w . SetCount
                      argumentList (
                        argument 1 ) ;
                expressionStatement
                  methodInvocation
                    nameNode pkt . SetData
                    argumentList (
                      argument
                        nameNode i ,
                      argument
                        infixExpression
                          infixExpression 'A' +
                            methodInvocation
                              nameNode w . Count
                              argumentList ( ) - 1 ) ; }
          returnStatement return
            methodInvocation
              nameNode qpkt
              argumentList (
                argument
                  nameNode pkt ) ; } }
  classDcl
    modifiers( \/\/----- Richards ----------------------------------------------------- )  public class Richards
    extendsClass
    implementsInterfaces implements
      classOrInterfaceName Benchmark
    classBody {
      varDclsStatement
        modifiers private
        basicType long
        variableDeclarator total_ms ;
      methodDcl
        modifiers public
        basicType long
        attributeName getRunTime
        formalParameterList ( )
        throws
        block {
          returnStatement return
            nameNode total_ms ; }
      methodDcl
        modifiers public static
        basicType void
        attributeName main
        formalParameterList (
          formalParameter
            arrayType
              classOrInterfaceType
                nameNode String
              squareList [ ] args )
        throws
        block {
          expressionStatement
            postfixExpression
              parenList (
                newInstance new
                  classOrInterfaceType
                    nameNode Richards
                  argumentList ( ) )
              messageSelector . inst_main
                argumentList (
                  argument
                    nameNode args ) ; }
      varDclsStatement
        modifiers static
        basicType int
        variableDeclarator iterations =
          scalarInitializer 10 ;
      methodDcl
        modifiers public
        basicType void
        attributeName inst_main
        formalParameterList (
          formalParameter
            arrayType
              classOrInterfaceType
                nameNode String
              squareList [ ] args )
        throws
        block {
          expressionStatement
            methodInvocation
              nameNode System . out . println
              argumentList (
                argument 'Richards benchmark (deutsch_acc_virtual) starting...' ) ;
          varDclsStatement
            basicType long
            variableDeclarator startTime =
              scalarInitializer
                methodInvocation
                  nameNode System . currentTimeMillis
                  argumentList ( ) ;
          ifStatement if
            parenList (
              prefixExpression !
                methodInvocation
                  nameNode run
                  argumentList ( ) )
            returnStatement return ;
          varDclsStatement
            basicType long
            variableDeclarator endTime =
              scalarInitializer
                methodInvocation
                  nameNode System . currentTimeMillis
                  argumentList ( ) ;
          expressionStatement
            methodInvocation
              nameNode System . out . println
              argumentList (
                argument 'finished.' ) ;
          expressionStatement
            infixExpression
              nameNode total_ms =
              infixExpression
                nameNode endTime -
                nameNode startTime ;
          expressionStatement
            methodInvocation
              nameNode System . out . println
              argumentList (
                argument
                  infixExpression
                    infixExpression
                      infixExpression
                        infixExpression 'Total time for ' +
                          nameNode iterations + ' iterations: ' +
                      parenList (
                        infixExpression
                          nameNode total_ms \/ 1000.0 ) + ' secs' ) ;
          expressionStatement
            methodInvocation
              nameNode System . out . println
              argumentList (
                argument
                  infixExpression
                    infixExpression 'Average time per iteration: ' +
                      parenList (
                        infixExpression
                          nameNode total_ms \/
                          nameNode iterations ) + ' ms' ) ; }
      methodDcl
        modifiers static
        basicType void
        attributeName schedule
        formalParameterList ( )
        throws
        block {
          varDclsStatement
            classOrInterfaceType
              nameNode Task
            variableDeclarator t =
              scalarInitializer
                nameNode Task . taskList ;
          whileStatement while
            parenList (
              infixExpression
                nameNode t != null )
            blockStatement
              block {
                varDclsStatement
                  classOrInterfaceType
                    nameNode Packet
                  variableDeclarator pkt =
                    scalarInitializer null ;
                ifStatement if
                  parenList (
                    nameNode Task . tracing )
                  expressionStatement
                    methodInvocation
                      nameNode System . out . println
                      argumentList (
                        argument
                          infixExpression 'tcb=' +
                            methodInvocation
                              nameNode t . Ident
                              argumentList ( ) ) ;
                ifStatement if
                  parenList (
                    methodInvocation
                      nameNode t . IsTaskHoldingOrWaiting
                      argumentList ( ) )
                  expressionStatement
                    infixExpression
                      nameNode t =
                      methodInvocation
                        nameNode t . Link
                        argumentList ( ) ; else
                  blockStatement
                    block {
                      ifStatement if
                        parenList (
                          nameNode Task . tracing )
                        expressionStatement
                          methodInvocation
                            nameNode Task . trace
                            argumentList (
                              argument
                                prefixExpression
                                  coersion (
                                    basicType char )
                                  parenList (
                                    infixExpression '0' +
                                      methodInvocation
                                        nameNode t . Ident
                                        argumentList ( ) ) ) ;
                      expressionStatement
                        infixExpression
                          nameNode t =
                          methodInvocation
                            nameNode t . RunTask
                            argumentList ( ) ; } } }
      methodDcl
        modifiers public
        basicType boolean
        attributeName run
        formalParameterList ( )
        throws
        block {
          forStatement for
            forParenList (
              forInit
                varDclsStatement
                  basicType int
                  variableDeclarator i =
                    scalarInitializer 0 ;
              forCond
                infixExpression
                  nameNode i <
                  nameNode iterations ;
              forUpdate
                statementExpressionList
                  postfixExpression
                    nameNode i ++ )
            blockStatement
              block {
                expressionStatement
                  methodInvocation
                    nameNode Task . set_holdCount
                    argumentList (
                      argument 0 ) ;
                expressionStatement
                  methodInvocation
                    nameNode Task . set_queuePacketCount
                    argumentList (
                      argument 0 ) ; ( \/\/ Added to allow repeated execution ) 
                expressionStatement
                  newInstance( \/\/ of the test.    Ole Agesen, 3\/95. )  new
                    classOrInterfaceType
                      nameNode IdleTask
                    argumentList (
                      argument
                        nameNode I_IDLE ,
                      argument 1 ,
                      argument 10000 ,
                      argument
                        postfixExpression
                          parenList (
                            newInstance new
                              classOrInterfaceType
                                nameNode TaskState
                              argumentList ( ) )
                          messageSelector . Running
                            argumentList ( ) ,
                      argument
                        newInstance new
                          classOrInterfaceType
                            nameNode IdleTaskRec
                          argumentList ( ) ) ;
                varDclsStatement
                  classOrInterfaceType
                    nameNode Packet
                  variableDeclarator wkq =
                    scalarInitializer
                      newInstance new
                        classOrInterfaceType
                          nameNode Packet
                        argumentList (
                          argument null ,
                          argument 0 ,
                          argument
                            nameNode K_WORK ) ;
                expressionStatement
                  infixExpression
                    nameNode wkq =
                    newInstance new
                      classOrInterfaceType
                        nameNode Packet
                      argumentList (
                        argument
                          nameNode wkq ,
                        argument 0 ,
                        argument
                          nameNode K_WORK ) ;
                expressionStatement
                  newInstance new
                    classOrInterfaceType
                      nameNode WorkTask
                    argumentList (
                      argument
                        nameNode I_WORK ,
                      argument 1000 ,
                      argument
                        nameNode wkq ,
                      argument
                        postfixExpression
                          parenList (
                            newInstance new
                              classOrInterfaceType
                                nameNode TaskState
                              argumentList ( ) )
                          messageSelector . WaitingWithPacket
                            argumentList ( ) ,
                      argument
                        newInstance new
                          classOrInterfaceType
                            nameNode WorkerTaskRec
                          argumentList ( ) ) ;
                expressionStatement
                  infixExpression
                    nameNode wkq =
                    newInstance new
                      classOrInterfaceType
                        nameNode Packet
                      argumentList (
                        argument null ,
                        argument
                          nameNode I_DEVA ,
                        argument
                          nameNode K_DEV ) ;
                expressionStatement
                  infixExpression
                    nameNode wkq =
                    newInstance new
                      classOrInterfaceType
                        nameNode Packet
                      argumentList (
                        argument
                          nameNode wkq ,
                        argument
                          nameNode I_DEVA ,
                        argument
                          nameNode K_DEV ) ;
                expressionStatement
                  infixExpression
                    nameNode wkq =
                    newInstance new
                      classOrInterfaceType
                        nameNode Packet
                      argumentList (
                        argument
                          nameNode wkq ,
                        argument
                          nameNode I_DEVA ,
                        argument
                          nameNode K_DEV ) ;
                expressionStatement
                  newInstance new
                    classOrInterfaceType
                      nameNode HandlerTask
                    argumentList (
                      argument
                        nameNode I_HANDLERA ,
                      argument 2000 ,
                      argument
                        nameNode wkq ,
                      argument
                        postfixExpression
                          parenList (
                            newInstance new
                              classOrInterfaceType
                                nameNode TaskState
                              argumentList ( ) )
                          messageSelector . WaitingWithPacket
                            argumentList ( ) ,
                      argument
                        newInstance new
                          classOrInterfaceType
                            nameNode HandlerTaskRec
                          argumentList ( ) ) ;
                expressionStatement
                  infixExpression
                    nameNode wkq =
                    newInstance new
                      classOrInterfaceType
                        nameNode Packet
                      argumentList (
                        argument null ,
                        argument
                          nameNode I_DEVB ,
                        argument
                          nameNode K_DEV ) ;
                expressionStatement
                  infixExpression
                    nameNode wkq =
                    newInstance new
                      classOrInterfaceType
                        nameNode Packet
                      argumentList (
                        argument
                          nameNode wkq ,
                        argument
                          nameNode I_DEVB ,
                        argument
                          nameNode K_DEV ) ;
                expressionStatement
                  infixExpression
                    nameNode wkq =
                    newInstance new
                      classOrInterfaceType
                        nameNode Packet
                      argumentList (
                        argument
                          nameNode wkq ,
                        argument
                          nameNode I_DEVB ,
                        argument
                          nameNode K_DEV ) ;
                expressionStatement
                  newInstance new
                    classOrInterfaceType
                      nameNode HandlerTask
                    argumentList (
                      argument
                        nameNode I_HANDLERB ,
                      argument 3000 ,
                      argument
                        nameNode wkq ,
                      argument
                        postfixExpression
                          parenList (
                            newInstance new
                              classOrInterfaceType
                                nameNode TaskState
                              argumentList ( ) )
                          messageSelector . WaitingWithPacket
                            argumentList ( ) ,
                      argument
                        newInstance new
                          classOrInterfaceType
                            nameNode HandlerTaskRec
                          argumentList ( ) ) ;
                expressionStatement
                  infixExpression
                    nameNode wkq = null ;
                expressionStatement
                  newInstance new
                    classOrInterfaceType
                      nameNode DeviceTask
                    argumentList (
                      argument
                        nameNode I_DEVA ,
                      argument 4000 ,
                      argument
                        nameNode wkq ,
                      argument
                        postfixExpression
                          parenList (
                            newInstance new
                              classOrInterfaceType
                                nameNode TaskState
                              argumentList ( ) )
                          messageSelector . Waiting
                            argumentList ( ) ,
                      argument
                        newInstance new
                          classOrInterfaceType
                            nameNode DeviceTaskRec
                          argumentList ( ) ) ;
                expressionStatement
                  newInstance new
                    classOrInterfaceType
                      nameNode DeviceTask
                    argumentList (
                      argument
                        nameNode I_DEVB ,
                      argument 5000 ,
                      argument
                        nameNode wkq ,
                      argument
                        postfixExpression
                          parenList (
                            newInstance new
                              classOrInterfaceType
                                nameNode TaskState
                              argumentList ( ) )
                          messageSelector . Waiting
                            argumentList ( ) ,
                      argument
                        newInstance new
                          classOrInterfaceType
                            nameNode DeviceTaskRec
                          argumentList ( ) ) ;
                expressionStatement
                  methodInvocation
                    nameNode schedule
                    argumentList ( ) ;
                ifStatement if
                  parenList (
                    infixExpression
                      infixExpression
                        infixExpression
                          methodInvocation
                            nameNode Task . get_queuePacketCount
                            argumentList ( ) == 23246 &&
                        methodInvocation
                          nameNode Task . get_holdCount
                          argumentList ( ) == 9297 )
                  emptyStatement ; ( \/\/ correct )  else
                  blockStatement
                    block {
                      expressionStatement
                        methodInvocation
                          nameNode System . out . println
                          argumentList (
                            argument 'Incorrect results!' ) ;
                      returnStatement return false ; } }
          returnStatement return true ; }
      varDclsStatement
        modifiers( \/\/ Task IDs )  static final
        basicType int
        variableDeclarator I_IDLE =
          scalarInitializer 1 ,
        variableDeclarator I_WORK =
          scalarInitializer 2 ,
        variableDeclarator I_HANDLERA =
          scalarInitializer 3 ,
        variableDeclarator I_HANDLERB =
          scalarInitializer 4 ,
        variableDeclarator I_DEVA =
          scalarInitializer 5 ,
        variableDeclarator I_DEVB =
          scalarInitializer 6 ;
      varDclsStatement
        modifiers( \/\/ Packet types )  static final
        basicType int
        variableDeclarator K_DEV =
          scalarInitializer 1000 ,
        variableDeclarator K_WORK =
          scalarInitializer 1001 ; }
 */
class a {
  int b() { while (new int[3] )
                   ; }
}
class a {
  b c() {
    for ( 12, 13; if ; )
      23;
  }
}
class a {
  int b() { while (this) this() ; }
}
class a {
 int a() { switch (23) { case 23 : } }
}
class a {
  int b() { while ( a ? ? b : snort)
                   ; }
}
class a {
  b c() { 
    while
  }
}
class a {
  int b() { while (super . foo 23)
                   super(12) ; }
}
class a {
  public int snort() {}
};
interface snort {
 int foo();
 final int snort = 3;
}
class a {
  int b() { while (void.class)
                   ; }
}
class a {
  int b() { while (new fred.bob)
                   ; }
}
class a {
  int b() { while ((23.34)) ; }
}
class a {
  int a() {try}
}
class a {
 int a() { switch (23) { case } }
}
class a {
  int b() { while (void)
                   ; }
}
class a {
  int b() {
    switch
  }
}
class a {
  int b() { while ((3).super 23) ; }
}
class a {
  int b() {
    switch ( 34 )
  }
}
class a {
  b() ;
}
interface sludge {
  gunk a1 = 23, frob = 5;
}
class a {
 int a() {
   continue 23
 }
}
class a {
  int b() { while ((3).new) ; }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending()/*-->> ; <<--*/
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Extra junk found in statement <<if>> at: [7@304, 8@304] */
package snort {}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask/*-->> ( <<--*/);

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Opening `{' does not match closing `)' in <<{
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask/*-->> ( <<--*/)>> at: [34@327, 37@337] */
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n)   /*-->*/ class /*<--*/  { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* extra junk in method <<class>> at: [36@83, 40@83] */
class a {
  int b() { while (super.23)
                   super(12) ; }
}
class a {
  int b() { while ((3).super.snort) ; }
}
class a {
  b c() {
    for ( 12, 13; 14 ; 15, 16)
      23;
  }
}
{
more stuff
(yuk)
foo
class a {
  int b() { while (!~foo) ; }
}
class a {
  int foo = ;
}
class a {
 int a() {
   continue ;
 }
}
class a {
  int b() { while (new int[][]{2, 3}[] )
                   ; }
}
class a {
 int a() {
   continue snort ;
 }
}
class a extends {}
class a {
  int b() { while (3 instanceof 23)
                   ; }
}
class a {
  b c() { 
    while ( if
  }
}
class a {
  int b() { while (23) ; }
}
package com.sun.kanban.character_sets;

import com.sun.kanban.utilities.DebugTools;


// used to test if a charcter is in a given class

public class CharacterSetInclusion implements CharacterSetClosure {
    protected boolean _table[];
    
    public CharacterSetInclusion(CharacterSet cc) { 
        _table = new boolean[CharacterSet.max_character_value + 1]; 
        cc.Do(this); 
    }
    
    
    public void for_char_in_class(char c) {
        if (_table[c])
            throw DebugTools.new_error("Duplicate character: " + c);
        _table[c] = true;
    }
    
    public String toString() {
        String s = super.toString() + " including: \"";
        for (char c = 0; c < _table.length; ++c)
            if (includes(c))
                s = s + c;
        return s + "\"";
    }
    
    public boolean includes(char c) { return _table[c]; }
}
/* in one line */
/* across lines
more */
/* this comment /* // /** ends here: */

class test {
  int foo() {
    int a = "Aa \b \t \n \f \r \\ \" \' \0 \7 \12 \321";
    int b[] = {.123 .12e2 .12E-3 0.123
      .123f .12e2F .12E-3d 0.123D
      0.123E4 0.123e-5
      0
      123
      0x123
      0123
      13l
      0xaL
      012l
      123.456
      123.456e6
      123.456e-6
      12.3
      17e+2};

  
class a {
  foo bar(snort frap, 23) ;
}
package 23;
class a {
  int b() { while (int[])
                   ; }
}
class a {
  public int ;
}
class a {
 int a() {
   break snort
 }
}
package ;
class a {
  b() {}
}
static final prototype snort {}
class a {
  int b() { while (snort.bar[34])
                   ; }
}
class a {
  int b() { while (new fred.bob())
                   ; }
}
class a {
 int a() {
   continue snort
 }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void /*-->> trace <<--*/(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* constructor must be a class or interface type <<void>> at: [10@282, 13@282] */
class a {
  int b() { while ((3).snort(3)) ; }
}
class a {
  int foo() { synchronized ( 3 ) {  } }
}
class a {
  int b() { while (new int[3][] )
                   ; }
}
class a {
  b c() {
    do ;
  }
}
class a {
  int b() { while (new fred)
                   ; }
}
class a {
  int foo = {5, {3, 4}};
}
class a {
  int b() { try {} catch (foobar up) {} }
}
class a {
 int b() { throw 23  ; }
}
class a {
  int b() { while ((3).super.) ; }
}
class a {
;
}
class a {
 int a() {
   break snort ;
 }
}
class a {
  int foo() { synchronized ( 3 ) ; }
}
class a {
 int a() { switch (23) { default: } }
}
class a {
  int b() { while ( a += )
                   ; }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l);
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { /*-->> id <<--*/ = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Expected a parenthesized expression, "this", "super", a literal, "new", an identifier, a basic type, or "void" instead of <<=>> at: [50@185, 50@185] */
class a {
  b c() { 
    while ( 23
  }
}
class a {
  int b() { while (new int() )
                   ; }
}
class a {
 int foo() {
   try {} 23 finally;
 }
}
class a {
  int b() { while (snort.bar.super)
                   ; }
}
class a {
  int b() { while (super . 23)
                   super(12) ; }
}
class a {
  int b() { while (new int[][] )
                   ; }
}
//  Based on original version written in BCPL by Dr Martin Richards
//  in 1981 at Cambridge University Computer Laboratory, England
//  and a C++ version derived from a Smalltalk version written by
//  L Peter Deutsch.
//  Java version:  Copyright (C) 1995 Sun Microsystems, Inc.
//  Translation from C++, Mario Wolczko
//  Outer loop added by Alex Jacoby

package COM.sun.labs.kanban.richards_deutsch_acc_virtual;

import Benchmark;

//----- Packet -------------------------------------------------------

class Packet {
  static final int BUFSIZE = 4;

  private Packet link;
  private int id;
  private int kind;
  private int datum;
  private int[] data = new int[BUFSIZE];

  Packet(Packet l, int i, int k) {
    SetLink(l)  /*-->*/ ( /*<--*/  ;
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }

  Packet Link() { return link; }
  int 	Ident() { return id; }
  int    Kind() { return kind; }
  int   Datum() { return datum; }

  void SetLink(Packet l)     { link = l; }
  void SetIdent(int i)       { id = i; }
  void SetKind(int k)        { kind = k; }
  void SetDatum(int d)       { datum = d; }

  int     Data(int i)        { return data[i]; }
  void SetData(int i, int d) { data[i] = d; }

  Packet append_to(Packet list) {
    SetLink(null);
    if (list == null) 
      return this;
    else {
      Packet p = list;
      Packet next = p.Link();
      while (next != null) {
        p = next;
	next = p.Link();
      }
      p.SetLink(this);
      return list;
    }
  }

}

//----- Task Records------------------------------

abstract class TaskRec { } // so we have a common type for all task records

class DeviceTaskRec extends TaskRec {
  private Packet pending;

  DeviceTaskRec()           { pending = null; }
  Packet Pending()          { return pending; }
  void SetPending(Packet p) { pending = p; }
}


class IdleTaskRec extends TaskRec {
  private int control, count;

  IdleTaskRec() { control = 1; count = 10000; }
  int Control() { return control; }
  int Count()   { return count; }
  void SetControl(int n) { control = n; }
  void SetCount(int n)   { count = n; }
}


class HandlerTaskRec extends TaskRec {
  private Packet workIn, deviceIn;

  HandlerTaskRec() { workIn = deviceIn = null; }

  Packet   WorkIn() { return workIn; }
  Packet DeviceIn() { return deviceIn; }

  void SetDeviceIn(Packet p) { deviceIn = p; }
  void SetWorkIn  (Packet p) { workIn = p; }

  Packet   WorkInAdd(Packet p) { return workIn = p.append_to(workIn); }
  Packet DeviceInAdd(Packet p) { return deviceIn = p.append_to(deviceIn); }
}



class WorkerTaskRec extends TaskRec {
  private int destination;
  private int count;

  WorkerTaskRec() { destination = Richards.I_HANDLERA; count = 0; }

  int       Count() { return count; }
  int Destination() { return destination; }

  void SetCount      (int n) { count = n; }
  void SetDestination(int d) { destination = d; }
}


//----- Task ---------------------------------------------------------

class TaskState {

  protected boolean packetPending, taskWaiting, taskHolding;

  TaskState() {
    packetPending = true;
    taskWaiting = false;
    taskHolding = false;
  }

  TaskState PacketPending() {
    packetPending = true;
    taskWaiting = taskHolding = false;
    return this;
  }
  TaskState Waiting() {
    packetPending = taskHolding = false;
    taskWaiting = true;
    return this;
  }
  TaskState Running() {
    packetPending = taskWaiting = taskHolding = false;
    return this;
  }
  TaskState WaitingWithPacket() {
    packetPending = taskWaiting = true; taskHolding = false;
    return this;
  }

  /* accessing */
  boolean IsPacketPending() { return packetPending; }
  boolean IsTaskWaiting()   { return taskWaiting; }
  boolean IsTaskHolding()   { return taskHolding; }

  void SetTaskHolding(boolean state) { taskHolding = state; }
  void SetTaskWaiting(boolean state) { taskWaiting = state; }
  void SetPacketPending(boolean state) { packetPending = state; }

  /* testing */ 
  boolean IsTaskHoldingOrWaiting() {
    return IsTaskHolding() || !IsPacketPending() && IsTaskWaiting();
  }
  boolean IsWaitingWithPacket() {
    return IsPacketPending() && IsTaskWaiting() && !IsTaskHolding();
  }
}

abstract class Task extends TaskState {

  static int layout = 0;

  protected Task link;
  protected int id;
  protected int pri;
  protected Packet wkq;
  protected TaskRec handle;

  Task      Link() { return link; }
  int      Ident() { return id; }
  int   Priority() { return pri; }
  Packet   Input() { return wkq; }
  TaskRec Handle() { return handle; }

  void     SetLink(Task x)    { link = x; }
  void    SetIdent(int x)     { id = x; }
  void SetPriority(int x)     { pri = x; }
  void    SetInput(Packet x)  { wkq = x; }
  void   SetHandle(TaskRec x) { handle = x; }

  static final int TaskTabSize = 10;
  private static Task[] taskTab = new Task[TaskTabSize];
  static Task    TaskTab(int i)         { return taskTab[i]; }
  static void SetTaskTab(int i, Task t) { taskTab[i] = t; }

  static Task taskList;

  static final boolean tracing = false;
  private static int holdCount = 0;
  private static int qpktCount = 0;

  static int  get_holdCount()      { return holdCount; }
  static void set_holdCount(int i) { holdCount = i; }

  static int  get_queuePacketCount()      { return qpktCount; }
  static void set_queuePacketCount(int i) { qpktCount = i; }

  Task(int i, int p, Packet w, TaskState initialState, TaskRec r) {
    link = taskList;
    SetIdent(i);
    SetPriority(p);
    SetInput(w);
    SetPacketPending(initialState.IsPacketPending());
    SetTaskWaiting(initialState.IsTaskWaiting());
    SetTaskHolding(initialState.IsTaskHolding());
    SetHandle(r);
    taskList = this;
    SetTaskTab(i, this);
  }

  abstract Task fn(Packet pkt, TaskRec r);

  private Task AddPacket(Packet p, Task old) {
    if (Input() == null) {
      SetInput(p);
      SetPacketPending(true);
      if (Priority() > old.Priority())
        return this;
    } else {
      p.append_to(Input());
    }
    return old;
  }

  Task RunTask() {
    Packet msg;

    if (IsWaitingWithPacket()) {
      msg = Input();
      SetInput(msg.Link());
      if (Input() == null)
	Running();
      else
	PacketPending();
    } else {
      msg = null;
    }
    return fn(msg, Handle());
  }

  protected Task waitTask() {
    SetTaskWaiting(true);
    return this;
  }

  protected Task hold() {
    set_holdCount(get_holdCount() + 1);
    SetTaskHolding(true);
    return Link();
  }

  protected Task release(int i) {
    Task t = findtcb(i);
    t.SetTaskHolding(false);
    return t.Priority() > Priority() ? t : this;
  }

  protected Task qpkt(Packet pkt) {
    Task t = findtcb(pkt.Ident());
    set_queuePacketCount(get_queuePacketCount() + 1);
    pkt.SetLink(null);
    pkt.SetIdent(Ident());
    return t.AddPacket(pkt, this);
  }

  static Task findtcb(int id) {
    Task t = Task.TaskTab(id);
    if (t == null) 
      System.out.println("\nBad task id " + id);
    return t;
  }

  static void trace(char a) {
    if (--layout <= 0) {
      System.out.println();
      layout = 50;
    }
    System.out.print(a);
  }

}

//----- DeviceTask ---------------------------------------------------

class DeviceTask extends Task
{
  DeviceTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    DeviceTaskRec d = (DeviceTaskRec)r;
    if (pkt == null) {
      pkt = d.Pending();
      if (pkt == null) 
        return waitTask();
      else {
	d.SetPending(null);
	return qpkt(pkt);
      }
    } else {
      d.SetPending(pkt);
      if (tracing) trace((char)pkt.Datum());
      return hold();
    }
  }
}


//----- HandlerTask --------------------------------------------------

class HandlerTask extends Task
{
  HandlerTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    HandlerTaskRec h = (HandlerTaskRec)r;
    if (pkt != null) {
      if (pkt.Kind() == Richards.K_WORK)
	h.WorkInAdd(pkt);
      else
        h.DeviceInAdd(pkt);
    }
    Packet work = h.WorkIn();
    if (work == null)
      return waitTask();

    int count = work.Datum();

    if (count >= Packet.BUFSIZE) {
      h.SetWorkIn(work.Link());
      return qpkt(work);
    }

    Packet dev = h.DeviceIn();
    if (dev == null)
      return waitTask();

    h.SetDeviceIn(dev.Link());
    dev.SetDatum(work.Data(count));
    work.SetDatum(count + 1);
    return qpkt(dev);
  }
}


//----- IdleTask -----------------------------------------------------

class IdleTask extends Task 
{
  IdleTask(int i, int a1, int a2, TaskState s, TaskRec r) {
    super(i, 0, null, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    IdleTaskRec i = (IdleTaskRec)r;

    i.SetCount(i.Count() - 1);
    if (i.Count() == 0) {
      return hold();
    } else if ((i.Control() & 1) == 0) {
      i.SetControl(i.Control() / 2);
      return release(Richards.I_DEVA);
    } else {
      i.SetControl((i.Control() / 2) ^ 0XD008);
      return release(Richards.I_DEVB);
    }
  }

}


//----- WorkTask -----------------------------------------------------

class WorkTask extends Task 
{
  WorkTask(int i, int p, Packet w, TaskState s, TaskRec r) {
    super(i, p, w, s, r);
  }

  Task fn(Packet pkt, TaskRec r) {
    WorkerTaskRec w = (WorkerTaskRec)r;

    if (pkt == null)
      return waitTask();

    int dest = (w.Destination() == Richards.I_HANDLERA
		? Richards.I_HANDLERB
		: Richards.I_HANDLERA);
    w.SetDestination(dest);
    pkt.SetIdent(dest);
    pkt.SetDatum(0);
    for (int i = 0; i < Packet.BUFSIZE; i++) { 
      w.SetCount(w.Count() + 1);
      if (w.Count() > 26) w.SetCount(1);
      pkt.SetData(i, 'A' + w.Count() - 1);
    }
    return qpkt(pkt);
  }
}


//----- Richards -----------------------------------------------------


public class Richards implements Benchmark
{
  private long total_ms;
  public long getRunTime() { return total_ms; }

  public static void main(String[] args) {
    (new Richards()).inst_main(args);
  }

  static int iterations = 10;

  public void inst_main(String[] args) { 
    System.out.println("Richards benchmark (deutsch_acc_virtual) starting...");
    long startTime = System.currentTimeMillis();
    if (!run())
      return;
    long endTime = System.currentTimeMillis();
    System.out.println("finished.");
    total_ms= endTime - startTime;
    System.out.println("Total time for " + iterations + " iterations: "
		       + (total_ms/1000.0) + " secs");
    System.out.println("Average time per iteration: "
		       + (total_ms / iterations) + " ms");
  }

  static void schedule() {
    Task t = Task.taskList;
    while (t != null) {
      Packet pkt = null;

      if (Task.tracing) 
	System.out.println("tcb=" + t.Ident());

      if (t.IsTaskHoldingOrWaiting()) 
        t = t.Link();
      else {
        if (Task.tracing) Task.trace((char)('0' + t.Ident()));
        t = t.RunTask();
      }
    }
  }

  public boolean run() {
    for (int i= 0; i < iterations; i++){
      Task.set_holdCount(0);
      Task.set_queuePacketCount(0);  // Added to allow repeated execution
				     // of the test.    Ole Agesen, 3/95.

      new IdleTask(I_IDLE, 1, 10000, (new TaskState()).Running(),
		   new IdleTaskRec());

      Packet wkq = new Packet(null, 0, K_WORK);
      wkq = new Packet(wkq, 0, K_WORK);
      new WorkTask(I_WORK, 1000, wkq,
		   (new TaskState()).WaitingWithPacket(),
		   new WorkerTaskRec());

      wkq = new Packet(null, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      wkq = new Packet(wkq, I_DEVA, K_DEV);
      new HandlerTask(I_HANDLERA, 2000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = new Packet(null, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      wkq = new Packet(wkq, I_DEVB, K_DEV);
      new HandlerTask(I_HANDLERB, 3000, wkq,
		      (new TaskState()).WaitingWithPacket(),
		      new HandlerTaskRec());

      wkq = null;
      new DeviceTask(I_DEVA, 4000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());
      new DeviceTask(I_DEVB, 5000, wkq, (new TaskState()).Waiting(),
		     new DeviceTaskRec());

      schedule();

      if (Task.get_queuePacketCount() == 23246 && Task.get_holdCount() == 9297) 
        ; // correct
      else {
        System.out.println("Incorrect results!");
        return false;
      }
    }
    return true;
  }

  // Task IDs
  static final int
    I_IDLE = 1,
    I_WORK = 2,
    I_HANDLERA = 3,
    I_HANDLERB = 4,
    I_DEVA = 5,
    I_DEVB = 6;

  // Packet types
  static final int
    K_DEV = 1000,
    K_WORK = 1001;
}
/* Opening `(' does not match closing `}' in <<( /*<--*/  ;
    SetIdent(i);
    SetKind(k);
    SetDatum(0);
    for(int j = 0; j < BUFSIZE; j++)
      SetData(j, 0);
  }>> at: [25@25, 3@31] */
class x {
  y z() {
    234
  }
}
import snort {}
class a {
  b c() {
    for ( 12, 13; 14 ; )
      23;
  }
}
class a {
  int b() { while (( do)) ; }
}
class a {
 int a() { switch (23) { default } }
}
class a {
  int b() {
    switch ( 34 ) { }
    
  }
}
class a {
  int() {}
}
class a {
  b c() { 
    while ( 23 ) 12;
  }
}
class a {
 static { int a; }
}
class a {
  int b() { try {} catch (foobar up) }
}
class a {
  int b() { try {/*A*/} catch (foobar up) {/*B*/} finally {/*C*/} }
}
package * ;
class a {
  b c() { if ( 23 ) }
}
class a {
  int b() { while (new int[3][4] )
                   ; }
}
class a {
  b c() {
    do ; while (
  }
}
class a {
  b c() { if ( 23 ) 32 ; }
}
class a {
  int b() { while (super . foo())
                   super(12) ; }
}
class FileName{
	public static void main(String[] argv){

	}
}
